<!DOCTYPE html>
<html style="display: none;" lang="zh">
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.0 -->
    <script>
        window.materialVersion = "1.5.0"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">














    <!-- Title -->
    
    <title>
        
            Flutter UI 渲染浅析（四）Build | 
        
        w4lle&#39;s Notes
    </title>

    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="format-detection" content="telephone=no"/>
    <meta name="theme-color" content="#0097A7">
    <meta name="author" content="w4lle">
    <!-- fix weibo pic -->
    <meta name="referrer" content="no-referrer" />
    <meta name="description" itemprop="description" content="系列文章的第四篇，本篇文章主要分析下 Element.rebuild() 过程。
源码基于 Flutter v1.20.4。">
    <meta name="keywords" content="Android,Flutter">

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(key){try{localStorage.removeItem(key)}catch(e){}};lsloader.setLS=function(key,val){try{localStorage.setItem(key,val)}catch(e){}};lsloader.getLS=function(key){var val="";try{val=localStorage.getItem(key)}catch(e){val=""}return val};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var keys=[];for(var i=0;i<localStorage.length;i++){keys.push(localStorage.key(i))}keys.forEach(function(key){var data=lsloader.getLS(key);if(window.oldVersion){var remove=window.oldVersion.reduce(function(p,c){return p||data.indexOf("/*"+c+"*/")!==-1},false);if(remove){lsloader.removeLS(key)}}})}catch(e){}};lsloader.clean();lsloader.load=function(jsname,jspath,cssonload,isJs){if(typeof cssonload==="boolean"){isJs=cssonload;cssonload=undefined}isJs=isJs||false;cssonload=cssonload||function(){};var code;code=this.getLS(jsname);if(code&&code.indexOf(versionString)===-1){this.removeLS(jsname);this.requestResource(jsname,jspath,cssonload,isJs);return}if(code){var versionNumber=code.split(versionString)[0];if(versionNumber!=jspath){console.log("reload:"+jspath);this.removeLS(jsname);this.requestResource(jsname,jspath,cssonload,isJs);return}code=code.split(versionString)[1];if(isJs){this.jsRunSequence.push({name:jsname,code:code});this.runjs(jspath,jsname,code)}else{document.getElementById(jsname).appendChild(document.createTextNode(code));cssonload()}}else{this.requestResource(jsname,jspath,cssonload,isJs)}};lsloader.requestResource=function(name,path,cssonload,isJs){var that=this;if(isJs){this.iojs(path,name,function(path,name,code){that.setLS(name,path+versionString+code);that.runjs(path,name,code)})}else{this.iocss(path,name,function(code){document.getElementById(name).appendChild(document.createTextNode(code));that.setLS(name,path+versionString+code)},cssonload)}};lsloader.iojs=function(path,jsname,callback){var that=this;that.jsRunSequence.push({name:jsname,code:""});try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(path,jsname,xhr.response);return}}that.jsfallback(path,jsname)}};xhr.send(null)}catch(e){that.jsfallback(path,jsname)}};lsloader.iocss=function(path,jsname,callback,cssonload){var that=this;try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(xhr.response);cssonload();return}}that.cssfallback(path,jsname,cssonload)}};xhr.send(null)}catch(e){that.cssfallback(path,jsname,cssonload)}};lsloader.iofonts=function(path,jsname,callback,cssonload){var that=this;try{var xhr=new XMLHttpRequest;xhr.open("get",path,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){callback(xhr.response);cssonload();return}}that.cssfallback(path,jsname,cssonload)}};xhr.send(null)}catch(e){that.cssfallback(path,jsname,cssonload)}};lsloader.runjs=function(path,name,code){if(!!name&&!!code){for(var k in this.jsRunSequence){if(this.jsRunSequence[k].name==name){this.jsRunSequence[k].code=code}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var script=document.createElement("script");script.appendChild(document.createTextNode(this.jsRunSequence[0].code));script.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(script);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var that=this;var script=document.createElement("script");script.src=this.jsRunSequence[0].path;script.type="text/javascript";this.jsRunSequence[0].status="loading";script.onload=function(){that.jsRunSequence.shift();if(that.jsRunSequence.length>0){that.runjs()}};document.body.appendChild(script)}};lsloader.tagLoad=function(path,name){this.jsRunSequence.push({name:name,code:"",path:path,status:"failed"});this.runjs()};lsloader.jsfallback=function(path,name){if(!!this.jsnamemap[name]){return}else{this.jsnamemap[name]=name}for(var k in this.jsRunSequence){if(this.jsRunSequence[k].name==name){this.jsRunSequence[k].code="";this.jsRunSequence[k].status="failed";this.jsRunSequence[k].path=path}}this.runjs()};lsloader.cssfallback=function(path,name,cssonload){if(!!this.cssnamemap[name]){return}else{this.cssnamemap[name]=1}var link=document.createElement("link");link.type="text/css";link.href=path;link.rel="stylesheet";link.onload=link.onerror=cssonload;var root=document.getElementsByTagName("script")[0];root.parentNode.insertBefore(link,root)};lsloader.runInlineScript=function(scriptId,codeId){var code=document.getElementById(codeId).innerText;this.jsRunSequence.push({name:scriptId,code:code});this.runjs()};lsloader.loadCombo=function(jslist){var updateList="";var requestingModules={};for(var k in jslist){var LS=this.getLS(jslist[k].name);if(!!LS){var version=LS.split(versionString)[0];var code=LS.split(versionString)[1]}else{var version=""}if(version==jslist[k].path){this.jsRunSequence.push({name:jslist[k].name,code:code,path:jslist[k].path})}else{this.jsRunSequence.push({name:jslist[k].name,code:null,path:jslist[k].path,status:"comboloading"});requestingModules[jslist[k].name]=true;updateList+=(updateList==""?"":";")+jslist[k].path}}var that=this;if(!!updateList){var xhr=new XMLHttpRequest;xhr.open("get",combo+updateList,true);xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status>=200&&xhr.status<300||xhr.status==304){if(xhr.response!=""){that.runCombo(xhr.response,requestingModules);return}}else{for(var i in that.jsRunSequence){if(requestingModules[that.jsRunSequence[i].name]){that.jsRunSequence[i].status="failed"}}that.runjs()}}};xhr.send(null)}this.runjs()};lsloader.runCombo=function(comboCode,requestingModules){comboCode=comboCode.split("/*combojs*/");comboCode.shift();for(var k in this.jsRunSequence){if(!!requestingModules[this.jsRunSequence[k].name]&&!!comboCode[0]){this.jsRunSequence[k].status="comboJS";this.jsRunSequence[k].code=comboCode[0];this.setLS(this.jsRunSequence[k].name,this.jsRunSequence[k].path+versionString+comboCode[0]);comboCode.shift()}}this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" sizes="192x192" href="/img/favicon.png">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!--iOS -->
    <meta name="apple-mobile-web-app-title" content="Title">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="480">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="w4lle&#39;s Notes">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    
        
            <link rel=alternate type="application/atom+xml" href="/atom.xml">
        
    

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?tcz64tzAgXHydzHShhly3g==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        

    

    
        
            <link rel="stylesheet" href="/css/fontawesome.min.css">
        
    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-color: #F5F5F5;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icon -->

    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==", true)</script>
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://w4lle.com">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="Flutter UI 渲染浅析（四）Build | w4lle&#39;s Notes">
    <meta property="og:image" content="http://w4lle.com/img/favicon.png" />
    <meta property="og:description" content="系列文章的第四篇，本篇文章主要分析下 Element.rebuild() 过程。
源码基于 Flutter v1.20.4。">
    <meta property="og:article:tag" content="Flutter"> 

    
        <meta property="article:published_time" content="Mon Nov 16 2020 14:30:12 GMT+0800" />
        <meta property="article:modified_time" content="Tue Nov 17 2020 20:49:33 GMT+0800" />
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:title" content="Flutter UI 渲染浅析（四）Build | w4lle&#39;s Notes">
    <meta name="twitter:description" content="系列文章的第四篇，本篇文章主要分析下 Element.rebuild() 过程。
源码基于 Flutter v1.20.4。">
    <meta name="twitter:image" content="http://w4lle.com/img/favicon.png">
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content="http://w4lle.com" />

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://w4lle.com/2020/11/16/flutter-ui-build/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://w4lle.com/2020/11/16/flutter-ui-build/index.html",
    "headline": "Flutter UI 渲染浅析（四）Build",
    "datePublished": "Mon Nov 16 2020 14:30:12 GMT+0800",
    "dateModified": "Tue Nov 17 2020 20:49:33 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "w4lle",
        "image": {
            "@type": "ImageObject",
            "url": "/img/avatar.png"
        },
        "description": "人生如逆旅，我亦是行人。"
    },
    "publisher": {
        "@type": "Organization",
        "name": "w4lle&#39;s Notes",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/favicon.png"
        }
    },
    "keywords": ",FlutterAndroid",
    "description": "系列文章的第四篇，本篇文章主要分析下 Element.rebuild() 过程。
源码基于 Flutter v1.20.4。",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Isolation" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                
                    <!-- Isolation Header -->
                    <header class="header">
    <div class="header-wrapper">
        <!-- Header Copyright -->
        <div class="header-copyright">
            <div class="header-site">
                ©&nbsp;
                <script type="text/javascript">
                    var fd = new Date();
                    document.write(fd.getFullYear());
                </script>
                &nbsp;w4lle's Notes
            </div>
            <!--
            I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright.
            It will not impact the appearance and can give developers a lot of support :)

            很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
            它不会影响美观并可以给开发者很大的支持。 :)
            -->
            <div>
                Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a>
                <br>
                Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a>
            </div>
        </div>

        <!-- Header Title -->
        <span class="header-title header-item">
            <a href="/" title="w4lle&#39;s Notes">
                w4lle&#39;s Notes
            </a>
        </span>

        <p class="header-slogan header-item">
        
            
                人生如逆旅，我亦是行人。
            
        
        </p>

        <!-- Header Nav -->
        <nav class="header-nav header-item">
            <span class="header-nav-item">
                <a href="/" title="Home">
                    <span>主页</span>
                </a>
            </span>

            <!-- Pages  -->
            
                <span class="header-nav-item">
                    <a href="/tags" title="标签">
                        <span>标签</span>
                    </a>
                </span>
            
                <span class="header-nav-item">
                    <a href="/timeline" title="时间轴">
                        <span>时间轴</span>
                    </a>
                </span>
            
            
        </nav>

        <!-- Header SNS -->
        <div class="header-item header-sns_list">
    <!-- Twitter -->
    

    <!-- Facebook -->
    

    <!-- Google + -->
    

    <!-- Weibo -->
    
        <a href="http://weibo.com/u/2274417881" target="_blank">
            <i class="fa fa-weibo fa-lg" aria-hidden="true"></i>
        </a>
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    
        <a href="https://github.com/w4lle" target="_blank">
            <i class="fa fa-github fa-lg" aria-hidden="true"></i>
        </a>
    

    <!-- LinkedIn -->
    

    <!-- Telegram -->
    
</div>

    </div>
</header>

                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    

                    <!-- Post TOC -->

    



<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                


    <!-- Isolation Post Header -->
    <!-- Post thumbnail -->
    
        <!-- Post Header Info -->
        <div class="post-header_info with-thumbnail">
            <!-- Author Avatar & Name -->
            <img src="/img/avatar.png" class="avatar-img" width="44px" height="44px" alt="w4lle's avatar">
            <span class="name-span">w4lle</span>
        </div>

        <!-- Custom thumbnail -->
        <div class="post_thumbnail-custom">
            <img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter.png">
    
        </div>



                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    

    
        <div class="post-content_wrapper">
            <p class="post-title">
                Flutter UI 渲染浅析（四）Build
            </p>
            <p>系列文章的第四篇，本篇文章主要分析下 Element.rebuild() 过程。</p>
<p>源码基于 Flutter v1.20.4。</p>
<a id="more"></a>
<p>在 <a href="http://w4lle.com/2020/11/11/flutter-ui-vsync/">Flutter UI 渲染浅析（二）VSync 注册</a> 这篇文章中提到，C++ Engine 接收到 VSync 信号后，需要做三件事情：</p>
<ul>
<li>执行 Dart Framework <code>dart:ui</code> 包下的 <code>_beginFrame()</code></li>
<li>执行 microtasks 任务</li>
<li>执行 Dart Framework <code>dart:ui</code> 包下的  <code>_drawFrame()</code></li>
</ul>
<p>上一篇文章 <a href="http://w4lle.com/2020/11/13/flutter-ui-animate/">Flutter UI 渲染浅析（三）Animation 原理</a> 中分析了 <code>_beginFrame()</code> 的过程。</p>
<p>然后接着去处理在 <code>Animate</code> 过程中触发的 <code>microtasks</code> 任务，一般为 <code>Ticker</code> 或者 <code>AnimationController</code> 中  Future 的完成回调。</p>
<p>本篇文章分析下 <code>_drawFrame()</code> 的前半部分—— <code>Element.rebuild()</code> 的过程。</p>
<h1 id="1、-handleDrawFrame"><a href="#1、-handleDrawFrame" class="headerlink" title="1、_handleDrawFrame()"></a>1、_handleDrawFrame()</h1><p>同上篇文章的逻辑一样，调用到 Dart Framework 的<code>SchedulerBinding._handleDrawFrame()</code> 方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/scheduler/binding.dart</span></div><div class="line">	<span class="keyword">void</span> _handleDrawFrame() &#123;</div><div class="line">    <span class="keyword">if</span> (_ignoreNextEngineDrawFrame) &#123;</div><div class="line">      _ignoreNextEngineDrawFrame = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    handleDrawFrame();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">void</span> handleDrawFrame() &#123;</div><div class="line">    <span class="keyword">assert</span>(_schedulerPhase == SchedulerPhase.midFrameMicrotasks);</div><div class="line">    <span class="comment">//结束Animate过程记录</span></div><div class="line">    Timeline.finishSync(); <span class="comment">// end the "Animate" phase</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// PERSISTENT FRAME CALLBACKS</span></div><div class="line">      _schedulerPhase = SchedulerPhase.persistentCallbacks;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> FrameCallback callback <span class="keyword">in</span> _persistentCallbacks)</div><div class="line">        _invokeFrameCallback(callback, _currentFrameTimeStamp);</div><div class="line"></div><div class="line">      <span class="comment">// POST-FRAME CALLBACKS</span></div><div class="line">      _schedulerPhase = SchedulerPhase.postFrameCallbacks;</div><div class="line">      <span class="keyword">final</span> <span class="built_in">List</span>&lt;FrameCallback&gt; localPostFrameCallbacks =</div><div class="line">          <span class="built_in">List</span>&lt;FrameCallback&gt;.from(_postFrameCallbacks);</div><div class="line">      <span class="comment">//清除列表</span></div><div class="line">      _postFrameCallbacks.clear();</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> FrameCallback callback <span class="keyword">in</span> localPostFrameCallbacks)</div><div class="line">        _invokeFrameCallback(callback, _currentFrameTimeStamp);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="comment">//SchedulerPhase状态置为idle，等待下一次绘制触发</span></div><div class="line">      _schedulerPhase = SchedulerPhase.idle;</div><div class="line">      <span class="comment">//结束Frame过程记录</span></div><div class="line">      Timeline.finishSync(); <span class="comment">// end the Frame</span></div><div class="line">      _currentFrameTimeStamp = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>主要做了两件事情：</p>
<ul>
<li>遍历 <code>_persistentCallbacks</code>，由 <code>WidgetsBinding.addPersistentFrameCallback()</code> 注册，从名字也可以看出，它是一个需要持久回调的列表，所以不可删除，每次绘制过程都会回调</li>
<li>遍历<code>_postFrameCallbacks</code>，由 <code>WidgetsBinding.addPostFrameCallback()</code> 注册，只会回调一次，调用过后清除回调列表，一般用于监听绘制完成后处理一些任务</li>
</ul>
<p>下面主要看下<code>_persistentCallbacks</code> 的执行过程。</p>
<h2 id="1-1、RendererBinding-drawFrame"><a href="#1-1、RendererBinding-drawFrame" class="headerlink" title="1.1、RendererBinding.drawFrame()"></a>1.1、RendererBinding.drawFrame()</h2><p>在 <a href="http://w4lle.com/2020/11/11/flutter-ui-vsync/">Flutter UI 渲染浅析（二）VSync 注册</a> 这篇文章中，我们简单分析了 7 个 Binding 类的作用及其初始化顺序。</p>
<p>在 <code>RendererBinding</code> 在初始化过程中，注册了<code>_persistentCallbacks</code> 回调，如下。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">mixin RendererBinding on BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, SemanticsBinding, HitTestable &#123;</div><div class="line">  <span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> initInstances() &#123;</div><div class="line">    <span class="keyword">super</span>.initInstances();</div><div class="line">    _instance = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">//初始化绘制管线</span></div><div class="line">    _pipelineOwner = PipelineOwner(</div><div class="line">      onNeedVisualUpdate: ensureVisualUpdate,</div><div class="line">      onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,</div><div class="line">      onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,</div><div class="line">    );</div><div class="line">    <span class="comment">//注册window回调</span></div><div class="line">    <span class="built_in">window</span></div><div class="line">      ..onMetricsChanged = handleMetricsChanged</div><div class="line">      ..onTextScaleFactorChanged = handleTextScaleFactorChanged</div><div class="line">      ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged</div><div class="line">      ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged</div><div class="line">      ..onSemanticsAction = _handleSemanticsAction;</div><div class="line">    <span class="comment">//初始化RenderObject根节点RenderView</span></div><div class="line">    initRenderView();</div><div class="line">    _handleSemanticsEnabledChanged();</div><div class="line">    <span class="comment">//这里添加_persistentCallbacks回调</span></div><div class="line">    addPersistentFrameCallback(_handlePersistentFrameCallback);</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">  <span class="comment">//_persistentCallbacks回调</span></div><div class="line">  <span class="keyword">void</span> _handlePersistentFrameCallback(<span class="built_in">Duration</span> timeStamp) &#123;</div><div class="line">    <span class="comment">//真正执行frame绘制</span></div><div class="line">    drawFrame();</div><div class="line">    _mouseTracker.schedulePostFrameCheck();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><code>_handlePersistentFrameCallback(Duration timeStamp)</code> 方法是 <code>_persistentCallbacks</code> 回调列表的一个子元素，其中去调用 <code>drawFrame()</code> 方法。</p>
<p>由于 <code>WidgetsFlutterBinding</code> 的混入顺序</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/widgets/binding.dart</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetsFlutterBinding</span> <span class="keyword">extends</span> <span class="title">BindingBase</span> <span class="title">with</span> <span class="title">GestureBinding</span>, <span class="title">SchedulerBinding</span>, <span class="title">ServicesBinding</span>, <span class="title">PaintingBinding</span>, <span class="title">SemanticsBinding</span>, <span class="title">RendererBinding</span>, <span class="title">WidgetsBinding</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> WidgetsBinding ensureInitialized() &#123;</div><div class="line">    <span class="keyword">if</span> (WidgetsBinding.instance == <span class="keyword">null</span>)</div><div class="line">      WidgetsFlutterBinding();</div><div class="line">    <span class="keyword">return</span> WidgetsBinding.instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>WidgetsBinding</code> 在 <code>RendererBinding</code> 之后，所以会先执行 <code>WidgetsBinding.drawFrame()</code> 方法。</p>
<h2 id="1-2、WidgetsBinding-drawFrame"><a href="#1-2、WidgetsBinding-drawFrame" class="headerlink" title="1.2、WidgetsBinding.drawFrame()"></a>1.2、WidgetsBinding.drawFrame()</h2><p><code>WidgetsBinding.drawFrame()</code> 实现: </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/widgets/binding.dart WidgetsBinding</span></div><div class="line">mixin WidgetsBinding on BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding &#123;</div><div class="line">  <span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> initInstances() &#123;</div><div class="line">    <span class="keyword">super</span>.initInstances();</div><div class="line">    _instance = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">//构造BuildeOwner，主要负责Widget的build过程</span></div><div class="line">    _buildOwner = BuildOwner();</div><div class="line">    buildOwner.onBuildScheduled = _handleBuildScheduled;</div><div class="line">    <span class="comment">//注册window相关回调</span></div><div class="line">    <span class="built_in">window</span>.onLocaleChanged = handleLocaleChanged;</div><div class="line">    <span class="built_in">window</span>.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged;</div><div class="line">  	<span class="comment">//导航channel  </span></div><div class="line">    SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation);</div><div class="line">    FlutterErrorDetails.propertiesTransformers.add(transformDebugCreator);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> drawFrame() &#123;</div><div class="line">		...</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//renderViewElement是根RenderObject RenderView对应的Element</span></div><div class="line">      <span class="keyword">if</span> (renderViewElement != <span class="keyword">null</span>)</div><div class="line">        buildOwner.buildScope(renderViewElement);</div><div class="line">      <span class="comment">//调用mixin的drawFrame方法，即RendererBinding.drawFrame()</span></div><div class="line">      <span class="keyword">super</span>.drawFrame();</div><div class="line">      buildOwner.finalizeTree();</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>buildOwner.buildScope() 触发Widget Tree、Element Tree、RenderObject Tree三棵树的构建或刷新过程</li>
<li>super.drawFrame() 调用父类的 drawFrame() 方法，由于 <code>WidgetsBinding</code> 混入了 <code>RendererBinding</code> ，所以这里会去调用 <code>RendererBinding.drawFrame()</code> ，下篇文章会继续分析</li>
<li>buildOwner.finalizeTree() 卸载未激活状态的 Element 节点。未激活状态的节点在一个绘制帧周期内，是有可能被重新激活的，如果没有重新激活，那么就卸载掉</li>
</ul>
<h2 id="1-3、BuildOwner-buildScope"><a href="#1-3、BuildOwner-buildScope" class="headerlink" title="1.3、BuildOwner.buildScope()"></a>1.3、BuildOwner.buildScope()</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/widgets/framework.dart BuildOwner</span></div><div class="line">	<span class="keyword">void</span> buildScope(<span class="built_in">Element</span> context, [ VoidCallback callback ]) &#123;</div><div class="line">    <span class="comment">// 记录 Build 过程</span></div><div class="line">    Timeline.startSync(<span class="string">'Build'</span>, arguments: timelineArgumentsIndicatingLandmarkEvent);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      _scheduledFlushDirtyElements = <span class="keyword">true</span>;</div><div class="line">      <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</div><div class="line">        _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">// 执行回调，在App启动构建三棵树时会用到</span></div><div class="line">        callback();</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 重排序，高度优先</span></div><div class="line">      _dirtyElements.sort(<span class="built_in">Element</span>._sort);</div><div class="line">      _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</div><div class="line">      <span class="built_in">int</span> dirtyCount = _dirtyElements.length;</div><div class="line">      <span class="built_in">int</span> index = <span class="number">0</span>;</div><div class="line">      <span class="keyword">while</span> (index &lt; dirtyCount) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="comment">// 触发 Elemeng.rebuild() 更新三棵树</span></div><div class="line">          _dirtyElements[index].rebuild();</div><div class="line">        &#125;</div><div class="line">        index += <span class="number">1</span>;</div><div class="line">        <span class="comment">// 在等待VSync 信号回调过程中，有可能又有新的标脏节点进来</span></div><div class="line">        <span class="keyword">if</span> (dirtyCount &lt; _dirtyElements.length || _dirtyElementsNeedsResorting) &#123;</div><div class="line">          <span class="comment">// 重排序，高度优先</span></div><div class="line">          _dirtyElements.sort(<span class="built_in">Element</span>._sort);</div><div class="line">          _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</div><div class="line">          dirtyCount = _dirtyElements.length;</div><div class="line">          <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; _dirtyElements[index - <span class="number">1</span>].dirty) &#123;</div><div class="line">            index -= <span class="number">1</span>;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> <span class="built_in">Element</span> element <span class="keyword">in</span> _dirtyElements) &#123;</div><div class="line">        <span class="comment">// 清除 Element 脏标记</span></div><div class="line">        element._inDirtyList = <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 清空脏列表</span></div><div class="line">      _dirtyElements.clear();</div><div class="line">      _scheduledFlushDirtyElements = <span class="keyword">false</span>;</div><div class="line">      _dirtyElementsNeedsResorting = <span class="keyword">null</span>;</div><div class="line">      <span class="comment">// 结束 Build 记录过程</span></div><div class="line">      Timeline.finishSync();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>执行回调，在 App 启动时<code>WidgetsFlutterBinding.ensureInitialized()
  ..scheduleAttachRootWidget(app)</code> 会用到，用于构建出三棵树，callback 为 <code>element.mount(null, null);</code></li>
<li><code>_dirtyElements</code> 脏列表重排序，在等待 VSync 信号回调过程中，有可能又有新的标脏节点进来</li>
<li>脏列表中的节点，即调用了 <code>State.setState()</code> 的节点，触发 Element.rebuild() 更新三棵树，这里的重点也是Element.rebuild()。</li>
<li>清除 Element 脏标记，清空脏列表</li>
</ul>
<h2 id="1-4、Element-rebuild"><a href="#1-4、Element-rebuild" class="headerlink" title="1.4、Element.rebuild()"></a>1.4、Element.rebuild()</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// flutter/lib/src/widgets/framework.dart Elememt  </span></div><div class="line">	<span class="keyword">void</span> rebuild() &#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> (!_active || !_dirty)</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    performRebuild();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@protected</span></div><div class="line">  <span class="keyword">void</span> performRebuild();</div></pre></td></tr></table></figure>
<p>逻辑比较简单，调用 <code>performRebuild()</code>，它是一个空方法，实现在子类。</p>
<h1 id="2、Widget、Element-与-RenderObject"><a href="#2、Widget、Element-与-RenderObject" class="headerlink" title="2、Widget、Element 与 RenderObject"></a>2、Widget、Element 与 RenderObject</h1><p>在继续分析后续流程之前，先简单梳理下 Widget、Element 与 RenderObject 之间的关系，以及三棵树与 Layer Tree 之间的关系。</p>
<p>Flutter 开发者最熟悉的就是 Widget 了。</p>
<p>Widget 是面向开发者的接口，它是对UI的描述性表达，即是用于描述 Element 的配置的。</p>
<p>Widget 是声明式的 UI 结构，开发者通过组合 Widget 构建出想要的UI效果。</p>
<p>Widget 是不可变的（immutable），这就意味着每次刷新，都会重新构建出新的Widget对象，创建的开销很小，成本较低。</p>
<p>我们通常将 Widget 组合构建出的 UI 层级结构称为 Widget Tree，但相比 Element Tree，实际上并不存在 Widget              Tree，由于 Widget 节点挂载在 Element 节点上，所以我们可以抽象为 Widget Tree。</p>
<p>Widget 提供 <code>createElement()</code> 和 <code>createRenderObject()</code> （并不是所有）用于构建 Element 和 RenderObject。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter_widgets_categories.png" alt=""></p>
<p>Widget 主要有三种类型：</p>
<ul>
<li>ProxyWidget 代理类，不直接参与构建UI，它们可以为其他 Widget 提供一些附加信息。例如 <code>InheritedWidget</code> 可以在其子树中传递附加信息；<code>ParentDataWidget</code> 用于提供其子树的布局信息</li>
<li>ComponentWidget 组合类，不直接参与绘制，它们用来组合包装用来构建复杂的UI布局。一般都是 <code>StatefullWidget</code> 或者 <code>StatelessWidget</code> 的子类，例如 <code>RaisedButton</code> 、<code>Scaffold</code>、<code>Text</code>、 <code>GestureDetector</code>、 <code>Container</code> 等</li>
<li>RenderObjectWidget 绘制类，可以构建出 RenderObject 用来布局和绘制</li>
</ul>
<p>Element 是响应式编程的基础，频繁的创建 Element 会对性能有影响，所以只有在必要条件下才会创建一个新的 Element 对象，大部分情况下会进行复用，主要包含两个职责：</p>
<ul>
<li>持有 Widget 和 RenderObject 的引用，协调二者之间的数据绑定关系</li>
<li>根据 Widget 的变化来创建或更新 Element Tree，包括挂载、更新、更改位置、卸载等</li>
</ul>
<p>Element 和 Widget 是一一对应的关系，同样类型的 Widget 构建出同样类型的 Element。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter_element_types.png" alt=""></p>
<p>RenderObject 用来布局和绘制，处理输入事件等。</p>
<p>Element 和 RenderObject 不是一一对应的，只有可以绘制的节点才有 RenderObject 对象。</p>
<p>Render Tree 用来布局和绘制 RenderObject 节点，最终生成 Layer Tree 提交给 C++ Engine。它的根节点是 RenderView。</p>
<p>他们三者之间的关系：</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesinternals_element.png" alt=""></p>
<p>Element 持有 Widget 引用和 RenderObject 应用（可能没有），Widget 用来构建 RenderObject 对象。</p>
<p>对于 StatefullElement 来说，它还会持有 State 的引用。</p>
<p>这里需要注意，Element 的 child 是 Widget 中 build() 方法构建出来的 Widget 所对应的 Element，下面会用到。</p>
<p>Widget、Element、RenderObject 构建出三棵树 Widget Tree、Element Tree、Render Tree，它们共同组成了 Flutter 对于UI的组织描述。</p>
<p>前两棵树可以认为是面向开发者的，它们构成了声明式UI、响应式UI的基础，Render Tree 用来真正的布局和绘制，最后生成 Layer Tree，并保存在 Scene 对象中，提交给 C++ Engine 做光栅化合成。</p>
<p>那么，可不可以绕开 Widget、Element、RenderObject 来进行绘制，其实是可以的，它们只是用来组织描述绘制信息的，我们可以直接拿到 Canvas 进行绘制，只要最终可以生成Layer Tree 保存在 Scene 中就可以。</p>
<p>例如 <a href="https://codepen.io/w4lle/pen/ZEOPZEe" target="_blank" rel="external">这个例子 🌰</a> 。</p>
<p>更进一步的，甚至可以绕过或者舍弃 Dart Framework，直接对接 C++ Engine，任何可以组织描述UI绘制结构的组织形式，理论上都可以桥接到 C++ Engine。</p>
<p>例如基于 W3C 标准的 CSS + JS/TS 组织的UI描述，通过绑定JS与C++ Engine，将绘制信息发送给 Engine，理论上也是可行的，如下图</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20201117155018.png" alt=""></p>
<h1 id="3、Element-performRebuild"><a href="#3、Element-performRebuild" class="headerlink" title="3、Element.performRebuild()"></a>3、Element.performRebuild()</h1><p>继续上面分析到 <code>Element.performRebuild()</code>。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter_ondrawframe.gif" alt=""></p>
<p>分 Element 类型看下实现</p>
<p>ComponentElement：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/widgets/framework.dart ComponentElement</span></div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> performRebuild() &#123;</div><div class="line">    Widget built;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      ...</div><div class="line">      built = build();</div><div class="line">      ...</div><div class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</div><div class="line">      _debugDoingBuild = <span class="keyword">false</span>;</div><div class="line">      <span class="comment">// 错误情况，这里是构建红屏的地方</span></div><div class="line">      built = ErrorWidget.builder();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="comment">// 改变标志位</span></div><div class="line">      _dirty = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      ...</div><div class="line">      _child = updateChild(_child, built, slot);</div><div class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</div><div class="line">      <span class="comment">// 错误情况，这里也是构建红屏的地方</span></div><div class="line">      built = ErrorWidget.builder();</div><div class="line">      _child = updateChild(<span class="keyword">null</span>, built, slot);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">// lib/src/widgets/framework.dart StatefullElement</span></div><div class="line">  <span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> performRebuild() &#123;</div><div class="line">    <span class="keyword">if</span> (_didChangeDependencies) &#123;</div><div class="line">      <span class="comment">// 依赖的祖先节点如果有变化，需要调用</span></div><div class="line">      _state.didChangeDependencies();</div><div class="line">      _didChangeDependencies = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">super</span>.performRebuild();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>主要做了两件事情：</p>
<ul>
<li><code>build()</code> 构建子 Widget，注意这里是 <strong>子Widget</strong></li>
<li><code>_updateChild()</code> 创建或更新子Element，注意这里是 <strong>子Element</strong></li>
</ul>
<p>为什么强调子Widget和子Element，因为在这个Element对象中，它对应的 Widget 和 Element 就是Element自己合它持有的 Widget。这里很容易搞混。</p>
<p>RenderObjectElement：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/widgets/framework.dart RenderObjectElement</span></div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> performRebuild() &#123;</div><div class="line">    ...</div><div class="line">     </div><div class="line">    widget.updateRenderObject(<span class="keyword">this</span>, renderObject);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">// lib/src/widgets/basic Stack</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> <span class="keyword">extends</span> <span class="title">MultiChildRenderObjectWidget</span> </span>&#123;</div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> updateRenderObject(BuildContext context, RenderStack renderObject) &#123;</div><div class="line">    <span class="keyword">assert</span>(_debugCheckHasDirectionality(context));</div><div class="line">    renderObject</div><div class="line">      ..alignment = alignment</div><div class="line">      ..textDirection = textDirection ?? Directionality.of(context)</div><div class="line">      ..fit = fit</div><div class="line">      ..clipBehavior = overflow == Overflow.visible ? Clip.none : clipBehavior;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <code>widget.updateRenderObject()</code> 的作用是把 Widget 中的属性值，绑定到 RenderObject 中，属性的类型一一对应。</p>
<h2 id="3-1、Element-build"><a href="#3-1、Element-build" class="headerlink" title="3.1、Element.build()"></a>3.1、Element.build()</h2><p><code>build()</code> 在各个类型的 Element 的实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// StatefullElement</span></div><div class="line">	<span class="meta">@override</span></div><div class="line">  Widget build() =&gt; _state.build(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"><span class="comment">// StatelessElement</span></div><div class="line">  <span class="meta">@override</span></div><div class="line">  Widget build() =&gt; widget.build(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"><span class="comment">// ProxyElement</span></div><div class="line">  <span class="meta">@override</span></div><div class="line">  Widget build() =&gt; widget.child;</div></pre></td></tr></table></figure>
<h2 id="3-2、Element-updateChild"><a href="#3-2、Element-updateChild" class="headerlink" title="3.2、Element.updateChild()"></a>3.2、Element.updateChild()</h2><p>这个方法是响应式UI的基础，也是 Dart Framework 的核心方法之一，看下实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@protected</span></div><div class="line"><span class="built_in">Element</span> updateChild(<span class="built_in">Element</span> child, Widget newWidget, <span class="keyword">dynamic</span> newSlot) &#123;</div><div class="line">  <span class="keyword">if</span> (newWidget == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// case 1</span></div><div class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>)</div><div class="line">      deactivateChild(child);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">Element</span> newChild;</div><div class="line">  <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// case 2</span></div><div class="line">    <span class="built_in">bool</span> hasSameSuperclass = <span class="keyword">true</span>;</div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> (hasSameSuperclass &amp;&amp; child.widget == newWidget) &#123;</div><div class="line">      <span class="comment">// case 2.1</span></div><div class="line">      <span class="keyword">if</span> (child.slot != newSlot)</div><div class="line">        updateSlotForChild(child, newSlot);</div><div class="line">      newChild = child;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasSameSuperclass &amp;&amp; Widget.canUpdate(child.widget, newWidget)) &#123;</div><div class="line">      <span class="comment">// case 2.2</span></div><div class="line">      <span class="keyword">if</span> (child.slot != newSlot)</div><div class="line">        updateSlotForChild(child, newSlot);</div><div class="line">      child.update(newWidget);</div><div class="line">      newChild = child;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// case 2.3</span></div><div class="line">      deactivateChild(child);</div><div class="line">      newChild = inflateWidget(newWidget, newSlot);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// case 3</span></div><div class="line">    newChild = inflateWidget(newWidget, newSlot);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> newChild;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先要先明确，这个方法是用来更新子树的，第一个参数 <code>child</code> 是 <strong>子Element</strong>，第二个参数<code>newWidget</code>是 <strong>子Widget</strong> 。</p>
<p>分几种情况：</p>
<ul>
<li>case 1：newWidget 为空，也就是当前 Element 节点对应的 Widget build() 返回了空，那么标记child为非激活状态(当前帧绘制完成后会被卸载)，然后返回空</li>
<li>case 2：如果child不为空，也就是之前构建过一次子Element<ul>
<li>case 2.1：如果子Element对应的widget 即 child.widget 和新构建的 newWidget 相等，直接更新子widget，如果插槽不同，更新下插槽</li>
<li>case 2.2：如果 <code>Widget.canUpdate(child.widget, newWidget)</code> ，判断标准是 <code>runtimeType</code> 和<code>key</code> 都相等，那么调用 <code>update()</code> 更新 child</li>
<li>case 2.3：否则child不可复用，标记child为非激活状态(当前帧绘制完成后会被卸载)，然后构建出一个新的 Element 节点，挂载到Element Tree上</li>
</ul>
</li>
<li>case 3：否则 child 为空，不可复用，构建出一个新的 Element 节点，挂载到Element Tree上</li>
</ul>
<p>下面看下几个关键的方法</p>
<h2 id="3-3、Element-update"><a href="#3-3、Element-update" class="headerlink" title="3.3、Element.update()"></a>3.3、Element.update()</h2><p>Element 类实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/widgets/framework.dart Element  </span></div><div class="line">	<span class="meta">@mustCallSuper</span> <span class="comment">// 子类复写该方法必须调用super</span></div><div class="line">  <span class="keyword">void</span> update(covariant Widget newWidget) &#123;</div><div class="line">    _widget = newWidget;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>直接更新 Element 子节点的 <code>_widget</code> 引用。</p>
<p>子类复写该方法必须调用super。</p>
<p>看下子类的实现。</p>
<h3 id="3-3-1、RenderObjectElement-update"><a href="#3-3-1、RenderObjectElement-update" class="headerlink" title="3.3.1、RenderObjectElement.update()"></a>3.3.1、RenderObjectElement.update()</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectElement</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> update(covariant RenderObjectWidget newWidget) &#123;</div><div class="line">    <span class="keyword">super</span>.update(newWidget);</div><div class="line">    widget.updateRenderObject(<span class="keyword">this</span>, renderObject);</div><div class="line">    _dirty = <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同上面一样，把 newWidget 中的属性值，绑定到 RenderObject 中。</p>
<p><code>SingleChildRenderObjectElement</code>、<code>MultiChildRenderObjectElement</code> 是 <code>RenderObjectElement</code> 的子类，分别看下实现。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleChildRenderObjectElement</span> <span class="keyword">extends</span> <span class="title">RenderObjectElement</span> </span>&#123;</div><div class="line">  <span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> update(SingleChildRenderObjectWidget newWidget) &#123;</div><div class="line">    <span class="keyword">super</span>.update(newWidget);</div><div class="line">    <span class="comment">// 更新子树</span></div><div class="line">    _child = updateChild(_child, widget.child, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用super，复用 RenderObjectElement.update() 逻辑</li>
<li>更新子树</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiChildRenderObjectElement</span> <span class="keyword">extends</span> <span class="title">RenderObjectElement</span> </span>&#123;</div><div class="line">  <span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> update(MultiChildRenderObjectWidget newWidget) &#123;</div><div class="line">    <span class="keyword">super</span>.update(newWidget);</div><div class="line">    _children = updateChildren(_children, widget.children, forgottenChildren: _forgottenChildren);</div><div class="line">    _forgottenChildren.clear();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用super，复用 RenderObjectElement.update() 逻辑</li>
<li>通过差分算法将新构造的 widget.children 绑定到已有的 _children 上来更新子树，updateChildren() 逻辑虽然看起来很多，但是还比较好理解，这里就不放源码了，说下逻辑<ul>
<li>首先从 topIndex 到 bottomIndex 遍历 oldChildElement 和 newChildWidget，如果<code>Widget.canUpdate(oldChild.widget, newWidget)</code>，那么<code>updateChild()</code>更新子树 <code>updateChild()</code>，直到匹配失败，记录 topIndex 累加值</li>
<li>从 bottomIndex 到 topIndex 遍历oldChildElement 和 newChildWidget，直到匹配失败，记录 bottomIndex 累减值，这里不更新子树</li>
<li>遍历缩小了的 oldChildElement 列表，记录 oldChild.widget.key 和 oldChild 到 map，key为空的反激活</li>
<li>遍历缩小了的 newChildWidget 列表，匹配 map 中的key类型，<code>updateChild()</code> 更新子树，未匹配到的反激活</li>
<li>最后更新第二步得到剩余的部分</li>
</ul>
</li>
</ul>
<h3 id="3-3-2、StatefullElement-update"><a href="#3-3-2、StatefullElement-update" class="headerlink" title="3.3.2、StatefullElement.update()"></a>3.3.2、StatefullElement.update()</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@override</span></div><div class="line"><span class="keyword">void</span> update(StatefulWidget newWidget) &#123;</div><div class="line">  <span class="keyword">super</span>.update(newWidget);</div><div class="line">  <span class="keyword">final</span> StatefulWidget oldWidget = _state._widget;</div><div class="line">  <span class="comment">// Notice that we mark ourselves as dirty before calling didUpdateWidget to</span></div><div class="line">  <span class="comment">// let authors call setState from within didUpdateWidget without triggering</span></div><div class="line">  <span class="comment">// asserts.</span></div><div class="line">  _dirty = <span class="keyword">true</span>;</div><div class="line">  _state._widget = widget <span class="keyword">as</span> StatefulWidget;</div><div class="line">  <span class="keyword">final</span> <span class="keyword">dynamic</span> debugCheckForReturnedFuture = _state.didUpdateWidget(oldWidget) <span class="keyword">as</span> <span class="keyword">dynamic</span>;</div><div class="line">  <span class="comment">// 更新子树</span></div><div class="line">  rebuild();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 super</li>
<li>更新 state 中 widget 的引用</li>
<li>调用 _state.didUpdateWidget(oldWidget)</li>
<li>调用 <code>rebuild()</code> 更新子树，由于 <code>rebuild()</code> 一定会触发 <code>build()</code> 方法调用，所以这里进行标脏</li>
</ul>
<p>StatelessElement.update() 类似，不写出来了。</p>
<h2 id="3-4、Element-inflateWidget"><a href="#3-4、Element-inflateWidget" class="headerlink" title="3.4、Element.inflateWidget()"></a>3.4、Element.inflateWidget()</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@protected</span></div><div class="line"><span class="built_in">Element</span> inflateWidget(Widget newWidget, <span class="keyword">dynamic</span> newSlot) &#123;</div><div class="line">  <span class="keyword">final</span> Key key = newWidget.key;</div><div class="line">  <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</div><div class="line">    <span class="comment">// 如果key类型是 GlobalKey，从非激活状态的列表中尝试匹配类型相同的节点，抢救复用一下</span></div><div class="line">    <span class="keyword">final</span> <span class="built_in">Element</span> newChild = _retakeInactiveElement(key, newWidget);</div><div class="line">    <span class="keyword">if</span> (newChild != <span class="keyword">null</span>) &#123;</div><div class="line">      newChild._activateWithParent(<span class="keyword">this</span>, newSlot);</div><div class="line">      <span class="keyword">final</span> <span class="built_in">Element</span> updatedChild = updateChild(newChild, newWidget, newSlot);</div><div class="line">      <span class="keyword">return</span> updatedChild;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 通过 Widget，创建对应的 Element</span></div><div class="line">  <span class="keyword">final</span> <span class="built_in">Element</span> newChild = newWidget.createElement();</div><div class="line"><span class="comment">// 挂载到 Element Tree 上</span></div><div class="line">  newChild.mount(<span class="keyword">this</span>, newSlot);</div><div class="line">  <span class="keyword">return</span> newChild;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果key类型是 GlobalKey，从非激活状态的列表中尝试匹配类型相同的节点，抢救性复用一下</li>
<li>通过 Widget，创建对应的 Element</li>
<li>挂载到 Element Tree 上</li>
</ul>
<h2 id="3-5、Element-mount"><a href="#3-5、Element-mount" class="headerlink" title="3.5、Element.mount()"></a>3.5、Element.mount()</h2><p>挂载到Element Tree上</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@mustCallSuper</span></div><div class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</div><div class="line">  <span class="comment">// 更新父节点信息</span></div><div class="line">  _parent = parent;</div><div class="line">  <span class="comment">// 更新插槽信息</span></div><div class="line">  _slot = newSlot;</div><div class="line">  <span class="comment">// 更新深度</span></div><div class="line">  _depth = _parent != <span class="keyword">null</span> ? _parent.depth + <span class="number">1</span> : <span class="number">1</span>;</div><div class="line">  <span class="comment">// 从初始化状态更改为激活状态</span></div><div class="line">  _active = <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) </div><div class="line">    <span class="comment">// 绑定 BuildOwner 对象</span></div><div class="line">    _owner = parent.owner;</div><div class="line">  <span class="keyword">final</span> Key key = widget.key;</div><div class="line">  <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</div><div class="line">    <span class="comment">// 如果是 GlobalKey，注册到公共map，全局复用</span></div><div class="line">    key._register(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 从 parent 更新 _inheritedWidgets，用于传递附加信息</span></div><div class="line">  _updateInheritance();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>更新父节点信息</li>
<li>更新插槽信息</li>
<li>更新深度</li>
<li>从初始化状态更改为激活状态</li>
<li>绑定 BuildOwner 对象</li>
<li>如果是 GlobalKey，注册到公共map，全局复用</li>
<li>从 parent 更新 _inheritedWidgets，用于传递附加信息</li>
</ul>
<p>如果子类复写该方法，那么必须要调用 super。</p>
<h3 id="3-5-1、ComponentElement-mount"><a href="#3-5-1、ComponentElement-mount" class="headerlink" title="3.5.1、ComponentElement.mount()"></a>3.5.1、ComponentElement.mount()</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentElement</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;  </div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</div><div class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</div><div class="line">    _firstBuild();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">void</span> _firstBuild() &#123;</div><div class="line">    rebuild();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 super() 调用 <code>Element.mount()</code></li>
<li>调用 _firstBuild() -&gt; rebuild() -&gt; performRebuild() 构建 Element 子树</li>
</ul>
<p>下面还有 SingleChildRenderObjectElement 、MultiChildRenderObjectElement 等子类，逻辑跟<code>update()</code>差不多，就不列出来了。</p>
<h3 id="3-5-2、RenderObjectElement-mount"><a href="#3-5-2、RenderObjectElement-mount" class="headerlink" title="3.5.2、RenderObjectElement.mount()"></a>3.5.2、RenderObjectElement.mount()</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectElement</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</div><div class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</div><div class="line">    <span class="comment">// 构建 RenderObject</span></div><div class="line">    _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</div><div class="line">		<span class="comment">// 将 RenderObject 挂载到 Render Tree 上</span></div><div class="line">    attachRenderObject(newSlot);</div><div class="line">    _dirty = <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 super() 调用 <code>Element.mount()</code></li>
<li>构建 RenderObject</li>
<li>将 RenderObject 挂载到 Render Tree 上</li>
</ul>
<h2 id="3-6、RenderObjectElement-attachRenderObject"><a href="#3-6、RenderObjectElement-attachRenderObject" class="headerlink" title="3.6、RenderObjectElement.attachRenderObject()"></a>3.6、RenderObjectElement.attachRenderObject()</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectElement</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;  </div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> attachRenderObject(<span class="keyword">dynamic</span> newSlot) &#123;</div><div class="line">    _slot = newSlot;</div><div class="line">    <span class="comment">// Element Tree 向上遍历祖先节点，找到第一个 RenderObject 节点</span></div><div class="line">    _ancestorRenderObjectElement = _findAncestorRenderObjectElement();</div><div class="line">    <span class="comment">// 根据规则插入到 Render Tree 中，需要子类实现</span></div><div class="line">    _ancestorRenderObjectElement?.insertChildRenderObject(renderObject, newSlot);</div><div class="line">    <span class="comment">// Element Tree 向上遍历祖先节点，找到第一个 ParentDataElement 节点</span></div><div class="line">    <span class="keyword">final</span> ParentDataElement&lt;ParentData&gt; parentDataElement = _findAncestorParentDataElement();</div><div class="line">    <span class="keyword">if</span> (parentDataElement != <span class="keyword">null</span>)</div><div class="line">      _updateParentData(parentDataElement.widget);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">void</span> _updateParentData(ParentDataWidget&lt;ParentData&gt; parentDataWidget) &#123;</div><div class="line">    ...</div><div class="line">    parentDataWidget.applyParentData(renderObject);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Element Tree 向上遍历祖先节点，找到第一个 RenderObject 节点</li>
<li>根据规则插入到 Render Tree 中，需要子类实现</li>
<li>Element Tree 向上遍历祖先节点，找到第一个 ParentDataElement 节点，ParentDataElement 节点中记录着布局位置信息，如果没有找到返回空</li>
<li>根据 ParentDataElement 找到对应的 ParentDataWidget，调用 <code>applyParentData()</code></li>
</ul>
<p>其中，<code>ParentDataElement</code> 根据参数绑定了 <code>ParentDataWidget</code> 类型，并通过泛型绑定了 ParentData 类型。</p>
<h3 id="3-6-1、ParentDataWidget-applyParentData"><a href="#3-6-1、ParentDataWidget-applyParentData" class="headerlink" title="3.6.1、ParentDataWidget.applyParentData()"></a>3.6.1、ParentDataWidget.applyParentData()</h3><p>ParentDataWidget 是 ProxyWidget 的子类，它的子类包括 Flexible、LayoutId、Positioned、KeepAlive 等Widget。</p>
<p>ParentDataWidget 使用泛型绑定了 ParentData 类型。</p>
<p>以 Flexible 为例看下实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flexible</span> <span class="keyword">extends</span> <span class="title">ParentDataWidget</span>&lt;<span class="title">FlexParentData</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> applyParentData(RenderObject renderObject) &#123;</div><div class="line">    <span class="keyword">final</span> FlexParentData parentData = renderObject.parentData <span class="keyword">as</span> FlexParentData;</div><div class="line">    <span class="built_in">bool</span> needsLayout = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (parentData.flex != flex) &#123;</div><div class="line">      parentData.flex = flex;</div><div class="line">      needsLayout = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (parentData.fit != fit) &#123;</div><div class="line">      parentData.fit = fit;</div><div class="line">      needsLayout = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (needsLayout) &#123;</div><div class="line">      <span class="keyword">final</span> AbstractNode targetParent = renderObject.parent;</div><div class="line">      <span class="keyword">if</span> (targetParent <span class="keyword">is</span> RenderObject)</div><div class="line">        targetParent.markNeedsLayout();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>更新布局属性信息</li>
<li>RenderObject 节点 Layout 标脏，记录在 <code>BuildOwner._nodesNeedingLayout</code> 列表中，等待下一步 Layout 处理</li>
</ul>
<h1 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h1><p>本篇文章介绍了 <code>WidgetsBinding.drawFrame()</code> 的过程，以及 Widget、Element、RenderObject 及三棵树的关系，梳理了<code>build()</code> 过程在三棵树之间的流转关系，通过 Element Tree 和 Widget Tree 构建了 Render Tree，最终触发 RenderObject.markNeedsLayout()  Layout 标脏操作，记录在 <code>BuildOwner._nodesNeedingLayout</code> 列表中，等待下一步 Layout 处理。</p>
<p>下一篇文章将继续分析 <code>RendererBinding.drawFrame()</code> 中 Layout 过程。</p>
<p>参考 </p>
<ul>
<li><p><a href="https://www.didierboelens.com/2019/09/flutter-internals/" target="_blank" rel="external">Flutter Internals</a></p>
</li>
<li><p><a href="https://blog.voiddog.org/1599449233776/" target="_blank" rel="external">谈谈 Flutter 的 build</a></p>
</li>
<li><p><a href="http://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/" target="_blank" rel="external">深入浅出 Flutter Framework 之 Element</a></p>
</li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2020/11/16/flutter-ui-build/">http://w4lle.com/2020/11/16/flutter-ui-build/</a> </p>

            
                <blockquote>
                    <p>
                         
                            版权声明：本文为 w4lle 原创文章，可以随意转载，但必须在明确位置注明出处！
                        
                        <br>
                        本文链接： http://w4lle.com/2020/11/16/flutter-ui-build/
                    </p>
                </blockquote>
            
        </div>
    
</div>


                
                    <!-- Paradox Post Info -->
                    
                

                <!-- Post Comments -->
                
                    
    <!-- 使用 gitcoment -->
<div id="gitment-comment">
    <!-- Gitment 评论框 -->
<div id="container"></div>
</div>
<style>
    #gitment-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    var gitment = new Gitment({
        //id: '页面 ID', // 可选。默认为 location.href
        owner: 'w4lle',
        repo: 'w4lle.github.io',
        oauth: {
            client_id: '88a4cc6214c9567625a7',
            client_secret: '2b98c3304a15727a3cbd13f20bb05f521c748061',
        },
    })
    gitment.render('container')
</script>

                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2020/11/13/flutter-ui-animate/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?V/53wGualMuiPM3xoetD5Q==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>









   <!-- Gitment -->





<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.0 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
