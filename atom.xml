<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>w4lle&#39;s Notes</title>
  <subtitle>Eeeee... va?</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://w4lle.com/"/>
  <updated>2020-11-09T11:58:03.912Z</updated>
  <id>http://w4lle.com/</id>
  
  <author>
    <name>w4lle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter UI 渲染浅析（一）总览</title>
    <link href="http://w4lle.com/2020/11/09/flutter-ui-overview/"/>
    <id>http://w4lle.com/2020/11/09/flutter-ui-overview/</id>
    <published>2020-11-09T11:43:02.000Z</published>
    <updated>2020-11-09T11:58:03.912Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter UI 渲染系列文章，基于 Flutter v1.20.4</p>
<a id="more"></a>
<p>我们知道屏幕显示的基本单位是像素，每个像素点显示不同的颜色值，按一定规则排列就形成了图像。</p>
<p>显示器按一定频率从 GPU 获取数据，就可以完成图像的更新。现在手机屏幕一般有60HZ、90HZ、120HZ，以60HZ为例，屏幕每秒会发出 60 个 Vsync 垂直同步信号。</p>
<p>Vsync 信号用于协调显示器、CPU 和 GPU 的工作。</p>
<p>GPU 每秒可以绘制的帧数叫做帧速率，如果帧速率大于屏幕刷新率，屏幕上显示的内容就有可能是两个图像的不完全内容，造成图像撕裂。Vsync 垂直信号可以保证刷新频率的统一。</p>
<p>在 Vsync 信号的调度下，UI 系统把逻辑代码变成图像显示到屏幕上，一般需要经过以下几个阶段：</p>
<ol>
<li>View，构建 View/DOM 节点</li>
<li>Layout，计算样式(Style)、布局(Layout)</li>
<li>ViewTree，将 View 节点按一定规则归属到不同的图层，构建或更新 ViewTree</li>
<li>Paint，绘制，输出绘制指令到 DisplayList</li>
<li>Rasterization，光栅化，执行 DisplayList 中的绘图指令，生成图层区域的像素数据</li>
<li>Composite，合成，把各图层光栅化后的数据进行叠加和特性处理，输出到屏幕上</li>
</ol>
<p>简单来说就是做了两件事情：</p>
<ol>
<li>构建 UI 描述规则，用于构建或刷新图像，并把绘制指令保存起来用于绘制，即 1-4</li>
<li>光栅化和合成，对硬件绘制 API 做了统一封装，屏蔽底层绘制细节，即 5-6</li>
</ol>
<p>Android 和 iOS 基本都是按照这个流程来构建UI的。</p>
<p>以 Android 为例，Android 通过 XML 来描述 UI 结构，用 DisplayList 保存绘制指令信息，通过 Skia 封装底层细节实现光栅化合成。</p>
<p>Flutter 作为一款跨端 UI 开发框架，它的渲染流程也是类似的。</p>
<p>这个系列的文章主要分析下 Flutter UI 渲染流程，涉及到的中间过程会分部解析，基于 Flutter v1.20.4 版本源码，主要分为以下几个部分：</p>
<ol>
<li>总览</li>
<li>Vsync 注册</li>
<li>Animate 及动画实现原理</li>
<li>Build</li>
<li>Layout</li>
<li>Paint &amp; RepaintBoundary</li>
<li>CompositeFrame</li>
<li>RasterThread 光栅化及合成</li>
</ol>
<h2 id="Flutter-架构"><a href="#Flutter-架构" class="headerlink" title="Flutter 架构"></a>Flutter 架构</h2><p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter_archdiagram.png" alt=""></p>
<p>Flutter 架构分为三层：Dart Framework、C++ Engine、 Platform Embedder。</p>
<p>Dart Framework 提供了响应式的开发框架，使用 Dart 开发，它对渲染逻辑做了统一封装，屏蔽了底层实现，对底层 C++ Engine 提供双向通信能力，开发者只需要组合 Widgets 用于构建 App 视图即可。</p>
<ul>
<li>最底层的 Foundation 层提供一些最基础的抽象类或定义，基于此， Animation 动画、Painting 绘制、Gestures 手势等构建出通用抽象能力</li>
<li>Rendering 层，构建出渲染树 Render Tree，也即 RenderObject Tree，用于绘制具体，RenderObject 会自动随着数据改变而动态改变</li>
<li>Widgets 层，提供了一套非常丰富的 Widget 组件库，用于构建 Widgets Tree 和 Element Tree，这是响应式编程的基础实现，每一个 RenderObject 都有一个对应的 Widget 及 Element</li>
<li>Materail 层和 Cupertino 层使用 Widgets 组件库，构建 Android Materail 或者 iOS Cupertino 风格的应用视图，开发者基于这些 Widgets 即可构建出效果一致的跨端应用</li>
</ul>
<p>C++ Engine 是 Flutter 的核心部分，大部分使用 C++ 开发，它的主要职责是光栅化合成上屏用于显示绘制内容，同时它也提供低层次的核心能力，比如Skia图形化绘制（graphics）、TextLayout、文件系统、网络 I/O、无障碍支持、插件体系、Dart运行时（DartVM）和 GC、编译链。</p>
<p>Engine 层对 App 层暴露 <code>dart:ui</code> 包，<code>dart:ui</code> 包是 Flutter App 的构建基础，其中的 dart 类对 C++ Engine 层中的实现类做了包装，它提供了基础能力，诸如交互系统、图形图像处理、渲染子系统等。</p>
<p>其中最重要的一个类是包下的 <code>Window</code>，它向上提供了最核心的一些服务，比如任务Scheduler API、绘制 API、输入事件响应等等。</p>
<p>Platform Embedder 是平台嵌入层，把 Flutte 代码打包嵌入到具体的实现平台，提供运行入口，并对上层提供最基础的能力，比如提供渲染画布、插件系统、无障碍、交互管理、消息循环管理等。</p>
<p>Flutter 分层架构使得平台相关性大大降低。</p>
<p>Dart Framework 对上提供统一的基于 dart 的响应式 UI 描述框架。</p>
<p>C++ Engine 向下对 Skia 绘制引擎对下统一封装，屏蔽了平台实现。</p>
<p>ReactNative / Weex 作为跨端框架 ，虽然走的也是是原生渲染，但是需要通过 js 来组织和描述 UI，中间需要做一层转换，才可以变成原生的 UI 描述结构，进而原生渲染。</p>
<p>而 Flutter 自建渲染引擎，不依赖平台实现，并且 dart 可以直接被编译成机器码，从架构上来说，性能相比 ReactNative / Weex 会更好。</p>
<h2 id="Flutter-渲染管线"><a href="#Flutter-渲染管线" class="headerlink" title="Flutter 渲染管线"></a>Flutter 渲染管线</h2><p>Flutter 渲染管线的设计是类似的，流程参考下图</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter_graphics_pipeline1.png" alt=""></p>
<p>首先看下用到的线程：</p>
<p>UIThread 是 Platform 创建的子线程，DartVM Root Isolate 所有的 dart 代码都运行在该线程。</p>
<p>阻塞UIThread 会直接导致 Flutter 应用卡顿掉帧、</p>
<p>RasterThread 原本叫做 GPUThread，也是 Platform 创建的子线程，由于很多人误认为运行在 GPU 上，但其实它是运行在 CPU  用于处理数据提交给 GPU，所以 Flutter 团队将其名字改为 Raster，表明它的作用是光栅化。</p>
<p>C++ Engine 中的光栅化和合成过程运行在该线程。</p>
<p>整个流程会经过以下几个过程：</p>
<ul>
<li>C++ Engine 触发 Platform 注册 Vsync 垂直信号回调，通过 Platform -&gt; C++ Engine -&gt; Dart Framework 触发整个绘制流程</li>
<li>Dart Framework 构建出四棵树，Widget Tree、Element Tree、RenderObject Tree、Layer Tree，布局、记录绘制区域及绘制指令信息，并保存在 Scene 对象用以光栅化，这个过程运行在  UIThread</li>
<li>通过 Flutter 自建引擎 Skia 进行光栅化和合成操作， 将 LayerTree 转换为 GPU 指令，并发送给 GPU 完成光栅化合成上屏显示操作，这个过程执行在 RasterThread</li>
</ul>
<p>整个过程是生产者消费者模型。</p>
<p>UIThread 负责生产 Layer Tree，RasterThread 负责消费 Layer Tree。</p>
<p>在 Engine Pipeline 中通过深度为 2 的两个信号量 <code>empty_</code> 和 <code>available_</code> 控制整个流程。</p>
<ul>
<li><p>当 Vsync 信号到来，触发 UIThread 开始工作时，<code>_empty</code> -1，开始生成 LayerTree ；</p>
</li>
<li><p>当 UIThread 准备好保存了 Engine LayerTree 的 Scene 对象， <code>available_</code> + 1</p>
</li>
<li><p>触发 Raster Thread 开始工作， <code>available_</code> - 1；</p>
</li>
<li><p>当 RasterThread 处理完光栅化合成上屏后， <code>_empty</code> + 1，使得 UIThread 继续接收 Vsync 信号，继续触发图形化流程。</p>
</li>
<li><p>当  <code>_empty</code> 信号量为 0 时，代表工作任务已满，就会延迟 UIThread 生成 Layer Tree 的任务，直到下一次 Vsync 信息到来。</p>
</li>
</ul>
<p>这种调度机制可以确保 RasterThread 不至于过载（2个任务）引起图像撕裂，同时也可以避免 UIThread 不必要的资源消耗。</p>
<p>所以不论在 UIThread 还是在 RasterThread 耗时太久，都会导致 Flutter 应用卡顿，因为会导致延迟接受 Vsync 信号，导致掉帧。</p>
<p>这个调度过程会在下一篇文章中详细分析。</p>
<h2 id="Flutter-UI-绘制管线"><a href="#Flutter-UI-绘制管线" class="headerlink" title="Flutter UI 绘制管线"></a>Flutter UI 绘制管线</h2><p>其中在 UIThread 生成Layer Tree的过程，我们将其称为 <code>Rendering Pipeline</code> 渲染管线。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter_rendering_pipeline.png" alt=""></p>
<p>主要过程为：</p>
<ul>
<li>Animate，触发动画更新下一帧的值</li>
<li>Build，触发构建或刷新 Widget Tree、Element Tree、RenderObject Tree</li>
<li>Layout，触发布局操作，确定布局大小和位置信息</li>
<li>CompositeBits，更新需要合成的 Layer 层标记</li>
<li>Paint，触发 RenderObject Tree 的绘制操作，构建 Layer Tree</li>
<li>Composite，触发 Layer Tree 发送到 Engine，生成 Engine LayerTree</li>
</ul>
<p>在 UIThread 构建出四棵树，并在 Engine 生成 Scene，最后提交给 RasterThread，对 LayerTree 做光栅化合成上屏。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/78758247" target="_blank" rel="external">渲染流水线中的光栅化（一）</a></p>
<p><a href="https://developer.aliyun.com/article/770384" target="_blank" rel="external">从架构到源码：一文了解Flutter渲染机制</a></p>
<p><a href="http://gityuan.com/2019/06/15/flutter_ui_draw/" target="_blank" rel="external">Flutter渲染机制—UI线程</a></p>
<p>本文链接： <a href="http://w4lle.com/2020/11/09/flutter-ui-overview/">http://w4lle.com/2020/11/09/flutter-ui-overview/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter UI 渲染系列文章，基于 Flutter v1.20.4&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://w4lle.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 工程架构</title>
    <link href="http://w4lle.com/2019/11/23/flutter-project-manage/"/>
    <id>http://w4lle.com/2019/11/23/flutter-project-manage/</id>
    <published>2019-11-23T14:11:04.000Z</published>
    <updated>2019-11-24T03:41:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍Android视角下在已有 App 中嵌入 Flutter 应用的实践，iOS 的方案思路基本一致。</p>
<a id="more"></a>
<p>系列文章：</p>
<ul>
<li><a href="http://w4lle.com/2019/11/22/flutter-hybrid-stack/">Flutter 混合栈管理</a></li>
<li><a href="http://w4lle.com/2019/11/23/flutter-project-manage/">Flutter 工程架构</a></li>
</ul>
<h1 id="Flutter-工程类型"><a href="#Flutter-工程类型" class="headerlink" title="Flutter 工程类型"></a>Flutter 工程类型</h1><p>Flutter工程中，通常有以下几种工程类型，下面分别简单概述下：</p>
<p><strong>1. Flutter Application</strong></p>
<p>​    纯净的Flutter App工程，包含标准的Dart层与Native平台层(android/&amp;ios/)</p>
<p><strong>2. Flutter Module</strong></p>
<p>​    Flutter模块工程，仅包含Dart层实现，Native平台子工程的作用是构建Flutter产物，是通过Flutter自动生成的隐藏工程（.android/&amp;.ios/）</p>
<p><strong>3. Flutter Plugin</strong></p>
<p>​    Flutter平台插件工程，包含Dart层与Native平台层的实现(android/&amp;ios/)，往外提供API接口</p>
<p><strong>4. Flutter Package</strong></p>
<p>​    Flutter纯Dart插件工程，仅包含Dart层的实现，往往定义一些公共Widget</p>
<p>接入Flutter工程的两种方式：</p>
<ol>
<li>源码集成，在原生项目中Flutter作为lib直接嵌入Flutter代码，编译过程需要依赖Flutter环境，每个开发都需要配置Flutter开发环境，适合全新项目</li>
<li>Flutter项目作为子项目module，生成aar后由原生App依赖，对于App来说屏蔽了Flutter开发环境，在原有环境中即可打包，对App开发来说屏蔽了Flutter环境，适合已经App嵌入Flutter应用</li>
</ol>
<p>本文主要介绍第二种方式，由于Flutter官方并未提供完整的解决方案，所以接入过程中会碰到一些问题，这里给出一些解决思路供参考。</p>
<p>创建一个flutter module：</p>
<p>flutter create -t module –org com.example my_flutter</p>
<p>工程结构：</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesD099FCC6-82A2-4170-A8A1-43C90F44CB65.png" alt=""></p>
<h1 id="FlutterModule-构建-Aar"><a href="#FlutterModule-构建-Aar" class="headerlink" title="FlutterModule 构建 Aar"></a>FlutterModule 构建 Aar</h1><p>flutter build aar</p>
<p>但是这个命令在Flutter v1.7.8版本中会提示找不到这个命令，估计是dev版本新加入的，还没有stable。</p>
<p>不久前加入的 <a href="https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps/_compare/1f606754ee0b18d9970e5fdd7b14d8a6df8d2d72...d648f6b063a0ab7ad4eaf0546e90b1cc75b9d58b" target="_blank" rel="external">https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps/_compare/1f606754ee0b18d9970e5fdd7b14d8a6df8d2d72...d648f6b063a0ab7ad4eaf0546e90b1cc75b9d58b</a></p>
<p>即使没有这个命令，也可以使用./gradlew assembleDebug进行编译，结果是一样的。</p>
<p>如果使用flutter build aar命令，Flutter官方给出的结果是，本地作为localmaven，生成的结构如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">build/host/outputs/repo</div><div class="line"></div><div class="line">└── com</div><div class="line"></div><div class="line">└── example</div><div class="line"></div><div class="line">└── my_flutter</div><div class="line"></div><div class="line">└── flutter_release</div><div class="line"></div><div class="line">├── 1.0</div><div class="line"></div><div class="line">│   ├── flutter_release-1.0.aar</div><div class="line"></div><div class="line">│   ├── flutter_release-1.0.aar.md5</div><div class="line"></div><div class="line">│   ├── flutter_release-1.0.aar.sha1</div><div class="line"></div><div class="line">│   ├── flutter_release-1.0.pom</div><div class="line"></div><div class="line">│   ├── flutter_release-1.0.pom.md5</div><div class="line"></div><div class="line">│   └── flutter_release-1.0.pom.sha1</div><div class="line"></div><div class="line">├── maven-metadata.xml</div><div class="line"></div><div class="line">├── maven-metadata.xml.md5</div><div class="line"></div><div class="line">└── maven-metadata.xml.sha1</div></pre></td></tr></table></figure>
<p>Flutter v1.2版本之后Flutter产物自动会打包到aar中，具体脚本见 flutter.gradle，主要做了三件事情：</p>
<ol>
<li>选择符合对应架构的Flutter引擎（flutter.so）</li>
<li>解析 .flutter-plugins文件，把Flutter对应的android module动态添加到Native工程的依赖中，即动态添加implementation依赖，这块后面会详细讲</li>
<li>Hook mergeAssets/processResources Task，预先执行FlutterTask，调用flutter命令编译Dart层代码构建出flutter_assets产物，并拷贝到assets目录下</li>
</ol>
<p>基于Flutter v1.7.8，编译产物 Debug版本</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images0517FC2D-73DC-4597-A471-8F87E51420B0.png" alt=""></p>
<p>Release版本 </p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesCB70BFBA-A021-4D0C-9614-395D366BF292.png" alt=""></p>
<p>在Flutter v1.7之前，Release的产物如下：</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagese21cd2440bca39a70b30abedaaba4e3be5e090e4.png" alt=""></p>
<p>也就是说Flutter的编译产物，<strong>从四个二进制文件变成了一个 libapp.so 文件</strong>。</p>
<p>这里也涉及到so兼容arm的问题，之前把libflutter.so拷贝到arm目录下即可，现在编译出的libapp.so拷贝过去是有问题的，解决办法可以参考 <a href="https://github.com/lizhangqu/plugin-flutter-armeabi" target="_blank" rel="external">这个项目</a>。</p>
<p>如果在Flutter module 中依赖了Flutter Plugin，那么在App中依赖Flutter module编译出的aar时，会报错，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ERROR: Unable to resolve dependency <span class="keyword">for</span> <span class="string">':app@debug/compileClasspath'</span>: Could not resolve io.flutter.plugins.sharedpreferences:shared_preferences:<span class="number">1.0</span>-SNAPSHOT. </div><div class="line"></div><div class="line">Show Details</div><div class="line"></div><div class="line">Affected Modules: app</div></pre></td></tr></table></figure>
<p>下面会分析下为什么会报错。</p>
<h1 id="Flutter-Plugin依赖原理"><a href="#Flutter-Plugin依赖原理" class="headerlink" title="Flutter Plugin依赖原理"></a>Flutter Plugin依赖原理</h1><p>以Flutter Module为例，看下Flutter Plugin依赖的原理。</p>
<h2 id="flutter-package-get"><a href="#flutter-package-get" class="headerlink" title="flutter package get"></a>flutter package get</h2><p>当Flutter Module在pub中依赖了Flutter Plugin，并且在 flutter package get后，会从远程pubserver拉取依赖的Flutter Plugin，并生成一个文件记录依赖了哪些Flutter Plugin，名字为： <code>.flutter-plugins</code>，内容为 k-v，如：</p>
<p><code>flutter_webview_plugin=/Users/wanglinglong/Develop/flutter/.pub-cache/hosted/pub.flutter-io.cn/flutter_webview_plugin-0.3.5/</code></p>
<p>被拉取到本地后的Flutter Plugin目录如下</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesimage2019-8-6%2011-51-21.png" alt=""></p>
<h2 id="动态依赖"><a href="#动态依赖" class="headerlink" title="动态依赖"></a>动态依赖</h2><p>然后在.android/app/settings.gradle 文件中添加配置脚本，使其在Gradle初始化之后执行解析操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rootProject.name = <span class="string">'android_generated'</span></div><div class="line">setBinding(<span class="keyword">new</span> Binding([gradle: <span class="keyword">this</span>]))</div><div class="line">evaluate(<span class="keyword">new</span> File(settingsDir, <span class="string">'include_flutter.groovy'</span>))</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesimage2019-8-2%2015-19-48.png" alt=""></p>
<p>这个脚本的作用是控制配置(evaluate)顺序，操作是解析.flutter-plugins，得到各个插件的android工程，使其在.android/Flutter 配置完成之后再进行配置解析。Gradle配置阶段的目标是解析每个project中的build.gradle。</p>
<p>然后在.android/Flutter/build.gradle中依赖 </p>
<p><code>apply from: &quot;$flutterRoot/packages/flutter_tools/gradle/flutter.gradle&quot;</code></p>
<p>这个文件中同样解析.flutter-plugins文件，遍历后一个一个 implementation 到./android/Flutter module工程里完成依赖。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesimage2019-8-2%2015-22-42.png" alt=""></p>
<p>所以在Native层面来看这种依赖其实是本地依赖，只不过Flutter Plugin工程路径都在Flutter的环境变量下的缓存目录中。留个思考题，这里用 <code>api</code> 代替 <code>implementation</code> 行不行？</p>
<p>这里的依赖分成两个部分，一部分是原生Native依赖，一部分是Dart依赖。</p>
<p>对于原生部分，Flutter Plugin作为lib被Flutter Module本地依赖，根据Android 编译常识，在打包Aar后，这些<strong>本地依赖的工程lib不能被一起打到Aar中</strong>。</p>
<p>所以当App中依赖Flutter Module的产物Aar时，不能获得Flutter Module 中依赖的Flutter Plugin Android原生依赖，最终会报错。</p>
<p>对于Dart部分，通过pub进行管理依赖，相当于源码依赖，在打包时，这些Plugin的Dart源码部分都参与打包，最终生成Flutter的构建产物。</p>
<p>Flutter Module打包成Aar后，Aar中包含Android原生部分编译产物和Flutter Dart部分编译产物，后面App依赖该Aar后就可以脱离Flutter的编译环境，直接进行apk打包了。</p>
<p>那么如何解决Aar报错的问题？</p>
<h1 id="Flutter-module-依赖-Flutter-Plugin"><a href="#Flutter-module-依赖-Flutter-Plugin" class="headerlink" title="Flutter module 依赖 Flutter Plugin"></a>Flutter module 依赖 Flutter Plugin</h1><p>已有方案大致原理都是收集Flutter Plugin 的Aar文件，然后进一步处理。</p>
<p><strong>方案一：</strong></p>
<p>使用 fat-aar，大致原理就是将所有的Flutter Plugin打包到同一个Aar中，这个方案比较臃肿，还可能涉及到gradle版本适配，而且可能产生多次依赖的问题。不建议使用。</p>
<p><strong>方案二：</strong></p>
<p>遍历所有依赖的Flutter Plugin，搜集Plugin Android工程下的Aar产物并copy到Flutter Module指定目录下，然后再push maven。</p>
<p><strong>方案三：</strong></p>
<p>遍历所有依赖的Flutter Plugin，根据Plugin版本信息，挨个打包成上传到maven。</p>
<p>由于公司内之前碰到到相关需求场景，即同一工程下多个Module如何统一管理的问题，最后解决方案就是使用的方案三，这里依然采用方案三，相比其他两种方案更稳定。</p>
<p>iOS 思路相同，打包成framework后上传到CDN，通过Pod进行依赖管理。</p>
<p>看下实现：</p>
<p>首先在.andorid/Flutter/build.gradle中依赖脚本 <code>apply from: &#39;./publish_flutter_plugin.gradle&#39;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">def flutterUpload = gradle.rootProject.project(<span class="string">':flutter'</span>).tasks.getByName(uploadTaskName)</div><div class="line">gradle.rootProject.ext.pluginList.each &#123; name -&gt;</div><div class="line">    project.afterEvaluate &#123;</div><div class="line">        project.apply plugin: <span class="string">'com.u51.publish'</span></div><div class="line">        <span class="comment">// 修改插件库对插件库的本地依赖为pom依</span></div><div class="line">        modifyPom &#123; pom -&gt;</div><div class="line">            pom.dependencies.findAll &#123; dep -&gt;</div><div class="line">                <span class="keyword">if</span> (rootProject.ext.pluginList.contains(dep.artifactId)) &#123;</div><div class="line">                    dep.groupId = rootProject.ext.groupId</div><div class="line">                    dep.version = rootProject.ext.pluginMap[dep.artifactId]</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 设定插件本地库发布坐标版本号</span></div><div class="line">        project.publish &#123;</div><div class="line">            groupId rootProject.ext.groupId</div><div class="line">            version rootProject.ext.pluginMap[name]</div><div class="line">            artifactId name</div><div class="line">            compileEnvCheck <span class="keyword">false</span></div><div class="line">            sources <span class="keyword">true</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// flutter库 upload在插件本地库均upload完成后</span></div><div class="line">        <span class="keyword">if</span> (pluginUploadTask != <span class="keyword">null</span>&amp;&amp;node==<span class="keyword">null</span>) &#123;</div><div class="line">            flutterUpload.dependsOn(pluginUploadTask)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外这种方案兼容持续集成环境，对于Native层面来讲，无需做任何改动。</p>
<h1 id="Flutter-Plugin-依赖-Flutter-Plugin"><a href="#Flutter-Plugin-依赖-Flutter-Plugin" class="headerlink" title="Flutter Plugin 依赖 Flutter Plugin"></a>Flutter Plugin 依赖 Flutter Plugin</h1><p>上面提到的是Flutter module依赖Flutter Plugin的情况，那么如果是Flutter Plugin工程依赖Flutter Plugin工程有没有问题？</p>
<p>先看下Flutter Plugin的项目结构 <code>flutter create --template=plugin -i swift -a kotlin flutter_plugin</code></p>
<p>在example下运行 flutter run命令，就可以跑起来了。</p>
<p>看下编译产物，其中Aar中只有原生的编译产物，并无Dart编译产物。</p>
<p>所以Flutter Plugin需要被pub依赖，pub将发布到远程的库下载到本地，然后在工程中</p>
<ul>
<li>原生部分，Flutter Module通过上述方案动态添加maven 依赖</li>
<li>Dart部分，Flutter Module通过pub依赖找到Dart源码，在Flutter Module中import引入，相当于源码依赖，共同参与编译，生成最终的 Dart产物</li>
</ul>
<p>上面的场景都是Flutter Module(Flutter Application)依赖Flutter Plugin的情况，那么Flutter Plugin能不能依赖Flutter Plugin，会不会有问题？</p>
<p>首先Dart部分由于是pub依赖，相当于源码依赖，是没有问题的。</p>
<p>原生部分，由于Flutter Plugin在原生部分没有引入include_flutter.groovy(Android)，所以宿主Flutter Pugin无法动态include到子Flutter Plugin，找不到依赖。</p>
<p>解决办法就是再给它加上，方法同上。</p>
<h1 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h1><p>总结来说，对于 Flutter 来讲只有 Flutter Module 和 Flutter Application编译会生成Dart编译产物，而Flutter Application我们基本不用考虑。</p>
<p>所以很自然的得出结论，我们可以把Flutter Module作为隔离层，作为Flutter层的聚合统一输出给 App，App 工程只需通过 maven or Pod 依赖Flutter Module即可。</p>
<p>其余的Flutter相关依赖操作都交给Flutter Module，通过Pub进行管理即可。</p>
<p>这样通过若干个独立工程 Flutter Module、App、Flutter Plugin，就把整个构建流程建立起来了。</p>
<p>更进一步的，如果业务需要，可以在Flutter层进行更细化的划分，把Native组件化的思路对应到Flutter层。</p>
<p>每个Flutter Plugin可以作为独立的业务模块或基础组件，业务组件向下依赖基础组件，在打包时通过Pub传递依赖一起参与打包。</p>
<p>我们期望业务组件之间不互相依赖，就像之前的文章 <a href="http://w4lle.com/2018/11/16/51credit-android-architecture/">51信用卡 Android 架构演进实践</a> 中讲的那样，业务组件不互相依赖只是约定，但不是强制约束，所以要通过一些手段达到强制约束的目的，由于架构还没有演进到这一步，所以没还没有调研方案，后面有需要再研究。</p>
<p>另外还有持续集成 Flutter 环境怎么配置？</p>
<p>以及Flutter版本管理的问题，Flutter版本升级API可能有变动，怎么保证开发同学使用同一版本的Flutter？</p>
<p>参考主流方案使用flutterw进行管理，不详细阐述。</p>
<p>整体结构借用一张图</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter_hybrid_arch.jpg" alt=""></p>
<h2 id="Pub-私服"><a href="#Pub-私服" class="headerlink" title="Pub 私服"></a>Pub 私服</h2><p>参考 <a href="https://github.com/dart-lang/pub_server" target="_blank" rel="external">pub_server</a> 搭建私服。</p>
<h1 id="工程模板"><a href="#工程模板" class="headerlink" title="工程模板"></a>工程模板</h1><p>当依照上面的思路愉快的开发时，会发现当触发<code>flutter package get</code> 命令，.android/&amp;.ios/ 目录就都被还原了，里面的修改都被删除了。</p>
<p>这段操作在 flutter_tools 中进行，官方这么做的目的可能是不希望开发者直接修改.android&amp;.ios/目录，因为这两个目录仅仅是参与编译的中间过渡。</p>
<p>而通过上面的分析，这两个目录是一定要修改的，不然跑不起来。</p>
<p>除此之外还有一个问题，上面提到远程依赖和本地依赖切换，在开发过程中选择本地依赖进行打包，此时Flutter是跑在App中的，需要调试时发现没有入口。</p>
<p>这里可以通过在Flutter Module 中 <code>flutter attach</code>，然后重启App就可以连上Flutter的调试服务，才可以使用hot reload的功能，但是整个流程还是很长，并且hot reload并不是全能的，有些情况下并不能生效，还是要触发全量编译，有没有办法缩短构建路径？</p>
<p>上面的两个问题其实都可以通过自定义工程模板来解决，首先我们修改flutter_tools中的关键代码，使得不覆盖目录。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">packages/flutter_tools/lib/src/commands/packages.dart</div><div class="line">  <span class="meta">@override</span></div><div class="line">  Future&lt;FlutterCommandResult&gt; runCommand() <span class="keyword">async</span> &#123;</div><div class="line">    <span class="comment">// await rootProject.ensureReadyForPlatformSpecificTooling(checkProjects: true);</span></div><div class="line">    logger.startProgress(</div><div class="line">      <span class="string">'这是修改过的 flutter_tools 不会去修改.android 和 .ios 目录下的代码'</span>,</div><div class="line">    );</div><div class="line">    refreshPluginsList(rootProject);</div><div class="line">  	...</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>然后我们修改flutter_tools/template下的模板代码，使其满足我们的需求。这样新建的Flutter Module都是通过模板工程创建的，开发环境一致。</p>
<p>更进一步的，我们可以把<strong>完整可运行</strong>的Module模板放到仓库中使用submodule进行管理，这样每次模板更新后，Module可以实时更新。这部分可以放在flutterw中进行管理。</p>
<p>这里的完整可运行包含两个部分：</p>
<ul>
<li>修改 .android/Flutter/ Module，使其可以满足编译构建需要</li>
<li>修改 .android/app，使其<strong>拥有和工程App同样的运行时环境</strong>，包括登陆注册环境、Hybrid Plugin环境(非Flutter Plugin，这里可以理解为不依赖Flutter环境的、更加通用的Hybrid插件系统)、调试环境、网络环境等等</li>
</ul>
<p>当然这个方案也并不完美，因为涉及到修改flutter_tools，虽然改动不大，但每次Flutter版本还是要做版本兼容。</p>
<p>更好的方案是重写Dart构建流程，将flutter_tools中的流程串起来而不是修改它们，这样就不用做版本迁移了。</p>
<p>好在本身Flutter开发环境就是由flutterw动态配置的，我们把FlutterSDK放在内部仓库进行维护，通过统一管理入口进行管理，对开发来讲透明、无感知。</p>
<p>另外在App中，我们可以通过一些配置来切换远程依赖和本地依赖。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">gradle.properties</div><div class="line"># flutter模块项目开关</div><div class="line">includeFlutterProject=false</div><div class="line">flutterProjectPath=../U51XiaoLanBenFlutter</div><div class="line"></div><div class="line">setting.gradle</div><div class="line">// flutter lib</div><div class="line">if (includeFlutterProject == 'true') &#123;</div><div class="line">    setBinding(new Binding([gradle: this]))</div><div class="line">    evaluate(new File(</div><div class="line">            settingsDir,</div><div class="line">            "$&#123;flutterProjectPath&#125;/.android/include_flutter.groovy"</div><div class="line">    ))</div><div class="line">&#125;</div><div class="line"></div><div class="line">build.gradle</div><div class="line">if (includeFlutterProject == 'true') &#123;</div><div class="line">	implementation project(':flutter')</div><div class="line">  implementation project(':flutter_shell')</div><div class="line">&#125; else &#123;</div><div class="line">	implementation 'com.u51.android:xiaolanben-flutter:0.0.1-SNAPSHOT'</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样可以更方便的进行调试。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章以Android为例子，主要介绍了在接入Flutter过程中碰到的一些问题及解决方案，实际上对于iOS来说也思路基本一致，我们的iOS方案也已经落地。</p>
<p>我们目前只在一个App中进行了实践，实际上对于另外的一个App工程，业务相同的Flutter Plugin应该做到通用性，只需要新建一个Flutter Module做中转就可以集成。</p>
<p>各个App的Flutter运行时环境应该是统一的，目前来看，这个工程架构可以满足多业务组开发并行Flutter的情况。</p>
<p><strong>注：另外这篇文章成文时间较久了，大概几个月前写的，方案对于目前的Flutter v1.9版本依然是适用的。</strong></p>
<p>参考：</p>
<ul>
<li><a href="https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps" target="_blank" rel="external">https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps</a></li>
<li><a href="https://tech.meituan.com/2018/08/09/waimai-flutter-practice.html" target="_blank" rel="external">Flutter原理与实践</a></li>
<li><a href="http://zhengxiaoyong.com/2018/12/16/Flutter%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%9E%B6%E6%9E%84/" target="_blank" rel="external">Flutter混合开发组件化与工程化架构</a></li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2019/11/23/flutter-project-manage/">http://w4lle.com/2019/11/23/flutter-project-manage/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍Android视角下在已有 App 中嵌入 Flutter 应用的实践，iOS 的方案思路基本一致。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://w4lle.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 混合栈管理</title>
    <link href="http://w4lle.com/2019/11/22/flutter-hybrid-stack/"/>
    <id>http://w4lle.com/2019/11/22/flutter-hybrid-stack/</id>
    <published>2019-11-22T10:42:54.000Z</published>
    <updated>2019-11-24T02:58:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flutter-混合栈管理"><a href="#Flutter-混合栈管理" class="headerlink" title="Flutter 混合栈管理"></a>Flutter 混合栈管理</h1><p>本文主要聊一下 Flutter 混合栈，由于 Flutter 版本跨度较大，所以 Flutter API 也有很大变化，下文中前几个方案的实现看看就好，不用深究。重点关注兼容目前 Flutter 版本(v1.9.1) 的实现。本文以 Android 平台为例进行讲解。</p>
<a id="more"></a>
<p>系列文章：</p>
<ul>
<li><a href="http://w4lle.com/2019/11/22/flutter-hybrid-stack/">Flutter 混合栈管理</a></li>
<li><a href="http://w4lle.com/2019/11/23/flutter-project-manage/">Flutter 工程架构</a></li>
</ul>
<h1 id="为什么需要混合栈？"><a href="#为什么需要混合栈？" class="headerlink" title="为什么需要混合栈？"></a>为什么需要混合栈？</h1><p>在讨论 Flutter 之前，先看下 Weex 及 H5 Hybrid 如何处理多实例问题的。</p>
<p>对于Weex，其引入了 JavaScript 通过JS Runtime 完成动态运算，再把运算结果和Native客户端进行通信，完成真实ViewTree的构建、渲染等操作指令。</p>
<p>而当客户端面对多个 Weex 页面时，为了性能方面的考虑，并没有为每个 Weex 页面提供各自独立的 JS Runtime，相反只有一个 JS Runtime，这意味着所有的 Weex 页面共享同一份 JS Runtime，共用全局环境、变量、内存、和外界通信的接口等等。</p>
<p>所以我们可以看到，Weex初始化过程中，只需要初始化一次 JS Framework(weex-jsfm.js)，后面每次打开新的Weex页面都不必重新初始化。</p>
<p>为了隔离Weex独立页面的运行环境，在Native层面，每打开一个Weex页面，都会有一个唯一的WXSDKInstance，其中持有唯一InstanceId，在与JS双向通信过程中，每端都要携带InstanceId，例如声明周期调用：</p>
<ul>
<li><code>createInstance(id, code, ...)</code>：：创建一个新的 Weex 页面，通过一整段 Weex JS Bundle 的代码，在 JS Runtime 开辟一块新的空间用来存储、记录和运算</li>
<li><code>refreshInstance(id, data)</code>：更新这个 Weex 页面的“顶级”根组件的数据</li>
<li><code>destroyInstance(id)</code>：销毁</li>
</ul>
<p>指令调用：</p>
<ul>
<li><code>sendTasks(id, tasks)</code>：发送指令</li>
<li><code>receiveTasks(id, tasks)</code>：接受指令</li>
</ul>
<p>而在 JS Runtime中，每个InstanceId都有一份独立的运算和数据状态等与客户端相对应，JS通过闭包将其隔离在不同的闭包里，达到隔离的目的。</p>
<p>对于需要共享的数据，则不用InstanceId做对应，如WeexSDK初始化过程中的各种 registe：</p>
<ul>
<li><code>registerComponents(xxcomponent)</code> ： 注册视图组件</li>
<li><code>registerModules(xxmodule)</code>：注册功能模块</li>
</ul>
<p>对应Native端代码 <code>mWXBridge.execJS(&quot;&quot;, null, METHOD_REGISTER_XX, args);</code> ，第一个字段即InstanceId为空。这样即可在全局范围内查找并使用已测试的组件和模块，而不需要每个实例分别注册。</p>
<p>再看下 H5 Hybrid 混合开发，H5的容器是webview，可以在一个webview中管理所有H5页面，有点类似目前Flutter的方式；性能方面，Android平台来讲，从 Android 7.0开始，webview可选作为独立进程，Android8.0开始默认开启多进程模式，所以，即使App内打开多个webview也不会导致性能下降的很厉害。</p>
<p>而Flutter一开始的设计就是为了纯净的Flutter应用设计的，纯Flutter应用整个运行生命周期都只有一个FlutterView和Root Isolate，依靠Flutter Framework自身Route支持在FlutterView内部完成界面跳转，类似webview。借用一张图，在新版上有些变化，但大体相通。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20191123170804.png" alt=""></p>
<p>而 Isolate 之间在内存上是隔离的，这个隔离跟上面讲的Weex Instance隔离是两回事情。</p>
<p>Weex Instance隔离可以认为是两个内部类之间的隔离关系（实际是闭包），它们可以通过共同的外部类（一个比喻）来进行通信，可以共用同一份全局变量，也就是说它们之间是可以做到共用内存进行通信的。</p>
<p>而Isolate则是彻底的内存隔离，两个Isolate之间不存在内存上通信的可能性，只能通过第三方介入才可以通信。</p>
<p>试想一种情况，我们在多个页面Widget之间不能直接通信，并且像InheritedWidget也不能做到多Widget数据共享，而我们知道Flutter中的状态管理很大一部分方案都是依赖InheritedWidget来做数据共享的，这就相当于直接废弃了Flutter原生状态管理，得从Native绕道过来通信啦，这对开发来说体验太糟糕。</p>
<p>更重要的是对资源的占用，FlutterEngine运行环境初始就会占用很大内存，通信通道也会创建多个，缓存空间也会有多份，而且每个Engine会存在四个线程（实际是三个）：</p>
<ul>
<li>Platform Task Runner 相当于主线程，跟Flutter Engine的所有交互（接口调用）必须发生在这里，所有Engine实例共享同一个Platform Runner</li>
<li>UI Task Runner 用于执行 Root Isolate，对创建的对象和Widgets进行Layout并生成一个Layer Tree，处理来自Native Plugins的消息响应，Timers，Microtasks</li>
<li>GPU Task Runner 被用于执行GPU指令调用</li>
<li>IO Runner用于 IO 读写</li>
</ul>
<h1 id="Flutter-混合栈方案"><a href="#Flutter-混合栈方案" class="headerlink" title="Flutter 混合栈方案"></a>Flutter 混合栈方案</h1><p>总体来讲有几种种方案：</p>
<ol>
<li>多 Activity 多 FlutterView 方案，即多引擎方案</li>
<li>共享 FlutterView，代表为闲鱼 <a href="https://github.com/FlutterRepo/hybrid_stack_manager" target="_blank" rel="external">hybrid_stack_manager</a></li>
<li>共享 FlutterNativieView，代表为 <a href="https://juejin.im/post/5c419c07f265da616f703aa1" target="_blank" rel="external">微店</a></li>
<li>共享 FlutterView升级版，代表为闲鱼 <a href="https://github.com/alibaba/flutter_boost" target="_blank" rel="external">Flutter_Boost</a></li>
<li>共享 Isolate，代表为 <a href="https://www.msup.com.cn/share/details?id=226" target="_blank" rel="external">头条</a></li>
</ol>
<p>其实核心思想都是公用同一个 FlutterEngine，避免不必要的资源浪费，优化性能及页面跳转体验，并实现多端逻辑统一。</p>
<p>下面会深入理解每个框架的实现细节。</p>
<h2 id="多引擎方案"><a href="#多引擎方案" class="headerlink" title="多引擎方案"></a>多引擎方案</h2><p>多引擎方案即一系列连续Flutter页面对应一个Activity(VC)，类似于webview中打开h5，但是存在着本质上的区别。</p>
<p>例如，我们进行下面一组导航操作：</p>
<p><code>Flutter Page1 -&gt; Flutter Page2 -&gt; Native Page1 -&gt; Flutter Page3</code></p>
<p>我们只需要在Flutter Page1和Flutter Page3创建不同的Flutter实例即可。</p>
<p>这个方案的好处就是简单易懂，逻辑清晰，但是该方案也存在显著的问题：</p>
<ul>
<li>性能问题，每个FlutterView对应一个FlutterEngine，FlutterEngine随着FlutterView的增多而线性增多，而FlutterEngine本身是一个较重的对象。包括线程数量、图片缓存、内存缓存、消息通道等都是存在多份的</li>
<li>通信问题，每个FlutterView对应的Isolate在内存上隔离，也就是说跨FlutterView的Widget间通信需要原生介入支持</li>
<li>转场动画问题，Native之间的跳转动画和Flutter Widget间的跳转动画不同，使用体验不太好</li>
</ul>
<p>总结起来就是多引擎方案不适合在生产环境中使用。</p>
<h2 id="hybrid-stack-manager"><a href="#hybrid-stack-manager" class="headerlink" title="hybrid_stack_manager"></a>hybrid_stack_manager</h2><p>这个框架实现思路很简单，即用XFlutterView包装FlutterView，进而代理 FlutterNativeView。</p>
<p>并且替重写了 FlutterWrapperActivity 用于替换了FlutterActivity，里面的逻辑是相似的，只不过把其中的FlutterView和FlutterActivityDelegate都换成了代理类。</p>
<p>其中的FlutterView是唯一的，全局共用一个FlutterView。</p>
<p>当发生跳转时，有几种情况：</p>
<p><strong>当原生跳转Flutter时</strong></p>
<ul>
<li>原生跳转Flutter其实是跳转到FlutterWrapperActivity</li>
<li>在FlutterWrapperActivity.onCreate方法中动态绑定FlutterView，并将参数通过MethodChannel传递给Flutter</li>
<li>Flutter通过Navigator管理页面widget，并且在Flutter层唯一确定一个FlutterWrapperActivity</li>
<li>在FlutterWrapperActivity.onResume方法中更新curFlutterActivity，代表当前的FlutterWrapperActivity</li>
</ul>
<p><strong>当Flutter跳转Flutter时</strong></p>
<ul>
<li>Flutter跳转Flutter通过MethodChannel传值给原生，调用curFlutterActivity.openUrl方法</li>
<li>原生这边接收到参数后，再开启一个FlutterWrapperActivity2</li>
<li>截屏保存bitmap，绑定到对应的FlutterWrapperActivity1，并将截图显示出来</li>
<li>FlutterActivity1.onStop方法，移除FlutterView</li>
<li>其余逻辑同上</li>
</ul>
<p><strong>当Flutter跳转原生时</strong></p>
<ul>
<li>Flutter跳原生通过MethodChannel传值给原生，调用curFlutterActivity.openUrl方法</li>
<li>原生这边接收到参数后会返回一个Class，通过startActivity实现页面跳转</li>
<li>截屏保存bitmap，绑定到对应FlutterWrapperActivity，这种情况截屏不需要显示</li>
</ul>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20191122170546.png" alt=""></p>
<p>该方案基于一个事实：<strong>任何时候我们最多只能看到一个页面。（特殊情况不在考虑范围内）</strong></p>
<p>如图所示，当从FlutterActivity跳转到另一个FlutterActivity时，FlutterView从FlutterActivity1移除，并动态绑定到FlutterActivity2。</p>
<p>此时，为了保证切换在显示上的统一，避免FlutterView从FlutterActivity1移除时页面出现白屏的情况，需要对FlutterActivity1进行截屏操作，并且将截屏显示出来。</p>
<p>上面只描述了打开页面的情况，对于返回操作是一样的，在onResume和onStop中分别做处理。</p>
<p>该方案可取之处：</p>
<ul>
<li>每一个页面都有一个VC(Activity)，保证所有基于VC(Activity)生命周期的逻辑(如埋点等)照常工作</li>
<li>不同的Flutter页面之间可以正常通信，共享数据</li>
<li>Native可以调起任意的Flutter页面，无论是首次打开还是之后</li>
</ul>
<p>这种方案的缺点：</p>
<ul>
<li>需要反射FlutterSDK，<strong>侵入性强</strong></li>
<li>单例的HybridStackManager持有context上下文，容易造成内存泄露</li>
<li><strong>强依赖Flutter版本</strong>，实现基于Flutter v0.x</li>
<li>依赖FlutterSDK NavigatorState history属性，新版该属性已经私有化，所以 <a href="https://github.com/FlutterRepo/hybrid_stack_manager/issues/5" target="_blank" rel="external">新版不可用</a></li>
<li>同级的Flutter页面无法实现，例如tab中的同级Flutter页面</li>
<li>每个FlutterActivity都持有一张截屏的bitmap，占用内存空间</li>
</ul>
<h2 id="共享FlutterNativeView方案"><a href="#共享FlutterNativeView方案" class="headerlink" title="共享FlutterNativeView方案"></a>共享FlutterNativeView方案</h2><p>跟方案2类似，只不过从全局共用FlutterView变为全局共用一个FlutterNativeView，保持一个Flutter页面对应一个原生Activity(VC)。<a href="https://juejin.im/post/5c419c07f265da616f703aa1" target="_blank" rel="external">原理解析</a>及部分<a href="https://github.com/voiddog/hybrid_stack_manager" target="_blank" rel="external">源码</a></p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter_weidian.jpg" alt=""></p>
<p>在实现上跟方案二类似，但是要更简洁，废弃了FlutterActivity，重写了FlutterWrapperActivity，仍然复用Delegate用于管理生命周期，在onCreate方法中判断FlutterNativeView是否已经attach过，如果已经attach，那么就先detach操作，detach操作是重点。</p>
<p>同样的，在FlutterWrapperActivity的onDestroy方法中，也需要detach操作。</p>
<p>FlutterNativeView的声明是static，所以是全局唯一的，可以与任何FlutterWrapperActivity对应的FlutterView绑定。</p>
<p>因为在初始化时，getFlutterView和getFlutterNativeView都被ViewFactory的实现类FlutterWrapperActivity所重写，在构造FlutterView时，将唯一的FlutterNativeView当做参数，传进去就完成了FlutterView和FlutterNativeView的绑定。</p>
<p>并且FlutterNativeView绑定的context是ApplicationContext，所以不存在context内容泄露的风险。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">FlutterWrapperActivity</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> FlutterView <span class="title">createFlutterView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    FlutterNativeView flutterNativeView = createFlutterNativeView();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FlutterView(<span class="keyword">this</span>, <span class="keyword">null</span>, flutterNativeView);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> FlutterNativeView <span class="title">createFlutterNativeView</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sFlutterNativeView == <span class="keyword">null</span>) &#123;</div><div class="line">        isCreatePage = <span class="keyword">true</span>;</div><div class="line">        sFlutterNativeView = <span class="keyword">new</span> FlutterNativeView(getApplicationContext());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sFlutterNativeView;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面提到的detach方法是重点，是因为这是该方案唯一hook FlutterSDK的地方，实际上这里不能说是严格意义上的detach，最终调用的是 FlutterView.nativeSurfaceDestroyed()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onSurfaceDestroyed</span><span class="params">(FlutterView flutterView, FlutterNativeView flutterNativeView)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//Flutter 较旧版本，新版本已不兼容</span></div><div class="line">        Method nativeSurfaceDestroyed = FlutterView.class.getDeclaredMethod(<span class="string">"nativeSurfaceDestroyed"</span>, <span class="keyword">long</span>.class);</div><div class="line">        nativeSurfaceDestroyed.setAccessible(<span class="keyword">true</span>);</div><div class="line">        nativeSurfaceDestroyed.invoke(flutterView, flutterNativeView.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">//对应的老版本engine代码 FlutterView.java</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</div><div class="line">            assertAttached();</div><div class="line">            nativeSurfaceDestroyed(mNativeView.get());</div><div class="line">        &#125;</div><div class="line"> </div><div class="line"> </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeSurfaceDestroyed</span><span class="params">(<span class="keyword">long</span> nativePlatformViewAndroid)</span></span>;</div></pre></td></tr></table></figure>
<p>为了兼容新版本，只需要替换反射那里的实现即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Flutter v1.7.8</span></div><div class="line">Field mFlutterJNI = flutterNativeView.getClass().getDeclaredField(<span class="string">"mFlutterJNI"</span>);</div><div class="line">mFlutterJNI.setAccessible(<span class="keyword">true</span>);</div><div class="line">Object o = mFlutterJNI.get(flutterNativeView);</div><div class="line"> </div><div class="line">Method onSurfaceDestroyed = o.getClass().getDeclaredMethod(<span class="string">"onSurfaceDestroyed"</span>);</div><div class="line">onSurfaceDestroyed.invoke(o);</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">//对应的 FlutterSDK 代码 FlutterView.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</div><div class="line">    FlutterView.<span class="keyword">this</span>.assertAttached();</div><div class="line">    FlutterView.<span class="keyword">this</span>.mNativeView.getFlutterJNI().onSurfaceDestroyed();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改后在Flutter v1.7.8版本上可以顺利运行。</p>
<p>其中，<a href="https://github.com/flutter/engine" target="_blank" rel="external">Flutter Engine代码地址</a>，平台代码目录在 shell/platform/android</p>
<p>该方案最大的特点是不需要截屏，是因为FlutterView是和FlutterActivity绑定的，当切换FlutterActivity时，FlutterNativeView 从 FlutterView1 detach，此时FlutterActivity1中的FlutterView1显示的内容不再更新，所以显示内容不变，不用担心白屏的问题。</p>
<p>iOS 如果支持滑动返回的话可能还是需要截屏，因为在侧滑的时候，页面不一定结束。</p>
<p>总结一下，该方案的优点：</p>
<ul>
<li>hook 少，侵入性较少，就一处</li>
<li>不需要截屏，内存占用会稍微好一点</li>
<li>单例的FlutterNativeView不持有Activity的context，没有内存泄露的风险</li>
<li>支持页面间数据传递，切是await 的方式，非通知形式</li>
</ul>
<p>缺点：</p>
<ul>
<li>首次进入白屏时间较长</li>
<li>不支持平级的FlutterView展示，比如tab中的Flutter界面</li>
</ul>
<p>总体来说，这个方案还是有很大的参考价值的。</p>
<h2 id="FlutterBoost"><a href="#FlutterBoost" class="headerlink" title="FlutterBoost"></a>FlutterBoost</h2><p><a href="https://github.com/alibaba/flutter_boost" target="_blank" rel="external">项目地址</a></p>
<p>该方案是多Navigator方案，要研究这个方案的实现，首先要先读下Flutter中路由管理和Widget层级关系的相关代码，可以看<a href="https://juejin.im/post/5c8db8e8f265da2d864b889f" target="_blank" rel="external">这篇文章</a>。</p>
<p>具体原理即Flutter层通过封装过的Widget，即ContainerManagerWidget，管理多个Navigator，每个Navigator对应一个（或多个）具体的业务Widget，并且支持当前Navigator中正常的push Widget的操作。</p>
<p>原生层和Flutter层的容器通过唯一id对应起来，并通过消息通道进行生命周期同步和数据交互。</p>
<p>这里原生层是驱动方，所有的页面级别的操作都是统一发送到原生层处理，然后再次分发同步给Flutter层依次处理。</p>
<h3 id="多Navigator实现"><a href="#多Navigator实现" class="headerlink" title="多Navigator实现"></a>多Navigator实现</h3><p>这个方案的精髓在于，从FlutterView中的单Navigator栈级别的导航，进化到了多Navigator平级导航，即可以随时随地找到任意一个Flutter页面，它们之间的关系是同级的。这在之前的方案中是做不到的。</p>
<p>下面主要分析下多Navigator的实现。</p>
<p>首先，在Flutter中，万事皆Widget。</p>
<p>Navigator也不例外。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20191122173237.png" alt=""></p>
<p>对于Navigator的页面管理，比如 Navigator.of(context).push(route); 默认从当前控件的context依次向上寻找距离自己最近的NavigatorState，然后调用它的push方法入栈。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> NavigatorState of(</div><div class="line">    BuildContext context, &#123;</div><div class="line">      <span class="built_in">bool</span> rootNavigator = <span class="keyword">false</span>,</div><div class="line">      <span class="built_in">bool</span> nullOk = <span class="keyword">false</span>,</div><div class="line">    &#125;) &#123;</div><div class="line">    <span class="keyword">final</span> NavigatorState navigator = rootNavigator</div><div class="line">        ? context.rootAncestorStateOfType(<span class="keyword">const</span> TypeMatcher&lt;NavigatorState&gt;())</div><div class="line">        : context.ancestorStateOfType(<span class="keyword">const</span> TypeMatcher&lt;NavigatorState&gt;());</div><div class="line">    <span class="keyword">return</span> navigator;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@override</span></div><div class="line">State ancestorStateOfType(TypeMatcher matcher) &#123;</div><div class="line">  <span class="comment">///向父节点寻找类型匹配的对象</span></div><div class="line">  <span class="keyword">assert</span>(_debugCheckStateIsActiveForAncestorLookup());</div><div class="line">  <span class="built_in">Element</span> ancestor = _parent;</div><div class="line">  <span class="keyword">while</span> (ancestor != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (ancestor <span class="keyword">is</span> StatefulElement &amp;&amp; matcher.check(ancestor.state))</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    ancestor = ancestor._parent;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">final</span> StatefulElement statefulAncestor = ancestor;</div><div class="line">  <span class="keyword">return</span> statefulAncestor?.state;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以只要在Navigator中再插入一个ContainerManagerWidget，进行拦截页面跳转的操作，用来管理多个Navigator，这样就实现了Flutter页面的扁平化操作，规避掉了原有Navigator的栈结构。</p>
<p>Flutter层的整体架构图如下</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20191122173608.png" alt=""></p>
<p>其中，ContainerManager自己维护了一个Overlay，用于管理多Navigator的上下文切换。</p>
<p>由于OverlayState在遍历entry过程中是倒叙的，所以只要保证列表结构的 _leastEntries 在添加_ContainerOverlayEntry时，始终保持onstage需要前台展示的最后添加即可。</p>
<p>上面提到原生层和Flutter层的容器通过唯一id对应起来，并通过消息通道进行生命周期同步和数据交互。</p>
<p>而在Flutter层，每个Widget之间是共享内存的，它们之间可以共用同一套运行环境、全局变量、内存、通信接口等。所以他们之间可以正常通信，</p>
<p>这样看是不是和Weex JS 层有点像了。</p>
<p>实际上当深入了解后，会发现在DOM处理、View的映射关系上Flutter和Weex有很多相似支持。</p>
<p>比如Flutter中的三棵树 —— Widget、Element、RenderObject 和 Weex Native 中的三棵树—— WxDomObject、WXComponent、NativeView 之间的相似性等等。</p>
<h3 id="原生层实现"><a href="#原生层实现" class="headerlink" title="原生层实现"></a>原生层实现</h3><p>对于原生层有两种实现，我们分别来看：</p>
<ol>
<li>共享FlutterView</li>
<li>共享FlutterEngine</li>
</ol>
<p><strong>共享 FlutterView ：</strong></p>
<p>分析的代码基于master分支，当前版本0.420，适用于<strong>Flutter v1.5</strong>之前的版本。</p>
<p>整体上来说，该方案使用了较为复杂的FlutterView共享管理方案，FlutterView仍然是单例的，但是相对于方案二hybrid_stack_manager有了长足的进步，逻辑复杂度也提高了不少。</p>
<p>下图是官方提供的原理图</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20191122173908.png" alt=""></p>
<p>对于原生层和Flutter层来说，分别有一个ContainerManager用于管理调度Flutter容器，这个容器的概念，在原生层就是包装过的FlutterActivity，在Flutter层是Navigator。</p>
<p>简单来说，原生层通过ContainerManager管理包装过的FlutterActivity，从而共享单例的FlutterView。</p>
<p>这里为了避免切换过程中出现白屏的问题，依然需要截屏。</p>
<p>由于截屏，这里可能依然会出现闪动、黑屏的出现，见 <a href="https://github.com/alibaba/flutter_boost/issues/221" target="_blank" rel="external">issue</a></p>
<p><strong>共享 FlutterEngine：</strong></p>
<p>分支：flutter_1.5_upgrade_opt 适配了<strong>Flutter v1.5</strong>版本。</p>
<p>该方案是多FlutterView，单FlutterEngine的方案，有点类似于共享FlutterNativeView方案。</p>
<p>实际上这里的<strong>FlutterEngine就是Flutter v1.5版本之后用于替代FlutterNativeView的。</strong></p>
<p><strong>高版本的FlutterSDK，提供了embedding包，该包下提供了新的容器实现及TextureView的支持。</strong></p>
<p>该方案仍然是废弃了FlutterActivity，而自己组装了一个BoostFlutterActivity，并且废弃了delegate相关声明周期管理，所有的声明周期管理都是自己来管理。</p>
<p>不同点在于共享FlutterNativeView方案 detach过程中需要反射拿到FlutterJNI，进而调用onSurfaceDestroyed方法，而这个方案不需要，最终在FlutterView的detach过程中，调用路径 FlutterView.detach()-&gt;FlutterRender.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">detachFromRenderSurface()-&gt;</div><div class="line">FlutterRender.surfaceDestroyed()-&gt;</div><div class="line">flutterJNI.onSurfaceDestroyed()-&gt;</div><div class="line">FlutterJNI.nativeSurfaceDestroyed()</div></pre></td></tr></table></figure>
<p>可以看到最终需要调用的方法是一致的，都需要调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flutterJNI.nativeSurfaceDestroyed().</div></pre></td></tr></table></figure>
<p>以Flutter v1.5为界限简单对比如下：</p>
<p><strong>Flutter v1.5 之前的 Android SDK：</strong></p>
<p>io.flutter.view.FlutterView: 与FlutterNativeView关联，FlutterNativeView通过DartExecutor对FlutterJNI下jni方法进行消息通道传递；</p>
<p>视图渲染实际实现为SurfaceView；</p>
<p>视图销毁与创建通过embedding包下的FlutterJNI通知native</p>
<p>核心成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private final DartExecutor dartExecutor;</div><div class="line">private final FlutterRenderer flutterRenderer;</div><div class="line">private final NavigationChannel navigationChannel;</div><div class="line">private final KeyEventChannel keyEventChannel;</div><div class="line">private final LifecycleChannel lifecycleChannel;</div><div class="line">private final LocalizationChannel localizationChannel;</div><div class="line">private final PlatformChannel platformChannel;</div><div class="line">private final SettingsChannel settingsChannel;</div><div class="line">private final SystemChannel systemChannel;</div><div class="line">private final InputMethodManager mImm;</div><div class="line">private final TextInputPlugin mTextInputPlugin;</div><div class="line">private final AndroidKeyProcessor androidKeyProcessor;</div><div class="line">private final AndroidTouchProcessor androidTouchProcessor;</div></pre></td></tr></table></figure>
<p><strong>Flutter 1.5之后的 Android SDK提供了embedding包，废弃了io包：</strong></p>
<p>io.flutter.embedding.android.FlutterView 与FlutterEngine关联，废弃了FlutterNativeView；</p>
<p>视图渲染实际为FlutterSurefaceView或FlutterTextureView；</p>
<p>视图销毁与创建通过embedding包下的FlutterJNI通知native；</p>
<p>核心成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private FlutterView.RenderMode renderMode;</div><div class="line">private FlutterView.TransparencyMode transparencyMode;</div><div class="line">private RenderSurface renderSurface;</div><div class="line">private FlutterEngine flutterEngine;</div><div class="line">private TextInputPlugin textInputPlugin;</div><div class="line">private AndroidKeyProcessor androidKeyProcessor;</div><div class="line">private AndroidTouchProcessor androidTouchProcessor;</div><div class="line">private AccessibilityBridge accessibilityBridge;</div></pre></td></tr></table></figure>
<p>Flutter Engine核心成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private final AccessibilityChannel accessibilityChannel;</div><div class="line">private final KeyEventChannel keyEventChannel;</div><div class="line">private final LifecycleChannel lifecycleChannel;</div><div class="line">private final LocalizationChannel localizationChannel;</div><div class="line">private final NavigationChannel navigationChannel;</div><div class="line">private final PlatformChannel platformChannel;</div><div class="line">private final SettingsChannel settingsChannel;</div><div class="line">private final SystemChannel systemChannel;</div><div class="line">private final TextInputChannel textInputChannel;</div></pre></td></tr></table></figure>
<p>另外，在最新版本 Flutter v1.9.1 已经提供了FlutterEngineProvider相关接口，即官方有意提供混合栈的管理方案，但现在只是个半成品，如果直接用的话，会发现返回键点不动，跟了下发现是把PlatformChannel的Handler给置空了，除此之外还有一些其他的问题。</p>
<p>具体实现参见最新版的Flutter_Boost，已经做好了Flutter v1.9.1的适配，总体上实现已经跟embedding差别不大，有差别的点在于FlutterEngine的attach和detach的时机不同、FlutterPlugin的生命周期做了下同步，感兴趣的自己去阅读，这里不详细说了。</p>
<p>总结一下：</p>
<p>优点：</p>
<ul>
<li>Flutter层多Navigator方案，支持同级Flutter Widget随意切换</li>
<li>提供了一种新的思路，理论上Flutter跳转可以仍然使用官方api，可以在中间拦截</li>
<li>多FlutterView，不需要截屏</li>
</ul>
<p>缺点：</p>
<ul>
<li>略有侵入性，各个Flutter版本需要适配</li>
</ul>
<h2 id="共享Isolate"><a href="#共享Isolate" class="headerlink" title="共享Isolate"></a>共享Isolate</h2><p>头条的方案，多FlutterView，多FlutterEngine，单Isolate方案</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20191122175942.png" alt=""></p>
<p>该方案需要修改Flutter engine源码，暂不考虑。</p>
<p>多FlutterEngine在同一运行环境下可以做到内存共享，但同时也需要注意内存同步的问题，毕竟每个FlutterEngine都各自持有UITaskRunner，可以同时操作同一份内存的，头条的解决方案是把这些线程全部做成共享的了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分析了上面几种混合栈管理方案，整体上来说闲鱼的共享FlutterEngine方案比较主流，其中的多Navigator有很大的参考价值。</p>
<p>对于51信用卡来说，可以以此为基础，建设符合公司内部使用的混合栈管理方案。主要有几个事情：</p>
<ul>
<li>Plugin 管理问题，Plugin 是指每条指令对应在Native（Android、iOS）上的实现，得益于Hybrid的基础设施建设，公司内部目前有200+ Plugin可以直接使用，这也就意味着大部分需要Native参与的功能，都已经实现好了，Flutter 端直接调用即可，这块可以参考之前的文章 <a href="http://w4lle.com/2018/11/16/51credit-android-architecture/">51信用卡 Android 架构演进实践</a> </li>
<li>路由管理，接入已有路由框架</li>
<li>Flutter v1.9.1兼容</li>
</ul>
<p>经过几个版本的迭代，目前已经完成了上面的几件事情，并在业务中使用。</p>
<p><strong>注：此篇文章成文时间较久，近期做了一些修改，主要增加了Flutter v1.9.1 及相关的内容。</strong></p>
<p>参考</p>
<ul>
<li><p><a href="https://jiongks.name/blog/weex-multi-instance-runtime/" target="_blank" rel="external">Weex 在 JS Runtime 内的多实例管理</a></p>
</li>
<li><p><a href="https://www.jiqizhixin.com/articles/2019-03-07-15" target="_blank" rel="external">Flutter混合开发——FlutterBoost</a></p>
</li>
<li><p><a href="https://juejin.im/post/5b764acb51882532dc1812b1" target="_blank" rel="external">Flutter新锐专家之路：混合开发篇</a></p>
</li>
<li><p><a href="https://juejin.im/post/5c419c07f265da616f703aa1" target="_blank" rel="external">微店的Flutter混合栈管理技术实践</a></p>
</li>
<li><p><a href="https://www.msup.com.cn/share/details?id=226" target="_blank" rel="external">让Flutter真正支持View级别的混合开发</a></p>
</li>
<li><a href="https://zhuanlan.zhihu.com/p/38026271" target="_blank" rel="external">为追求高性能，我必须告诉你Flutter引擎线程的事实</a></li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2019/11/22/flutter-hybrid-stack/">http://w4lle.com/2019/11/22/flutter-hybrid-stack/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Flutter-混合栈管理&quot;&gt;&lt;a href=&quot;#Flutter-混合栈管理&quot; class=&quot;headerlink&quot; title=&quot;Flutter 混合栈管理&quot;&gt;&lt;/a&gt;Flutter 混合栈管理&lt;/h1&gt;&lt;p&gt;本文主要聊一下 Flutter 混合栈，由于 Flutter 版本跨度较大，所以 Flutter API 也有很大变化，下文中前几个方案的实现看看就好，不用深究。重点关注兼容目前 Flutter 版本(v1.9.1) 的实现。本文以 Android 平台为例进行讲解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://w4lle.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>UI2Code（三）imgcook</title>
    <link href="http://w4lle.com/2019/04/08/UI2Code-2/"/>
    <id>http://w4lle.com/2019/04/08/UI2Code-2/</id>
    <published>2019-04-08T11:30:15.000Z</published>
    <updated>2019-11-24T02:58:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>imgcook是阿里实现的基于sketch或Ps设计稿，自动生成布局代码的工具，支持生成支持flexbox布局的代码，包括JARVIS、Vue、微信小程序、React、H5、Rax等等。由两部分组成，一个是sketch(Ps)插件，另外一部分是<a href="https://imgcook.taobao.org/" target="_blank" rel="external">imgcook平台</a>。</p>
<a id="more"></a>
<p>系列文章：</p>
<ul>
<li><a href="http://w4lle.com/2019/03/13/UI2Code-0/">UI2Code（一）pix2code</a></li>
<li><a href="http://w4lle.com/2019/03/22/UI2Code-1/">UI2Code（二）pixeltoapp</a></li>
<li><a href="http://w4lle.com/2019/04/08/UI2Code-2/">UI2Code（三）imgcook</a></li>
</ul>
<p>经过前面的研究，我们知道，UI2Code作为可以从UI截图生成布局代码的工作，其构建流程大致如下：</p>
<ol>
<li>版面分析，包含背景分析和前景分析</li>
<li>提取GUI元素</li>
<li>组件识别</li>
<li>属性提取</li>
<li>布局推导</li>
<li>DSL 推导</li>
<li>编译，得到目标平台代码</li>
</ol>
<p>其中难点是版面分析和布局推导。</p>
<p>版面分析，目的是得到相对准确的背景和前景，通过传统的计算机图像计算和机器学习，将UI图片拆分并分层，得到相对独立的控件，为下一步控件识别和属性提取做准备。可以说，这部分做的好坏直接影响到后面所有的流程。</p>
<p>而对于线上业务逻辑来说，UI图千变万化，背景和前景可能存在很复杂的耦合关系，没有统一的规则约束，这就导致版面分析的难度较大。</p>
<ol>
<li>通过纯图像计算，版面分析不准确，组件间的提取不够独立或被隔断，泛化能力不够</li>
<li>通过机器学习识别，控件属性信息不全，没有坐标、宽度等信息，且准确度不够</li>
</ol>
<p>所以将图像计算与机器学习相结合，通过上述1、2、3、4步骤得到一定泛化能力且相对准确的版面结构和控件信息。</p>
<p>而对于我们来说，1、2、3、4步想要得到的内容，在Sketch设计稿里面都是有提供的，我们只需要想办法将其提取处理就可以，然后进行下一步操作。</p>
<p>所以经过优化后，整个流程如下：</p>
<ol>
<li>提取 Sketch 设计稿信息</li>
<li>布局推导</li>
<li>DSL 推导</li>
<li>编译</li>
</ol>
<p>imgcook 做的就是这样的事情。</p>
<h1 id="实际效果"><a href="#实际效果" class="headerlink" title="实际效果"></a>实际效果</h1><p>页面级别 ：</p>
<p>设计稿 </p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1bpzqptv3j30k2120wh6.jpg" alt=""> </p>
<p>运行效果 </p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1gfnovz73j30u01rcmys.jpg" alt=""> </p>
<p>卡片级别 ：</p>
<p>设计稿 </p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1gfb9ubk6j30ku098my0.jpg" alt=""> </p>
<p>运行效果 </p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1gfe6muckj30tu0glmz3.jpg" alt=""></p>
<h1 id="实现拆解"><a href="#实现拆解" class="headerlink" title="实现拆解"></a>实现拆解</h1><p>主要分为几个大的过程：</p>
<ol>
<li>Sketch -&gt; Json</li>
<li>Json -&gt; DSL</li>
<li>DSL -&gt; Code</li>
</ol>
<p>分别来看下。</p>
<h2 id="sketchToJson"><a href="#sketchToJson" class="headerlink" title="sketchToJson"></a>sketchToJson</h2><p>在sketch中选中图层，或者symbol，选中imgcook插件导出，当从sketch导出时，会产生一个json文件，以上面第二个卡片为例，信息如下 </p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1gg7w0xdqj31440u0wk9.jpg" alt=""> </p>
<p>其中包含的信息包括： </p>
<ul>
<li><p>artboardImg，选中symbol的渲染图，如<a href="https://ai-sample.oss-cn-hangzhou.aliyuncs.com/test/b4dd75404f6e11e9b26815c07ac4b122.png" target="_blank" rel="external">https://ai-sample.oss-cn-hangzhou.aliyuncs.com/test/b4dd75404f6e11e9b26815c07ac4b122.png</a> </p>
</li>
<li><p>控件唯一id </p>
</li>
<li><p>控件类型，比如Text、Image、Shape、Repeat </p>
</li>
<li><p>控件属性props，包括xy坐标、宽高、背景色、背景圆角、溢出处理(overflow)、图片内容、文字内容、字体和大小、字体颜色、行高、行数等等 </p>
</li>
<li><p>children属性，这个一般都是铺平的，当时Type是Repeat时会有该值 </p>
</li>
</ul>
<p>而在插件处理过程中，可能会有以下过程：</p>
<ul>
<li><p>没有图层信息，图层信息都被过滤掉 </p>
</li>
<li><p>平铺的数组，没有层级关系和兄弟关系 </p>
</li>
<li><p>Repeat包含多个children，内容是Text </p>
</li>
<li><p>完全被遮挡或者不可见的控件被过滤 </p>
</li>
<li><p>复杂的mask计算，对于遮罩的处理 </p>
</li>
<li><p>控件类型和属性都是依次解析 </p>
</li>
</ul>
<p>相当于把sketch文件中的所有信息都处理过后，得到一份期望的json文件，其中基本没有布局层次属性，仅有控件属性，包括大小、位置、控件特有属性等。</p>
<p>布局层次关系及位置关系由下一步来具体确定。</p>
<h2 id="JsonToDSL"><a href="#JsonToDSL" class="headerlink" title="JsonToDSL"></a>JsonToDSL</h2><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1ghk5j5h0j31iw0u0aim.jpg" alt=""> </p>
<p>把上面的json复制到imgcook平台，会发起gen-layout-process请求，该请求会把json文件当做请求参数上传，并返回一个dsl的Response，请求抓包文件结果经过缩减后大概如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"type"</span>: <span class="string">"Block"</span>,</div><div class="line">  <span class="attr">"id"</span>: <span class="string">"Block-661077"</span>,</div><div class="line">  <span class="attr">"__VERSION__"</span>: <span class="string">"2.0"</span>,</div><div class="line">  <span class="attr">"mask"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">"props"</span>: &#123;</div><div class="line">    <span class="attr">"style"</span>: &#123;</div><div class="line">      <span class="attr">"display"</span>: <span class="string">"flex"</span>,</div><div class="line">      <span class="attr">"alignItems"</span>: <span class="string">"flex-start"</span>,</div><div class="line">      <span class="attr">"flexDirection"</span>: <span class="string">"column"</span>,</div><div class="line">      <span class="attr">"width"</span>: <span class="number">375</span>,</div><div class="line">      <span class="attr">"height"</span>: <span class="number">164</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"attrs"</span>: &#123;</div><div class="line">      <span class="attr">"x"</span>: <span class="number">0</span>,</div><div class="line">      <span class="attr">"y"</span>: <span class="number">0</span>,</div><div class="line">      <span class="attr">"className"</span>: <span class="string">"block-661077"</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"children"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"__VERSION__"</span>: <span class="string">"2.0"</span>,</div><div class="line">      <span class="attr">"props"</span>: &#123;</div><div class="line">        <span class="attr">"style"</span>: &#123;</div><div class="line">          <span class="attr">"display"</span>: <span class="string">"flex"</span>,</div><div class="line">          <span class="attr">"alignItems"</span>: <span class="string">"flex-start"</span>,</div><div class="line">          <span class="attr">"flexDirection"</span>: <span class="string">"row"</span>,</div><div class="line">          <span class="attr">"backgroundColor"</span>: <span class="string">"#ffffff"</span>,</div><div class="line">          <span class="attr">"width"</span>: <span class="number">375</span>,</div><div class="line">          <span class="attr">"height"</span>: <span class="number">68</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">"attrs"</span>: &#123;</div><div class="line">          <span class="attr">"x"</span>: <span class="number">0</span>,</div><div class="line">          <span class="attr">"y"</span>: <span class="number">0</span>,</div><div class="line">          <span class="attr">"className"</span>: <span class="string">"shape-0"</span></div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      <span class="attr">"children"</span>: [</div><div class="line">        &#123;</div><div class="line">          <span class="attr">"__VERSION__"</span>: <span class="string">"2.0"</span>,</div><div class="line">          <span class="attr">"props"</span>: &#123;</div><div class="line">            <span class="attr">"style"</span>: &#123;</div><div class="line">              <span class="attr">"marginTop"</span>: <span class="number">6</span>,</div><div class="line">              <span class="attr">"marginLeft"</span>: <span class="number">6</span>,</div><div class="line">              <span class="attr">"width"</span>: <span class="number">23</span>,</div><div class="line">              <span class="attr">"height"</span>: <span class="number">23</span></div><div class="line">            &#125;,</div><div class="line">            <span class="attr">"attrs"</span>: &#123;</div><div class="line">              <span class="attr">"x"</span>: <span class="number">22</span>,</div><div class="line">              <span class="attr">"y"</span>: <span class="number">22</span>,</div><div class="line">              <span class="attr">"source"</span>: <span class="string">"https://ai-sample.oss-cn-hangzhou.aliyuncs.com/test/b46d27404f6e11e98785ebe830f6201d.png"</span>,</div><div class="line">              <span class="attr">"src"</span>: <span class="string">"https://ai-sample.oss-cn-hangzhou.aliyuncs.com/test/b46d27404f6e11e98785ebe830f6201d.png"</span>,</div><div class="line">              <span class="attr">"className"</span>: <span class="string">"image-7"</span></div><div class="line">            &#125;</div><div class="line">          &#125;,</div><div class="line">          <span class="attr">"children"</span>: [],</div><div class="line">          <span class="attr">"type"</span>: <span class="string">"Image"</span>,</div><div class="line">          <span class="attr">"id"</span>: <span class="string">"Image-7"</span>,</div><div class="line">          <span class="attr">"componentType"</span>: <span class="string">"picture"</span>,</div><div class="line">          <span class="attr">"_jsonId"</span>: <span class="string">"Image-7"</span>,</div><div class="line">          <span class="attr">"_jsonElementId"</span>: <span class="string">"Image-7"</span>,</div><div class="line">          <span class="attr">"title"</span>: <span class="string">"Image"</span>,</div><div class="line">          <span class="attr">"semantic"</span>: &#123;</div><div class="line">            <span class="attr">"dvc_default"</span>: [</div><div class="line">              &#123;</div><div class="line">                <span class="attr">"name"</span>: <span class="string">"dvc_default"</span>,</div><div class="line">                <span class="attr">"level"</span>: <span class="number">100</span>,</div><div class="line">                <span class="attr">"result"</span>: <span class="string">"img"</span>,</div><div class="line">                <span class="attr">"prefix"</span>: <span class="string">""</span>,</div><div class="line">                <span class="attr">"id"</span>: <span class="number">262862</span></div><div class="line">              &#125;</div><div class="line">            ],</div><div class="line">            <span class="attr">"dvc_picture"</span>: [</div><div class="line">              &#123;</div><div class="line">                <span class="attr">"name"</span>: <span class="string">"dvc_picture"</span>,</div><div class="line">                <span class="attr">"level"</span>: <span class="number">88</span>,</div><div class="line">                <span class="attr">"result"</span>: <span class="string">"zhaoshangbank"</span>,</div><div class="line">                <span class="attr">"prefix"</span>: <span class="string">""</span>,</div><div class="line">                <span class="attr">"id"</span>: <span class="number">953603</span>,</div><div class="line">                <span class="attr">"choose"</span>: <span class="literal">true</span></div><div class="line">              &#125;</div><div class="line">            ]</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      ],</div><div class="line">      <span class="attr">"type"</span>: <span class="string">"Shape"</span>,</div><div class="line">      <span class="attr">"id"</span>: <span class="string">"Shape-0"</span>,</div><div class="line">      <span class="attr">"__ADAPT__"</span>: <span class="literal">true</span>,</div><div class="line">      <span class="attr">"componentType"</span>: <span class="string">"view"</span>,</div><div class="line">      <span class="attr">"_jsonId"</span>: <span class="string">"Shape-0"</span>,</div><div class="line">      <span class="attr">"_jsonElementId"</span>: <span class="string">"Shape-0"</span>,</div><div class="line">      <span class="attr">"title"</span>: <span class="string">"Shape"</span>,</div><div class="line">      <span class="attr">"semantic"</span>: &#123;</div><div class="line">        <span class="attr">"dvc_layout"</span>: []</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  <span class="attr">"artboardImg"</span>: <span class="string">"https://ai-sample.oss-cn-hangzhou.aliyuncs.com/test/b4dd75404f6e11e9b26815c07ac4b122.png"</span>,</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"可提1 copy"</span>,</div><div class="line">  <span class="attr">"componentType"</span>: <span class="string">"view"</span>,</div><div class="line">  <span class="attr">"_jsonId"</span>: <span class="string">"Block-661077"</span>,</div><div class="line">  <span class="attr">"_jsonElementId"</span>: <span class="string">"Block-661077"</span>,</div><div class="line">  <span class="attr">"title"</span>: <span class="string">"Block"</span>,</div><div class="line">  <span class="attr">"semantic"</span>: &#123;</div><div class="line">    <span class="attr">"dvc_default"</span>: [</div><div class="line">      &#123;</div><div class="line">        <span class="attr">"name"</span>: <span class="string">"dvc_default"</span>,</div><div class="line">        <span class="attr">"level"</span>: <span class="number">100</span>,</div><div class="line">        <span class="attr">"result"</span>: <span class="string">"block"</span>,</div><div class="line">        <span class="attr">"prefix"</span>: <span class="string">""</span>,</div><div class="line">        <span class="attr">"id"</span>: <span class="number">613351</span></div><div class="line">      &#125;</div><div class="line">    ],</div><div class="line">    <span class="attr">"dvc_layout"</span>: [</div><div class="line">      &#123;</div><div class="line">        <span class="attr">"name"</span>: <span class="string">"dvc_layout"</span>,</div><div class="line">        <span class="attr">"level"</span>: <span class="number">100</span>,</div><div class="line">        <span class="attr">"result"</span>: <span class="string">"box"</span>,</div><div class="line">        <span class="attr">"prefix"</span>: <span class="string">""</span>,</div><div class="line">        <span class="attr">"id"</span>: <span class="number">803050</span>,</div><div class="line">        <span class="attr">"choose"</span>: <span class="literal">true</span></div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仔细观察该json文件，得出信息： </p>
<ul>
<li><p>完整的DomTree，嵌套关系明确 </p>
</li>
<li><p>控件属性props中多了一些信息，包括布局方式(“display”: “flex”)、flex布局方向(flexDirection)、主轴对齐方式(justifyContent)、副轴对齐方式(alignItems)、文本过长处理(text-overflow)、className、margin定位信息(marginTop、marginLeft) </p>
</li>
<li><p>语义semantic，是一个数组，最终产生一个className </p>
</li>
<li><p>组件类型componentType，包括view、text、picture </p>
</li>
</ul>
<p>这一步完成后，基本就得到了完整可用的布局DSL。</p>
<p>下一步就是compile的过程。</p>
<h2 id="DSL2Code"><a href="#DSL2Code" class="headerlink" title="DSL2Code"></a>DSL2Code</h2><p>DSL compile目标代码的过程，imgcook支持比较多的代码模板，JARVIS、Vue、微信小程序、React、H5、Rax。 </p>
<p>以Vue为例，发起请求，Response 结果这里不再列出，感兴趣的读者可以自行查看。</p>
<p>其中renderCode包含3部分内容： </p>
<ul>
<li><p>template，DOMTree，完整的布局信息，支持动态数据绑定 </p>
</li>
<li><p>script，需要绑定的方法逻辑</p>
</li>
<li><p>style，需要绑定的css样式</p>
</li>
</ul>
<p>分别对应vue中的代码块 </p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1ghaq0z2wj315e068401.jpg" alt=""> </p>
<p>实际的vue代码： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bd"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"zhaoshangbank-wrap"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">img</span></span></div><div class="line">          <span class="attr">class</span>=<span class="string">"zhaoshangbank"</span></div><div class="line">          <span class="attr">src</span>=<span class="string">"https://ai-sample.oss-cn-hangzhou.aliyuncs.com/test/b46d27404f6e11e98785ebe830f6201d.png"</span></div><div class="line">          @<span class="attr">click</span>=<span class="string">"onClick_2"</span></div><div class="line">        /&gt;</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"organization"</span>&gt;</span>招商银行 6889 <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"info"</span>&gt;</span>当前额度 <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>110,000<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      ...</div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"DvcComponent"</span>,</div><div class="line">  <span class="attr">methods</span>: &#123;</div><div class="line">    onClick_2()&#123;</div><div class="line">    	<span class="built_in">console</span>.log(<span class="string">"test"</span>)</div><div class="line">    &#125;,</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></div><div class="line">.box &#123;</div><div class="line">  display: flex;</div><div class="line">  align-items: flex-start;</div><div class="line">  flex-direction: column;</div><div class="line">  width: 375px;</div><div class="line">  height: 164px;</div><div class="line">...</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
<p>从生成的代码中可以看出，div一般使用flex布局。 这里的图片也已经被上传的图床，虽然不可线上使用，但是可以即时的预览。后面可以通过插件导出到本地。</p>
<p>到这里生成的代码基本是可用的，并且在imgcook平台上可以调整样式，绑定方法等操作。</p>
<p>这里的分析是很早以前进行的，数据结构可能已经变更，但大体上应该是相同的。</p>
<h1 id="实现难点"><a href="#实现难点" class="headerlink" title="实现难点"></a>实现难点</h1><p>经过上面的分析，基本知道了imgcook的大致流程，个人其中的难点在如下几个方面：</p>
<p>一是布局推导的过程，这块也是整个UI2Code的核心内容。</p>
<p>从准确性和还原过程中的可选项来看，应该是通过计算得到的，其中的布局细节较多，这块也是最重要的点，其结果直接导致页面布局的好坏。</p>
<p>imgcook平台对于这块的实现猜测是基于切割规则加算法来实现flex布局的，整体上来说基本能够实现设计稿上所体现的布局变化，但是有时候也会显得不够灵活，下面会详细说到。</p>
<p>具体如何实现布局推导，可以期待imgcook官方后续有没有说明。</p>
<p>这里只是引用一下闲鱼之前关于切割方面的论述，基本就是先横切再竖切，递归这个过程，在切割之前可以处理坐标嵌套，得到父子信息，然后在父布局中递归切割过程，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="string">'''</span></div><div class="line">切割方法</div><div class="line">---------------------------|</div><div class="line">|                          | </div><div class="line">|    --------- 30          | </div><div class="line">|    |        |            | </div><div class="line">|    --------- 60          | </div><div class="line">|                          | </div><div class="line">|    —————————— 120        | </div><div class="line">|    |         |           | </div><div class="line">|    ---------- 130        | </div><div class="line">|                          | </div><div class="line">|__________________________|</div><div class="line"></div><div class="line">如上图所示，第一个切线是60，第二个切线是130</div><div class="line">'''</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_by_col</span><span class="params">(cut_num, _im_mask)</span>:</span></div><div class="line">    zero_start = <span class="keyword">None</span></div><div class="line">    zero_end = <span class="keyword">None</span></div><div class="line">    end_range = len(_im_mask)</div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, end_range):</div><div class="line">        im = _im_mask[x]</div><div class="line">        <span class="keyword">if</span> len(np.where(im == <span class="number">255</span>)[<span class="number">0</span>]) == len(im):</div><div class="line">            <span class="comment"># 判断是否贯穿整个区域</span></div><div class="line">            <span class="keyword">if</span> zero_start == <span class="keyword">None</span>:</div><div class="line">                zero_start = x</div><div class="line">        <span class="keyword">elif</span> zero_start != <span class="keyword">None</span> <span class="keyword">and</span> zero_end == <span class="keyword">None</span>:</div><div class="line">            zero_end = x</div><div class="line">        <span class="keyword">if</span> zero_start != <span class="keyword">None</span> <span class="keyword">and</span> zero_end != <span class="keyword">None</span>:</div><div class="line">            start = zero_start</div><div class="line">            <span class="keyword">if</span> start &gt; <span class="number">0</span>:</div><div class="line">                <span class="comment"># 首次非联通区域过滤掉</span></div><div class="line">                cut_num.append(start)</div><div class="line">            zero_start = <span class="keyword">None</span></div><div class="line">            zero_end = <span class="keyword">None</span></div><div class="line">        <span class="keyword">if</span> x == end_range - <span class="number">1</span> <span class="keyword">and</span> zero_start != <span class="keyword">None</span> <span class="keyword">and</span> zero_end == <span class="keyword">None</span> <span class="keyword">and</span> zero_start &gt; <span class="number">0</span>:</div><div class="line">            zero_end = x</div><div class="line">            start = zero_start</div><div class="line">            <span class="keyword">if</span> start &gt; <span class="number">0</span>:</div><div class="line">                cut_num.append(start)</div><div class="line">            zero_start = <span class="keyword">None</span></div><div class="line">            zero_end = <span class="keyword">None</span></div></pre></td></tr></table></figure>
<p>切割过后，根据各种优化算法得到实际的布局信息。</p>
<p>当然，实际生产过程肯定要比我猜测的要复杂的多得多。比如什么时候适合flex布局，什么时候适合相对布局，以及谁是优先级更高的，还有是否可以阈值控制来使相对布局变成flex布局等等。</p>
<p>第二个难点是ClassName的语义分析。</p>
<p>猜测是通过机器学习进行OCR图片识别和NLP自然语言处理翻译，这块属于易用性方面的优化。</p>
<p>第三个难点是配套设施，上面分析的都是如何得到一个相对准确的布局DSL，imgcook平台除了这个核心之外，平台给开发者提供了更好的拓展，根据得到的DSL信息，开发者可以根据自己的喜好编译成各种平台、各种语言。另外还有工程化配套的工具，比如导出插件，可以把生成的文件全部导出到本地，不依赖线上图床服务等等。</p>
<h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><ul>
<li><p>数据绑定，需要手动绑定数据，并且data名字要先想好 </p>
</li>
<li><p>图床问题，默认是上传至阿里的图床，不可以直接使用，可以使用导出的zip包中包含所有的icon </p>
</li>
<li><p>界面布局，简版 flex，基本只有方向，默认margin定位 </p>
</li>
<li><p>flex 的对齐方式，比如justify-content: space-between属性阈值较低，大概2个像素，不容易被触发 </p>
</li>
</ul>
<p>不过imgcook团队一直在做优化工作，相信可以做的越来越好用，造福开发者。</p>
<h1 id="u51-weex"><a href="#u51-weex" class="headerlink" title="u51-weex"></a>u51-weex</h1><p>基于以上的分析，和imgcook平台的开放能力，我这边第一时间体验了自定义DSL的功能，由于我们团队内使用weex较多，所以做了一个自定义weex DSL的功能，地址在：<a href="https://github.com/imgcook-dsl/u51-weex" target="_blank" rel="external">https://github.com/imgcook-dsl/u51-weex</a></p>
<p>具体的使用方式可以参考官方文档：<a href="https://imgcook.taobao.org/docs?slug=dsl-dev" target="_blank" rel="external">https://imgcook.taobao.org/docs?slug=dsl-dev</a></p>
<p>理论上来说可以对任意平台的布局进行拓展。</p>
<p>这块也在团队内部做了一些推广，整体上来说可以提高UI方面的开发效率，当然也存在着一些问题，这里就不具体展开了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整体来讲imgcook是一个基本可用的布局代码生成平台，对于提升工作效率方面有一些帮助。</p>
<p>同时，对于拓展平台支持的兼容性也比较不错。</p>
<p>虽然对于页面级别也可以生成，但是对于代码层级关系、后期代码维护上都不太建议直接上页面级别；比较建议的方式是生成卡片item的布局，导出作为一个component使用。 </p>
<p>最后希望更多开发者可以使用imgcook，提出一些建议，使得他们团队可以进行更多的优化。</p>
<p>这篇文章写的时间比较久，当文章发布的时候发现imgcook平台又新添加了<a href="https://imgcook.taobao.org/labs" target="_blank" rel="external">Lab</a>，期待更多有意思的产品。</p>
<p>本文链接： <a href="http://w4lle.com/2019/04/08/UI2Code-2/">http://w4lle.com/2019/04/08/UI2Code-2/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;imgcook是阿里实现的基于sketch或Ps设计稿，自动生成布局代码的工具，支持生成支持flexbox布局的代码，包括JARVIS、Vue、微信小程序、React、H5、Rax等等。由两部分组成，一个是sketch(Ps)插件，另外一部分是&lt;a href=&quot;https://imgcook.taobao.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;imgcook平台&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://w4lle.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>UI2Code（二）pixeltoapp</title>
    <link href="http://w4lle.com/2019/03/22/UI2Code-1/"/>
    <id>http://w4lle.com/2019/03/22/UI2Code-1/</id>
    <published>2019-03-22T09:36:57.000Z</published>
    <updated>2019-11-24T02:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://pixeltoapp.com/" target="_blank" rel="external">pixeltoapp</a> 是一个通过传统图像处理把屏幕截图转换为 Android 代码的项目，使用python实现，提供在线服务，具体实现在<a href="https://github.com/soumikmohianuta/pixtoapp" target="_blank" rel="external">项目源码地址</a></p>
<a id="more"></a>
<p>系列文章：</p>
<ul>
<li><a href="http://w4lle.com/2019/03/13/UI2Code-0/">UI2Code（一）pix2code</a></li>
<li><a href="http://w4lle.com/2019/03/22/UI2Code-1/">UI2Code（二）pixeltoapp</a></li>
<li><a href="http://w4lle.com/2019/04/08/UI2Code-2/">UI2Code（三）imgcook</a></li>
</ul>
<h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1bjfidsnoj30ku1940wr.jpg" alt="原图"> </p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1bjglum9yj30ly118wgz.jpg" alt="代码渲染图"> </p>
<p>生成的布局代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div></pre></td><td class="code"><pre><div class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">             android:layout_width=&quot;250.0dip&quot;</div><div class="line">             android:layout_height=&quot;541.3333333333334dip&quot;</div><div class="line">             android:layout_gravity=&quot;center_vertical|center_horizontal&quot;</div><div class="line">             android:background=&quot;@color/color_0&quot;&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/ImageView_0&quot;</div><div class="line">        android:layout_width=&quot;10.333333333333334dip&quot;</div><div class="line">        android:layout_height=&quot;10.333333333333334dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;74.33333333333333dip&quot;</div><div class="line">        android:layout_marginTop=&quot;499.3333333333333dip&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;</div><div class="line">        android:src=&quot;@drawable/img_0&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/ImageView_1&quot;</div><div class="line">        android:layout_width=&quot;10.333333333333334dip&quot;</div><div class="line">        android:layout_height=&quot;10.0dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;41.333333333333336dip&quot;</div><div class="line">        android:layout_marginTop=&quot;499.3333333333333dip&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;</div><div class="line">        android:src=&quot;@drawable/img_2&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/ImageView_2&quot;</div><div class="line">        android:layout_width=&quot;31.666666666666668dip&quot;</div><div class="line">        android:layout_height=&quot;18.0dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;198.0dip&quot;</div><div class="line">        android:layout_marginTop=&quot;491.3333333333333dip&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;</div><div class="line">        android:src=&quot;@drawable/img_5&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/ImageView_3&quot;</div><div class="line">        android:layout_width=&quot;10.333333333333334dip&quot;</div><div class="line">        android:layout_height=&quot;10.333333333333334dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;52.666666666666664dip&quot;</div><div class="line">        android:layout_marginTop=&quot;499.0dip&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;</div><div class="line">        android:src=&quot;@drawable/img_6&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/ImageView_4&quot;</div><div class="line">        android:layout_width=&quot;9.333333333333334dip&quot;</div><div class="line">        android:layout_height=&quot;11.0dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;188.0dip&quot;</div><div class="line">        android:layout_marginTop=&quot;498.6666666666667dip&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;</div><div class="line">        android:src=&quot;@drawable/img_7&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/ImageView_5&quot;</div><div class="line">        android:layout_width=&quot;10.666666666666666dip&quot;</div><div class="line">        android:layout_height=&quot;11.0dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;176.33333333333334dip&quot;</div><div class="line">        android:layout_marginTop=&quot;498.6666666666667dip&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;</div><div class="line">        android:src=&quot;@drawable/img_8&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/ImageView_6&quot;</div><div class="line">        android:layout_width=&quot;10.666666666666666dip&quot;</div><div class="line">        android:layout_height=&quot;10.666666666666666dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;165.33333333333334dip&quot;</div><div class="line">        android:layout_marginTop=&quot;498.6666666666667dip&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;</div><div class="line">        android:src=&quot;@drawable/img_9&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/ImageView_7&quot;</div><div class="line">        android:layout_width=&quot;1.6666666666666667dip&quot;</div><div class="line">        android:layout_height=&quot;14.666666666666666dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;124.33333333333333dip&quot;</div><div class="line">        android:layout_marginTop=&quot;496.6666666666667dip&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;</div><div class="line">        android:src=&quot;@drawable/img_10&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/ImageView_8&quot;</div><div class="line">        android:layout_width=&quot;250.0dip&quot;</div><div class="line">        android:layout_height=&quot;1.6666666666666667dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;0.0dip&quot;</div><div class="line">        android:layout_marginTop=&quot;489.0dip&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;</div><div class="line">        android:src=&quot;@drawable/img_11&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;FrameLayout</div><div class="line">        android:id=&quot;@+id/FrameLayout_9&quot;</div><div class="line">        android:layout_width=&quot;229.66666666666666dip&quot;</div><div class="line">        android:layout_height=&quot;101.0dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;10.0dip&quot;</div><div class="line">        android:layout_marginTop=&quot;383.3333333333333dip&quot;</div><div class="line">        android:background=&quot;@color/color_0&quot;&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_9&quot;</div><div class="line">            android:layout_width=&quot;22.0dip&quot;</div><div class="line">            android:layout_height=&quot;7.666666666666667dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;70.0dip&quot;</div><div class="line">            android:layout_marginTop=&quot;78.33333333333333dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_12&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_10&quot;</div><div class="line">            android:layout_width=&quot;22.0dip&quot;</div><div class="line">            android:layout_height=&quot;7.666666666666667dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;48.0dip&quot;</div><div class="line">            android:layout_marginTop=&quot;78.33333333333333dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_13&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_11&quot;</div><div class="line">            android:layout_width=&quot;7.0dip&quot;</div><div class="line">            android:layout_height=&quot;7.333333333333333dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;40.666666666666664dip&quot;</div><div class="line">            android:layout_marginTop=&quot;78.33333333333333dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_14&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_12&quot;</div><div class="line">            android:layout_width=&quot;14.666666666666666dip&quot;</div><div class="line">            android:layout_height=&quot;7.333333333333333dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;26.0dip&quot;</div><div class="line">            android:layout_marginTop=&quot;78.33333333333333dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_15&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_13&quot;</div><div class="line">            android:layout_width=&quot;14.666666666666666dip&quot;</div><div class="line">            android:layout_height=&quot;7.666666666666667dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;11.333333333333334dip&quot;</div><div class="line">            android:layout_marginTop=&quot;78.33333333333333dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_16&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_14&quot;</div><div class="line">            android:layout_width=&quot;44.666666666666664dip&quot;</div><div class="line">            android:layout_height=&quot;20.0dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;174.33333333333334dip&quot;</div><div class="line">            android:layout_marginTop=&quot;72.0dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_18&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_15&quot;</div><div class="line">            android:layout_width=&quot;49.0dip&quot;</div><div class="line">            android:layout_height=&quot;8.333333333333334dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;24.333333333333332dip&quot;</div><div class="line">            android:layout_marginTop=&quot;40.333333333333336dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_21&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_16&quot;</div><div class="line">            android:layout_width=&quot;12.333333333333334dip&quot;</div><div class="line">            android:layout_height=&quot;7.0dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;11.666666666666666dip&quot;</div><div class="line">            android:layout_marginTop=&quot;41.0dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_22&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_17&quot;</div><div class="line">            android:layout_width=&quot;8.666666666666666dip&quot;</div><div class="line">            android:layout_height=&quot;8.0dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;210.33333333333334dip&quot;</div><div class="line">            android:layout_marginTop=&quot;40.666666666666664dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_23&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_18&quot;</div><div class="line">            android:layout_width=&quot;24.0dip&quot;</div><div class="line">            android:layout_height=&quot;8.333333333333334dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;184.0dip&quot;</div><div class="line">            android:layout_marginTop=&quot;40.333333333333336dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_24&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_19&quot;</div><div class="line">            android:layout_width=&quot;8.0dip&quot;</div><div class="line">            android:layout_height=&quot;5.666666666666667dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;210.66666666666666dip&quot;</div><div class="line">            android:layout_marginTop=&quot;29.0dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_25&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_20&quot;</div><div class="line">            android:layout_width=&quot;37.333333333333336dip&quot;</div><div class="line">            android:layout_height=&quot;9.333333333333334dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;49.0dip&quot;</div><div class="line">            android:layout_marginTop=&quot;25.333333333333332dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_26&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_21&quot;</div><div class="line">            android:layout_width=&quot;37.333333333333336dip&quot;</div><div class="line">            android:layout_height=&quot;9.333333333333334dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;11.333333333333334dip&quot;</div><div class="line">            android:layout_marginTop=&quot;25.333333333333332dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_27&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_22&quot;</div><div class="line">            android:layout_width=&quot;7.666666666666667dip&quot;</div><div class="line">            android:layout_height=&quot;12.666666666666666dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;200.0dip&quot;</div><div class="line">            android:layout_marginTop=&quot;22.0dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_28&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_23&quot;</div><div class="line">            android:layout_width=&quot;4.333333333333333dip&quot;</div><div class="line">            android:layout_height=&quot;12.333333333333334dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;193.33333333333334dip&quot;</div><div class="line">            android:layout_marginTop=&quot;22.0dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_29&quot;/&gt;</div><div class="line">    &lt;/FrameLayout&gt;</div><div class="line">    ...</div></pre></td></tr></table></figure>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1bmgzbb4rj31o90u00z4.jpg" alt=""> </p>
<p>整体处理过程： </p>
<p>原图 -&gt; 灰度处理 - 降噪 - 边缘探测，提取边缘轮廓 - 膨胀处理 - 框选边缘轮廓 - 遍历轮廓构建ViewTree - 删除重复元素，合并Layout布局，梳理ViewTree - 判断控件类型，目前支持Text和Image - 切割图像、文本识别，绑定控件属性 - 构建XML布局 </p>
<p>整体分为三个大的过程：背景分析、前景分析和布局构建 </p>
<p>- 背景分析：通过机器视觉算法，得到图像轮廓 </p>
<p>- 前景分析：对轮廓碎片进行整理，合并，识别 </p>
<p>- 布局构建：基于以上信息构建布局 </p>
<p>下面依次看下 </p>
<h2 id="背景分析"><a href="#背景分析" class="headerlink" title="背景分析"></a>背景分析</h2><p>包含 灰度处理、降噪、边缘探测、膨胀处理、框选边缘轮廓等几个步骤 </p>
<h3 id="灰度处理"><a href="#灰度处理" class="headerlink" title="灰度处理"></a>灰度处理</h3><p>二值化处理，作用是得到相对干净的背景底色 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">img_gray = cv2.cvtColor(img_color, cv2.COLOR_BGR2GRAY)</div></pre></td></tr></table></figure>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1bkowh846j30ku194q53.jpg" alt=""> </p>
<h3 id="降噪"><a href="#降噪" class="headerlink" title="降噪"></a>降噪</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cv2.fastNlMeansDenoising(img_gray)</div></pre></td></tr></table></figure>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1bkraa5qfj30ku194jtm.jpg" alt=""> </p>
<h3 id="边缘探测"><a href="#边缘探测" class="headerlink" title="边缘探测"></a>边缘探测</h3><p>使用Canny进行边缘探测，Canny算子是一种经典的边缘检测算子，它能得到精确的边缘位置。</p>
<p>Canny检测的一般步骤为：</p>
<ol>
<li>用高斯滤波进行降噪</li>
<li>用一阶偏导的有限差分计算梯度的幅值和方向 </li>
<li>对梯度幅值进行非极大值抑制</li>
<li>用双阈值检测和连接边缘。实验过程中，需要多次尝试选择较好的双阈值参数。 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cv2.Canny(imgData,self.lowThreshold,self.highThreshold)</div></pre></td></tr></table></figure>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1bksbdqhgj30ku194dgj.jpg" alt=""> #20-40 </p>
<h3 id="形态学膨胀"><a href="#形态学膨胀" class="headerlink" title="形态学膨胀"></a>形态学膨胀</h3><p>检测出来的边缘在某些局部地方会断开，可以采用特定形状和尺寸的结构元素对二值化图像进行形态学膨胀处理来连接断开的边缘。 </p>
<p>使用大小为(3，3)的十字线进行膨胀处理 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ratio =<span class="number">2</span>; </div><div class="line"></div><div class="line">kernel = np.ones((<span class="number">2</span> * dilationSize + <span class="number">1</span>, <span class="number">2</span> * dilationSize + <span class="number">1</span>), np.uint8) </div><div class="line"></div><div class="line">img_dilation = cv2.dilate(imgData, kernel, iterations=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1bkvi7ng4j30ku194t9b.jpg" alt=""> </p>
<h3 id="框选轮廓"><a href="#框选轮廓" class="headerlink" title="框选轮廓"></a>框选轮廓</h3><p>为了直观的看到轮廓形状，我们用红色把轮廓框起来，其中可以看到很多相同控件内的文字并没有联通，所以上一步的膨胀处理的参数仍然有调整空间 </p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1bkz5o1mbj30ku194jyb.jpg" alt=""> </p>
<p>背景分析基本就这些，下面看前景分析。</p>
<h2 id="前景分析"><a href="#前景分析" class="headerlink" title="前景分析"></a>前景分析</h2><p>前景分析包括对轮廓碎片进行整理并构建ViewTree、ViewTree优化合并、控件识别。</p>
<h3 id="构建ViewTree"><a href="#构建ViewTree" class="headerlink" title="构建ViewTree"></a>构建ViewTree</h3><p>得到轮廓参数后遍历操作，contours自带层级关系，按照该层级关系依次递归遍历，得到粗糙的ViewTree </p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1bl2vf5naj31lm0u0gv0.jpg" alt=""> </p>
<h3 id="ViewTree优化"><a href="#ViewTree优化" class="headerlink" title="ViewTree优化"></a>ViewTree优化</h3><p>包括如下几个方面：</p>
<ul>
<li>删除重叠区域view </li>
<li>合理划分父子关系 </li>
<li>合并无意义的Layout控件 </li>
</ul>
<h3 id="控件识别"><a href="#控件识别" class="headerlink" title="控件识别"></a>控件识别</h3><p>到这一步就得到了每一个View的坐标属性及轮廓属性了，根据这些数据进行抠图并识别控件类型，<strong>这里只支持两种控件</strong>：TextView 和 ImageView，但是生成的代码只包含ImageView，猜测是因为OCR识别中文有问题，所以控件类型识别错误导致。 </p>
<ul>
<li><p>控件识别 </p>
</li>
<li><p>属性提取，图像、文字、颜色 </p>
</li>
</ul>
<p>这里作者还提供了ListView的实现，但是应该不是完整的，所以被注释掉了。</p>
<p>到这一步，根据上面的工作，就可以得到整个ViewTree的描述信息了，相当于得到了布局的DSL，但是这里并没有输出DSL，仅仅是在内存中数据结构的表现。</p>
<h1 id="布局构建"><a href="#布局构建" class="headerlink" title="布局构建"></a>布局构建</h1><p>背景分析和前景分析都做完之后，就可以根据以上信息进行布局生成工作 ：</p>
<ul>
<li><p>根布局是FrameLayout </p>
</li>
<li><p>子布局有两种FrameLayout和RelativeLayout </p>
</li>
<li><p>控件都是相对父布局的绝对布局，layout_marginLeft，layout_marginTop </p>
</li>
<li><p>代码中看 RelativeLayout 中有相对布局，不过看生成的代码没有看到 </p>
</li>
</ul>
<p>这一步处理之后就可以得到布局代码了，生成布局代码后，这里也有一个compile的过程，根据提供的template工程，将布局代码带入，就可以得到可以运行的Android工程了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于设计稿是iOS，宽度750px的设计稿，所以出来的布局代码在Android上是没有适配的，不过这个关系都不大。 </p>
<p>这个项目提供了通过传统的机器视觉图像算法生成布局的思路。但是也存在一些问题： </p>
<ul>
<li>对于复杂界面处理能力有限</li>
<li>传统图像处理的方式，对于不同场景阈值可能需要频繁的调整，典型的如膨胀参数</li>
<li>泛化能力较弱，支持控件类型太少，并且识别准确率确实不行</li>
<li>布局能力有限，基本都是绝对坐标，布局比较死板 </li>
</ul>
<p>现在回过头来翻看闲鱼关于<a href="https://www.jiqizhixin.com/articles/2019-02-27-14" target="_blank" rel="external">版面分析的文章</a>，其中的主要流程跟pixtoapp基本一致，并且一些参数都是一样的，比如膨胀参数，猜测闲鱼团队应该也是参考过这个项目，并在这基础上做了一些优化。 </p>
<p>结合pix2code项目，pixtoapp进行版面分析，切割控件、得到布局，pix2code使用ML进行控件识别，最后进行组装，得到一个完整的布局，这种思路是可行的，猜测闲鱼也是基于这样的思路来做的。 </p>
<p>这种方案其中的一个最重要的点，也是最难的点，就是布局能力太弱，闲鱼文中提到的布局方式也是规则实现，那么就是类似pixtoapp中的实现方式，但是有一点不同的是，切割方式不同，所以闲鱼有row和col，而pixtoapp没有，RNN前置反馈这个还没有了解到，后面再看下。 </p>
<blockquote>
<p>前期我们采用4层LSTM网络进行训练学习，由于样本量比较小，我们改为规则实现。规则实现也比较简单，我们在第一步切图时5刀切割的顺序就是row和col。缺点是布局比较死板，需要结合RNN进行前置反馈。 </p>
</blockquote>
<p>通过两篇文章的分析，UI2Code的大体思路是通了的，但是核心点构建布局还没有很好的解决方案，还需要再详细思考下实现方案。 </p>
<p>参考 ：</p>
<p><a href="https://www.jiqizhixin.com/articles/2018-12-29-5" target="_blank" rel="external">基于AI的移动端自动化测试框架的设计</a> </p>
<p><a href="https://www.jiqizhixin.com/articles/2019-02-27-14" target="_blank" rel="external">UI2Code智能生成Flutter代码——版面分析篇</a></p>
<p>本文链接： <a href="http://w4lle.com/2019/03/22/UI2Code-1/">http://w4lle.com/2019/03/22/UI2Code-1/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://pixeltoapp.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pixeltoapp&lt;/a&gt; 是一个通过传统图像处理把屏幕截图转换为 Android 代码的项目，使用python实现，提供在线服务，具体实现在&lt;a href=&quot;https://github.com/soumikmohianuta/pixtoapp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;项目源码地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://w4lle.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>UI2Code（一）pix2code</title>
    <link href="http://w4lle.com/2019/03/13/UI2Code-0/"/>
    <id>http://w4lle.com/2019/03/13/UI2Code-0/</id>
    <published>2019-03-13T08:27:22.000Z</published>
    <updated>2019-11-24T02:57:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>pix2code 项目通过机器学习，支持输入一张图片输出实际的布局代码，同时支持生成三端(Android、iOS、web)布局代码。</p>
<p>pix2code作为UI2Code的先驱项目，后续的相关项目或多或少的都有参考该项目的实现。</p>
<a id="more"></a>
<p>系列文章：</p>
<ul>
<li><a href="http://w4lle.com/2019/03/13/UI2Code-0/">UI2Code（一）pix2code</a></li>
<li><a href="http://w4lle.com/2019/03/22/UI2Code-1/">UI2Code（二）pixeltoapp</a></li>
<li><a href="http://w4lle.com/2019/04/08/UI2Code-2/">UI2Code（三）imgcook</a></li>
</ul>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="https://github.com/tonybeltramelli/pix2code" target="_blank" rel="external">项目地址</a><br><a href="https://arxiv.org/abs/1705.07962" target="_blank" rel="external">论文地址</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650728064&amp;idx=1&amp;sn=adb744e599299916faa23545c2ab436e&amp;chksm=871b22feb06cabe83ba0e3268a7a8c0c486cf6f42427ab41814e69242f919b25bc7de06ea258&amp;scene=21#wechat_redirect" target="_blank" rel="external">论文翻译</a></p>
<p>使用双显卡服务器跑出模型，耗时大概1.5小时，模型数量1500张图片，1500个对应DSL，模型大小450M左右</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20191115164209.png" alt=""></p>
<p>然后使用验证集生成DSL，比对原始DSL</p>
<p>对比1：</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images03BC80FA-5959-4432-9622-19958492D0E7.png" alt=""></p>
<p>对比2：</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images61B2D439-EC8E-4574-8BB9-D7D427B1BDF0.png" alt=""></p>
<p>对比3：</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images77658E09-48B9-489D-B69A-69C6DB57AD75.png" alt=""></p>
<p>验证集共生成了250张图片对应的DSL，总体来看不能做到100%还原DSL，作者称可以做到77%左右的准确率。</p>
<p>以其中一个图片为例</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesCD7F3D19-3D1B-4070-833C-54AE57B6AC9E.png" alt=""></p>
<p>生成的DSL </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">stack&#123; </div><div class="line"></div><div class="line">  row&#123; </div><div class="line"></div><div class="line">    label,slider,label </div><div class="line"></div><div class="line">  &#125; </div><div class="line">&#125; </div><div class="line"></div><div class="line">footer&#123; </div><div class="line"></div><div class="line">	btn-search,btn-search,btn-search,btn-search </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译compile后生成的Android xml 布局文件</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images7B1049AC-A185-4F64-945D-32CDB2EF7C57.png" alt=""></p>
<p>结果是有10个控件，其中的8个是正确的，2个是识别错误的。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>基于图像标记（image caption）构建一种把图像和文本连接在一起的模型，用于生成源图像内容的描述。 </p>
<p>pix2code是一个基于卷及神经网络(CNN)和循环神经网络(LSTM，长短时神经单元)能够由单个GUI屏幕截图生成源代码的项目。 </p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20191115163604.png" alt=""></p>
<p>模型采用监督学习，有连个输入，一个数GUI截图，另外一个是对应的布局DSL。这些布局文件都足够简单，DSL也仅仅对控件进行了描述，不涉及位置信息和控件属性。<br>首先将GUI图像 I 通过CNN网络生成特征向量P，然后DSL 符号T 描述切割成一个序列 X（xt, t ∈ {0 . . . T − 1}）通过第一个语言模型得到特征向量qt（该语言模型由两个 LSTM 层、每层带有128个神经单元来实现），视觉编码向量 p 和语言编码向量 qt 可以级联为单一向量 rt，该级联向量 rt 随后可以投送到基于 LSTM 的模型来解码。因此解码器就学到了输入 GUI 图像中的对象和 DSL 代码中的符号间的关系，因此也就可以对这一关系进行建模。我们的解码器由两个 LSTM 层、每层带有 512 个单元的堆栈而实现。最后通过一个softmax进行一个分类对当前项进行预测，并把结果作为下一项的输入。</p>
<p>核心代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">image_model = Sequential()</div><div class="line">image_model.add(Conv2D(32, (3, 3), padding=&apos;valid&apos;, activation=&apos;relu&apos;, input_shape=input_shape))</div><div class="line">image_model.add(Conv2D(32, (3, 3), padding=&apos;valid&apos;, activation=&apos;relu&apos;))</div><div class="line">image_model.add(MaxPooling2D(pool_size=(2, 2)))</div><div class="line">image_model.add(Dropout(0.25))</div><div class="line"></div><div class="line">image_model.add(Conv2D(64, (3, 3), padding=&apos;valid&apos;, activation=&apos;relu&apos;))</div><div class="line">image_model.add(Conv2D(64, (3, 3), padding=&apos;valid&apos;, activation=&apos;relu&apos;))</div><div class="line">image_model.add(MaxPooling2D(pool_size=(2, 2)))</div><div class="line">image_model.add(Dropout(0.25))</div><div class="line"></div><div class="line">image_model.add(Conv2D(128, (3, 3), padding=&apos;valid&apos;, activation=&apos;relu&apos;))</div><div class="line">image_model.add(Conv2D(128, (3, 3), padding=&apos;valid&apos;, activation=&apos;relu&apos;))</div><div class="line">image_model.add(MaxPooling2D(pool_size=(2, 2)))</div><div class="line">image_model.add(Dropout(0.25))</div><div class="line"></div><div class="line">image_model.add(Flatten())</div><div class="line">image_model.add(Dense(1024, activation=&apos;relu&apos;))</div><div class="line">image_model.add(Dropout(0.3))</div><div class="line">image_model.add(Dense(1024, activation=&apos;relu&apos;))</div><div class="line">image_model.add(Dropout(0.3))</div><div class="line"></div><div class="line">image_model.add(RepeatVector(CONTEXT_LENGTH))</div><div class="line"></div><div class="line">visual_input = Input(shape=input_shape)</div><div class="line">encoded_image = image_model(visual_input)</div><div class="line"></div><div class="line">language_model = Sequential()</div><div class="line">language_model.add(LSTM(128, return_sequences=True, input_shape=(CONTEXT_LENGTH, output_size)))</div><div class="line">language_model.add(LSTM(128, return_sequences=True))</div><div class="line"></div><div class="line">textual_input = Input(shape=(CONTEXT_LENGTH, output_size))</div><div class="line">encoded_text = language_model(textual_input)</div><div class="line"></div><div class="line">decoder = concatenate([encoded_image, encoded_text])</div><div class="line"></div><div class="line">decoder = LSTM(512, return_sequences=True)(decoder)</div><div class="line">decoder = LSTM(512, return_sequences=False)(decoder)</div><div class="line">decoder = Dense(output_size, activation=&apos;softmax&apos;)(decoder)</div><div class="line"></div><div class="line">self.model = Model(inputs=[visual_input, textual_input], outputs=decoder)</div><div class="line"></div><div class="line">optimizer = RMSprop(lr=0.0001, clipvalue=1.0)</div><div class="line">self.model.compile(loss=&apos;categorical_crossentropy&apos;, optimizer=optimizer)</div></pre></td></tr></table></figure>
<p>具体原理参考<a href="https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650728064&amp;idx=1&amp;sn=adb744e599299916faa23545c2ab436e&amp;chksm=871b22feb06cabe83ba0e3268a7a8c0c486cf6f42427ab41814e69242f919b25bc7de06ea258&amp;scene=21#wechat_redirect" target="_blank" rel="external">论文翻译</a>。</p>
<p>生成 DSL 后，通过compiler编译成三端代码 UI -&gt; DSL -&gt; Code。</p>
<p>其中compile过程，就是替换DSL描述到实际控件的过程，这些实际控件的属性和布局位置信息全是写死的，存在放dsl-mapping文件中，以其中一个控件为例，对照关系如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;check&quot;: </div><div class="line">&quot;&lt;CheckBox android:id=\&quot;@+id/[ID]\&quot; </div><div class="line">	android:layout_width=\&quot;wrap_content\&quot; </div><div class="line">	android:layout_height=\&quot;wrap_content\&quot; </div><div class="line">	android:paddingRight=\&quot;10dp\&quot; </div><div class="line">	android:text=\&quot;[TEXT]\&quot;/&gt;&quot;,</div></pre></td></tr></table></figure>
<p>所以pix2code的核心是通过机器学习得到对应布局的DSL，compiler 是规则替换的过程。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>pix2code具有70%左右的准确率， 基于该项目，西安交大通过一些优化使准确率进一步提高。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images4E51A20B-550F-4016-94FF-9C718DDA2B2F.png" alt=""></p>
<p>参考文章 <a href="https://www.jiqizhixin.com/articles/2018-11-05-12?from=synced&amp;keyword=pix2Code" target="_blank" rel="external">https://www.jiqizhixin.com/articles/2018-11-05-12?from=synced&amp;keyword=pix2Code</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>pix2code项目本身作为一个实验性质的项目，论证了GUI截图通过AI手段自动生成布局代码的可行性。 </p>
<p>但是由于其也存在一些问题： </p>
<ul>
<li>模型准确率不高，修改模型或者重新构建模型成本高 </li>
<li>中间过程不允许人工干预，其结果就是完整的DSL，人工干预是在DSL生成后 </li>
<li>训练素材标准成本高，这也是深度学习都会碰到的一个实际问题 </li>
<li>切割精准度不够，实际上它是以CNN网络提取图片特征，精准度不大达到像素级别的要求 </li>
<li>控件位置和属性信息缺失，不能准确还原布局 </li>
</ul>
<p>基于以上调研分析，pix2code项目仅仅作为一个研究性项目进行开源，并不能实际使用在生产环境中，作者明确表述该项目和论文仅仅作为实验，并且不会再进行进一步的平台拓展。 </p>
<p>我们可以探索在pix2code基础上，通过图像分析+pix2code控件识别 来进行UI2Code的工作。 </p>
<p>后面会去调研下pixelToApp这个项目，其基于传统的计算机视觉识别技术进行代码生成。 </p>
<p>论文：</p>
<p><a href="https://cs.anu.edu.au/courses/CSPROJECTS/18S2/initialTalks/u6013787.pdf" target="_blank" rel="external">UI Design to Code Skeleton</a></p>
<p>参考文章：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650728064&amp;idx=1&amp;sn=adb744e599299916faa23545c2ab436e&amp;chksm=871b22feb06cabe83ba0e3268a7a8c0c486cf6f42427ab41814e69242f919b25bc7de06ea258&amp;scene=21#wechat_redirect" target="_blank" rel="external">深度学习助力前端开发：自动生成GUI图代码</a></li>
<li><a href="https://www.jiqizhixin.com/articles/2018-12-29-5" target="_blank" rel="external">基于AI的移动端自动化测试框架的设计</a> </li>
<li><a href="https://www.jiqizhixin.com/articles/2018-11-05-12?from=synced&amp;keyword=pix2Code" target="_blank" rel="external">前端设计图转代码，西安交大表示复杂界面也能一步步搞定</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIzNjc1NzUzMw==&amp;mid=2247496681&amp;idx=3&amp;sn=885b227400bdc8c81d74feffcb1b6c5c&amp;scene=0#wechat_redirect" target="_blank" rel="external">前端利器！让AI根据手绘原型生成HTML | 教程+代码</a></li>
<li><a href="https://medium.freecodecamp.org/how-you-can-train-an-ai-to-convert-your-design-mockups-into-html-and-css-cc7afd82fed4" target="_blank" rel="external">How you can train an AI to convert your design mockups into HTML and CSS</a></li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2019/03/13/UI2Code-0/">http://w4lle.com/2019/03/13/UI2Code-0/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pix2code 项目通过机器学习，支持输入一张图片输出实际的布局代码，同时支持生成三端(Android、iOS、web)布局代码。&lt;/p&gt;
&lt;p&gt;pix2code作为UI2Code的先驱项目，后续的相关项目或多或少的都有参考该项目的实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://w4lle.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>51信用卡 Android 架构演进实践</title>
    <link href="http://w4lle.com/2018/11/16/51credit-android-architecture/"/>
    <id>http://w4lle.com/2018/11/16/51credit-android-architecture/</id>
    <published>2018-11-16T03:24:10.000Z</published>
    <updated>2019-11-15T07:40:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着业务的快速扩张，原本小作坊式的单个工程的开发模式越来与不能满足实际需求。早在两年多以前，51信用卡管家就向下沉淀出了单独的公用基础库，一些通用的功能组件和个别独立的业务被拆分成 SDK，形成了一套中型项目、多人并行的开发模式，也为未来组件化拆分做准备。</p>
<a id="more"></a>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwi9479hnhj31g00uk49x.jpg" alt="image-20181023162224348"></p>
<p>这套框架运行了一段时间之后，伴随着单应用内业务需求的增加、开发人员数量的增多、基础库数量的膨胀，导致了一些问题：</p>
<ul>
<li>主工程代码耦合严重，牵一发而动全身</li>
<li>需求测试影响面大，不能聚焦单一业务模块</li>
<li>主工程代码越来越多，编译耗时</li>
<li>依赖倒置，业务代码依赖App工程</li>
<li>SDK 界限模糊，基础库和业务库界限不明确</li>
<li>业务模块间可以任意依赖调用，依赖规则不明确</li>
<li>类库越来越多，不好管理</li>
</ul>
<p>除了以上问题，动态化需求也越来越强烈，依赖 Hybrid + H5 打开页面慢的问题也凸显出来。</p>
<p>这些问题推动我们更进一步的升级开发构架。</p>
<h1 id="组件化-or-插件化"><a href="#组件化-or-插件化" class="headerlink" title="组件化 or 插件化"></a>组件化 or 插件化</h1><h2 id="动态化"><a href="#动态化" class="headerlink" title="动态化"></a>动态化</h2><p>最近两年，插件化框架层出不穷，各大厂都放出了自家开源的插件化框架。作为 Native 动态化与性能兼顾的插件化方案，很多公司选择插件化作为动态化技术方案。动态性通常有两部分的作用：一是动态热修复；二是动态下发业务插件。对于第一点，我们有热修复框架可以完成这部分工作；对于第二点，我们使用了 Hybrid 加载H5的方式实现，虽然性能上有所欠缺，但完全切到 Native 来做有点推倒重来的意思，并且跟业界同学交流后，对于动态下发业务插件用到的情况也不多，业务更新主要还是依靠 App 升级来实现。技术方案没有最优解，选择适合自己的才是最好的。</p>
<p>由于插件化也存在一些弊端，比如不可避免的 hook framework、修改 aapt、包装 Gradle Plugin、代理组件等等非常规操作，日常维护也是一笔不小的开销，稳定性、兼容性、新版本适配等等问题都需要考虑进去。对于 Android 端是否使用插件化，公司内部做过一些讨论，结论是不急着上，边走边看，先把业务组件拆分出来再说。</p>
<p>如今回过头看，自从 Android P发布以来，限制 hook framework 后，插件化逐渐开始式微，后面走向大概率是维护成本越来越高，成本收益比逐渐降低，最终弃坑不用。</p>
<p>除了插件化外，动态化方案近两年比较火的就是以 ReactNative、Weex 为代表的大前端方向，结合51信用卡的实际情况，最终选择拥抱大前端， Weex 作为动态化方案，以 Native 为主， Hybrid 离线化方案为辅，Weex 逐步迭代的架构开发模式。</p>
<p>Weex 的基础建设和前端同学合作，历经大半年时间，目前已经稳定应用在51信用卡各个 App 上，Weex 作为动态化页面的首选方案，已经完成了线上数百个页面的开发需求。配合离线化方案，各项性能指标也都达到要求。</p>
<h2 id="组件分离"><a href="#组件分离" class="headerlink" title="组件分离"></a>组件分离</h2><p>代码解耦与代码隔离，最有效的方案是工程隔离。审视我们最初的方案，每个 SDK 对应单独的仓库，通过 maven 依赖，通过工程分离隔离代码，这种方案没有问题，只不过需要往前更近一步，各个业务模块也需要独立主工程，拆分成独立的业务组件。</p>
<p>同时，划分清楚代码边界，控制依赖关系，梳理清楚层次结构，最终形成如下图所示的架构。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwrpnjc8xdj31hc0u0gt5.jpg" alt="组件化层次.001"></p>
<p>整体架构上提供三种容器：</p>
<ul>
<li>Native 容器，采用组件化架构，用于原生业务开发</li>
<li>Hybrid 容器，webview 加载 H5，配合离线化方案</li>
<li>Weex 容器，用于编写常规的页面，js 动态转化成 Native 控件，天然具有动态化特性，配合离线化方案，达到页面秒开的效果，同时共用 Hybrid 沉淀出的比较完善的 PG 方法</li>
</ul>
<p>同时，Hybrid 和 Weex 依赖于原生提供的方法，通过 JsBridge 进行通信，目前共有 200 多个 PG 方法供 js 调用。长远来看，这三种容器并不会互相取代，相反地，它们应该是相互依存、取长补短、长期共存的状态。</p>
<h1 id="组件化实践"><a href="#组件化实践" class="headerlink" title="组件化实践"></a>组件化实践</h1><p>Native 容器对应上图中各个层级的定义：</p>
<ul>
<li>工程 App，各个应用工程，目前已有十多个应用并行开发，51信用卡管家作为平台应用，其余应用为独立的业务工程应用</li>
<li>业务组件，独立的业务组件，一般为复合业务组件，api 与实现分离，相互之间依赖隔离</li>
<li>基础业务 SDK，独立的小的单功能模块，提供基础功能，目前这一层级中还包含遗留未改造的部分业务组件</li>
<li>基础 Lib，业务无关的基础组件</li>
</ul>
<p>组件化拆分的核心诉求是解耦合，提高组件内聚，所以应该从诉求出发，在沿用当下开发模式，并且不强依赖组件化框架的情况下，逐渐的进行组件化拆分。</p>
<p>通过工程隔离进而进行组件化拆分后，基本可以解决上面提到的问题：</p>
<ul>
<li>高内聚，低耦合，代码边界清晰，代码变动影响面可以准确评估</li>
<li>提高开发效率，每个组件可以独立打包，单独调试，最多几十秒就可以完成打包过程</li>
<li>每个组件负责组件内的事情，理论上只要保证组件内部稳定，接入工程 App 后也不会产生新的问题</li>
<li>降低 App 工程编译时间，最理想的情况是，App 工程仅仅是一个空壳，用于加载各个组件</li>
</ul>
<p>解耦，一般需要避免直接依赖，转为间接依赖，简单来说就是依赖隔离。对于组件化而言，每个组件都是单独的实现，单个组件对外提供的服务尽可能单一，依赖尽可能少；同时，依赖其它组件功能或页面的情况下，尽可能避免直接依赖，最好依赖中间层进行集中式管理，然后再进行逻辑分发。所以我们一般采用分总分的结构：组件内部分别注册，编译时生成汇总代码、运行时集中式管理，调用时处理逻辑分发。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwrpngbj7qj30yy0i4di0.jpg" alt="image-20181026181156315"></p>
<p>组件化需要解耦处理的几个基础模块：</p>
<ul>
<li>页面路由</li>
<li>模块间调用</li>
<li>消息总线</li>
<li>数据总线</li>
</ul>
<p>下面依次介绍。</p>
<h2 id="页面路由"><a href="#页面路由" class="headerlink" title="页面路由"></a>页面路由</h2><p>路由分发本质上是把直接依赖引用转化为中心化管理分发的一个过程，由于组件化拆分后，各个业务组件间不存在直接的依赖关系，所以必然要有一个统一收集页面跳转规则进而再分发的过程。</p>
<p>51信用卡在 2017 年就在进行路由化实践，以应对后面进行的组件化拆分需求，并沉淀出一套自研的路由框架 U51OkDeepLink，它也采用分总分结构，主要原理是组件内注册路由，编译时在组件内生成独立的路由表，并用 AOP 在编译时做好所有组件内路由表汇总的工作，调用初始化方法时进行路由表汇总，页面跳转时再进行管理分发，其用法很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//组件内注册路由</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleService</span> </span>&#123;</div><div class="line">    <span class="meta">@Path</span>(<span class="string">"/main"</span>)</div><div class="line">    <span class="meta">@Activity</span>(MainActivity.class)</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startMainActivity</span><span class="params">(@Query(<span class="string">"key"</span>)</span> String key)</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//其余组件唤起页面</span></div><div class="line"><span class="keyword">new</span> DeepLinkClient(context).buildRequest(<span class="string">"old://app/main?key=value"</span>).addQuery(<span class="string">"key2"</span>, <span class="string">"2"</span>).start();</div></pre></td></tr></table></figure>
<p>并且支持强大的异步特性，支持跳转过程中的中间逻辑处理。</p>
<p>其原理图如下</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwrpnhjehsj31ju0uewka.jpg" alt="router"></p>
<p>感兴趣的读者可以阅读 <a href="https://www.jianshu.com/p/8a3eeeaf01e8" target="_blank" rel="external">Android 组件化 —— 路由设计最佳实践</a> 获取更多技术细节。</p>
<h2 id="模块间调用"><a href="#模块间调用" class="headerlink" title="模块间调用"></a>模块间调用</h2><p>组件间层次和边界模糊问题的产生，根本原因是各个业务组件间的相互依赖关系混乱，为了进行业务组件间的隔离，首先要做好组件之间的服务调用解耦。</p>
<p>这里采用的是 ServiceLoader 的模式，组件工程目录一般如下所示</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwrpnfmr75j30bs052glm.jpg" alt="image-20181024204942179"></p>
<p>每个组件内一般声明三个 module：</p>
<ul>
<li>api module，声明对外暴露的服务接口和对外暴露的实体类及 Event 事件</li>
<li>imp module，依赖 api module，是 api module 的具体实现，不对外暴露细节，不允许其他组件对 imp module 进行直接依赖</li>
<li>app module，是工程的壳，可以直接运行调试，通过 SDKTemplate 创建生成，包含各种运行时所需环境</li>
</ul>
<p>业务组件之间依赖 api 库的服务接口，imp 库作为实现动态查找。版本发布时，同时发布 api 和 imp 两个库，并且保证 api 和 imp 具有相同版本号，这个在组件发版时统一管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//组件内 api module 接口声明</span></div><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestService</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//组件内 imp module 接口实现</span></div><div class="line"><span class="meta">@ServiceImpl</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//跨组件调用</span></div><div class="line">compile <span class="string">'com.u51.android:test-lib-api:$version'</span></div><div class="line"></div><div class="line">CommentService service = ServicesLoader.getInstance().getService(TestService.class);</div><div class="line">service.sayHello();</div></pre></td></tr></table></figure>
<p>它的实现原理与路由类似，也是采用分总分结构，在编译时通过 APT 生成汇总代码，调用时动态查找注入 Service 及其实现类的绑定关系。</p>
<p>与路由初始化汇总路由表不同的是，ServiceLoader 在调用时查找，省去了初始化的逻辑，Service 不会像路由这么多，查找起来不会存在遍历太慢的问题。</p>
<h2 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h2><p>消息总线是基于 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 实现的跨三端（Native、Hybrid、Weex）事件管理分发组件 U51EventBus。跨三端是指在任意一端注册监听后，在事件触发时都可以得到响应。</p>
<p>对于原生开发来说，EventBus 本身可以满足需求，虽然有点事件满天飞的缺点，但是还在可接受范围之内。对于业务组件来说，其 Event 类需要放在 api module 中进行暴露。</p>
<p>对于 Hybrid 和 Weex 来说，一般的 bridge 都是 callback 形式得到异步响应，对于全局事件通知支持不太友好。通过 bridge 通道连接 U51EventBus 消息总线，打通跨三端全局的事件监听及分发，得以实现任意事件可以在 Native、H5、Weex 之间相互发送和监听。比如，类似登陆、登出操作在 Native 发出后，全局已打开的 H5 或 Weex 页面可以立即得到感知。</p>
<p>其实现原理也是采用分总分结构，在编译时对 EventBus 进行了定制封装，事件分发还是使用的原有的 EventBus 分发逻辑。</p>
<h2 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h2><p>数据存储采用基于 <a href="https://developer.android.com/topic/libraries/architecture/room" target="_blank" rel="external">Room</a> 实现的统一 KV 存储框架，底层数据库依然是 sqlite，性能这块没有做特别强调，强制其在子线程中进行操作，用于支持日常开发中配置和业务数据的存取操作。</p>
<p>另外，数据总线支持按模块进行存取，每个业务组件都可以定义自有 tag，避免字段冲突问题。</p>
<h1 id="跨平台混合开发实践"><a href="#跨平台混合开发实践" class="headerlink" title="跨平台混合开发实践"></a>跨平台混合开发实践</h1><p>无论从早期的 PhoneGap、Cordova，还是近年来比较火的 ReactNative、Weex，到最近两年崛起的 Flutter，跨平台混合开发一直深受众多开发青睐。究其原因，还是其跨平台和动态化是原生开发所不具备的特性。</p>
<h2 id="Hybrid-容器实践"><a href="#Hybrid-容器实践" class="headerlink" title="Hybrid 容器实践"></a>Hybrid 容器实践</h2><p>Native 和 H5 混合开发一般是比较常见的混合开发模式，H5 开发效率高、迭代快速、不依赖 App 发版，51信用卡众多 App 产品中，有很多页面都是用 H5 来开发，嵌入原生 App 中使用 webview 进行加载显示。</p>
<p>早期 H5 容器在各个 App 中分别独立实现，没有统一的架构和规范，导致对 H5 的支持效率较低，PG 方法（来源于 PhoneGap）的开发、测试和维护都相当的混乱，重复性工作太多。</p>
<p>Native 层提供一套通用性强、功能丰富、稳定性高的 H5 容器对业务的高速发展至关重要。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwxgmjrohtj31kw0zkwth.jpg" alt="image-20181105173903973"></p>
<h3 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h3><p>由于 H5 不具备直接调用原生方法，所以原生壳要提供一套通用的通信方式，一般为 JsBridge，在 Android 端，实现 JsBridge 通信的通道一般有以下几种：</p>
<ul>
<li>shouldOverrideUrlLoading</li>
<li>addJavascriptInterface</li>
<li>onJsPrompt/onJsAlert</li>
</ul>
<p>而通道不是关键，怎样管理和维护 PG 方法调用才是核心。为此，我们把每个方法定义为一个 Plugin，用插件的形式管理 PG 方法，这样可以做到每个插件独立运行，互不干扰。插件管理也是采用分总分结构，在各个业务组件中分别注册，编译是通过 APT 生成汇总代码，运行时进行插件汇总，最后调用通过 PluginManager 查找分发逻辑。</p>
<p>插件注册代码如下，其中 <code>onExecute()</code> 方法在 js 调用该方法时触发，执行结果通过 <code>evaluateJavaScript()</code> 方法异步返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@JsPlugin</span>(name = TestPlugin.PLUGIN_NAME, loadOnInit = <span class="keyword">false</span>, version = <span class="number">1</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPlugin</span> <span class="keyword">extends</span> <span class="title">EnNiuJsPlugin</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PLUGIN_NAME = <span class="string">"TestPlugin"</span>;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPluginName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> PLUGIN_NAME;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onExecute</span><span class="params">(String args)</span> </span>&#123;</div><div class="line">        doSomething();                    </div><div class="line">        callbackContext.callback(...);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，H5 容器和插件都具有 Activity 生命周期感知能力，插件的生命周期：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwxgmhf6r9j31kw16eas1.jpg" alt="image-20181105191433330"></p>
<h3 id="配套设施"><a href="#配套设施" class="headerlink" title="配套设施"></a>配套设施</h3><p>插件统一通过插件管理平台进行维护管理，目前已有200+插件。PG 插件作为基础通用功能，采取集中式管理机制，任何人在新增、修改插件都需要进行相关负责人审核，以避免出现 Android、iOS 两端实现不统一，版本间实现不统一等问题。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwxgmi1nm7j31kw0ebdl6.jpg" alt="image-20181105191949792"></p>
<p>插件调试通过调试平台进行操作，浏览器中打开调试地址，App 端通过调试工具扫码建立连接，即可进行插件调试。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwxgmiq9l1j31kw110thw.jpg" alt="image-20181105192429943"></p>
<h3 id="离线加载"><a href="#离线加载" class="headerlink" title="离线加载"></a>离线加载</h3><p>Hybrid 混合开发的一大劣势就是性能比较差，打开页面较慢，特别是在弱网情况下。由于51信用卡业务大部分都是静态资源请求，参考业界做法，我们实现了动态下发离线包的方式来提升H5页面打开速度。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwxgmkmdnlj31ca12wn45.jpg" alt="lixianbao"></p>
<p>这里细节问题不具体展开。</p>
<p>除了以上提到的实践外，我们还做了很多工作，比如 UI 统一、Back 键拦截、公共参数处理、PG 白名单机制、H5监控、PG 方法监控等等，限于文章篇幅，这里不再一一列出，敬请关注后续相关文章。</p>
<h2 id="Weex-容器实践"><a href="#Weex-容器实践" class="headerlink" title="Weex 容器实践"></a>Weex 容器实践</h2><p>在 Hybrid 已有配套基础上，51信用卡选择了 Weex 作为跨平台方案，经过一年的踩坑填坑过程，目前已经有 20+ 个项目、数百个 Weex 页面在线上稳定运行，并且，目前 Weex 方案趋于成熟，已经作为51信用卡端内首选业务方案。</p>
<h3 id="共享插件"><a href="#共享插件" class="headerlink" title="共享插件"></a>共享插件</h3><p>由于 Hybrid 良好的面向接口编程特性，在进行 Weex 基础建设过程中，很方便的就把已有的插件集成进来，并且共享已沉淀的配套设施。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ENBridgeModule</span> <span class="keyword">extends</span> <span class="title">WXModule</span> </span>&#123;</div><div class="line">    <span class="meta">@JSMethod</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String method, String args, JSCallback jsCallback)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        weexWebView = weexEngine.getWeexVirtualWebView();</div><div class="line">        EnNiuJsBridge enNiuJsBridge = weexWebView.getEnNiuJsBridge();</div><div class="line">        enNiuJsBridge.notify(pg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注册 Weex 的 Module，并且每个 Weex Engine 中会新建出一个虚拟 webview，用于桥接 JsBridge 进而调用 PluginManager 进行插件逻辑分发。</p>
<p>Weex 容器实践在之前的文章中已经提到过一部分，具体请看 <a href="https://mp.weixin.qq.com/s/PSquf5ILDykC9jYFu911qg" target="_blank" rel="external">Weex避坑指南-理论篇 </a>，后续还将有 Weex 实践相关的文章放出，这里不做过多篇幅的介绍，敬请关注后续相关文章。</p>
<h1 id="工程化实践"><a href="#工程化实践" class="headerlink" title="工程化实践"></a>工程化实践</h1><p>工程化本质上是为了提高研发效率。51信用卡客户端团队自研的大风车管理平台，用于 App 管理、持续集成、类库管理、发版管理等，围绕客户端研发上下游流程，建立统一的管理入口。</p>
<p>目前，51信用卡 iOS 和 Android 共 30 多个应用 App、 200 多个类库依托大风车平台进行管理。下面主要介绍下类库管理相关内容。</p>
<h2 id="类库管理"><a href="#类库管理" class="headerlink" title="类库管理"></a>类库管理</h2><p>51信用卡目前有 100 多个 Android 类库，每个类库对应一个独立的 Gitlab 仓库。过多的独立组件及独立仓库，管理起来有些麻烦。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwrpnk3uc9j31kw0scaj6.jpg" alt="image-20181030193630574"></p>
<p>依托于大风车平台，所有类库的名称、最新版本及标签类型都会展示在列表页，标签类型对应组件化架构的层次结构，包括：基础组件、单业务功能组件、多业务功能组件。</p>
<p>在类库详情页，会有库的功能描述、groupId:artifactId 依赖信息、版本历史记录、分支信息、README、CHANGELOG、负责人等详情信息。</p>
<p>所有的类库管理工作都可以在大风车完成，包括新建类库、类库发版、查阅相关信息等等，这大大提高了基础组的研发效率，降低了团队间的沟通成本。</p>
<p>并且 App 工程中，该 App 所依赖的所有类库信息一目了然，在多人维护、多类库并行开发、类库频繁发版的情况下，依赖类库信息 check 更加便捷。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwrpng2bwcj31kw1540z0.jpg" alt="image-20181031160854953"></p>
<h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p>由于类库之间是仓库隔离，所以它们的依赖关系是 maven 依赖，所有类库的 aar 包都需要发布到内部 maven 服务器上，上传工作由 PublishMavenPlugin 完成。</p>
<h3 id="SNAPSHOT-预览版"><a href="#SNAPSHOT-预览版" class="headerlink" title="SNAPSHOT 预览版"></a>SNAPSHOT 预览版</h3><p>对于开发调试阶段，每个类库自带 DemoApp 工程，所以采用源码依赖；开发完成后，类库使用<code>SNAPSHOT</code>版本（比如 1.0.0-SNAPSHOT）发布到 maven 服务器，接入 App 工程后 push 代码触发大风车打包，进行集成测试。需要修改类库时，可以再重复发布相同版本的<code>SNAPSHOT</code>版本。</p>
<p><code>SNAPSHOT</code>版本可以在开发同学自己的机器上进行打包发布。</p>
<h3 id="正式版"><a href="#正式版" class="headerlink" title="正式版"></a>正式版</h3><p>对于发布阶段，类库必须使用正式版本发布，由于正式版本不可重复发布，这也就要求开发同学保证每个正式版本的版本质量，在正式发布前都应达到发布标准。</p>
<p>由于类库内部也存在相互依赖的情况，所以在类库正式发布时，不允许依赖包含<code>SNAPSHOT</code>版本的类库，<code>DependencyCheck</code>工作也会在  PublishMavenPlugin 完成。</p>
<p>同时，正式版本不允许开发同学在本机打包发布，PublishMavenPlugin 会检测是否在云端打包环境。功能分支经 CodeReview 后合并 master 分支，然后创建对应版本的 tag，触发大风车进行打包发布工作，发布成功后，会邮件通知 Android 组同学，并附带 CHANGELOG。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwxgz042voj312q0qa44m.jpg" alt="image-20181105204154472"></p>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><p>App 工程下采用 compile 依赖，compile 会解析类库 maven 包中的 pom 文件，进而间接依赖 pom 文件中声明的其他类库，也就是依赖传递。正常情况下，依赖传递会减少不必要的类库声明，当出现版本冲突时会自动处理 merge 操作。</p>
<p>但是，在多人协同工作、多类库并行开发情况下，事情变得有些复杂。考虑一种情况，应用 A 依赖类库 B，类库 B 依赖类库 C，正常情况下，A 中只需要声明依赖 B 即可，C 会被依赖传递过去。如果 C 中改变了方法签名，并且在应用 A 中显示声明依赖 C，编译时和运行时会分别出现什么情况？在编译时没有问题，正常编译通过；在运行时，当运行到类库 B 中使用的类库 C 中被改变签名的方法时，App crash。这是因为，maven 在处理类库版本 merge 时，会将 C 升级到最高版本，而此时 B 中已经编译好的 class 中使用的还是老版本 C 中的方法。</p>
<p>为了处理这个问题，我们使用 APICheckGradlePlugin 在编译时进行 check 操作，当发现被调用的方法找不到时，主动报错，将错误提前暴露在编译期，而非在运行时。同时内部强调 API 接口的向下兼容性，不用的方法标记为废弃，而非直接修改其方法签名或删除方法。</p>
<p>APICheckGradlePlugin 核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    c.getClassPool().get(callClassName)</div><div class="line">    isClassNotFound = <span class="keyword">false</span></div><div class="line">    m.getMethod()</div><div class="line">&#125; <span class="keyword">catch</span> (NotFoundException e) &#123;</div><div class="line">    <span class="keyword">if</span> (isClassNotFound) &#123;</div><div class="line">        dealException(String.format(<span class="string">"在%s类中的第%d行是用到的%s类不存在"</span>, className, line, callClassName))</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dealException(String.format(<span class="string">"在%s类中的第%d行是用到的%s类的%s方法不存在"</span>, className, line, callClassName, methodName))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="多module发布"><a href="#多module发布" class="headerlink" title="多module发布"></a>多module发布</h3><p>上文中提到，在多业务组件库工程中会有多个 module，一个 api module，一个 imp module，在使用 DemoApp 编译调试时采用源码依赖， imp module 依赖 api module，App 依赖 imp module，这样在打包上传 maven 时，会出现无法一起上传的问题；并且我们也要确保 api 和 imp 的版本号一致。为了解决这个问题，需要在上传时动态修改他们的 pom 文件，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">modifyPom &#123; pom -&gt;</div><div class="line">    pom.dependencies.findAll &#123; dep -&gt; dep.groupId == rootProject.name &#125;.collect &#123; dep -&gt;</div><div class="line">        dep.groupId = pom.groupId = rootProject.groupId</div><div class="line">        dep.version = pom.version = rootProject.sdkVersion</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="一键创建项目"><a href="#一键创建项目" class="headerlink" title="一键创建项目"></a>一键创建项目</h2><h3 id="模板工程"><a href="#模板工程" class="headerlink" title="模板工程"></a>模板工程</h3><p>由于每个新建组件类库的 App 工程需要运行时环境基本相同，包括网络环境、调试环境、gradle 配置、通用依赖配置等等，这些重复性的工作最好放在一起统一处理。为此，我们创建了组件库的模板工程，只需要 clone 下来模板仓库，然后修改一些代码即可开发需求代码。</p>
<h3 id="一键创建类库"><a href="#一键创建类库" class="headerlink" title="一键创建类库"></a>一键创建类库</h3><p>但是，这种方式依然有很多共性的工作，比如 clone 代码、修改类库名、修改 groupId:artifactId、创建新的类库仓库、push 代码、在大风车中新建类库关联仓库地址等等操作。这些共性操作仍然可以用机器来操作，所以我们在大风车新建类库这一步中，把前面所有要做的事情全部做完，只需要在新建类库时填入必要的参数，一键就可以创建出可用的类库项目。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwrpngxyd4j31g40mqdht.jpg" alt="image-20181031201425732"></p>
<h3 id="一键创建应用"><a href="#一键创建应用" class="headerlink" title="一键创建应用"></a>一键创建应用</h3><p>随着我司 App 越来越多，新建 App 的配置同样面临类库刚开始时的困扰，新建 App 与新建类库本质上是一样的，只不过所需参数更多一些，并且这些参数可能不固定，有些 App 需要有些 App 不需要。参考类库，我们提取共性操作，创建了 App 的模板工程，并且对接大风车，一键即可创建出 App 工程，那些可变的参数留在模板工程中按需手动配置。</p>
<h2 id="模块负责人"><a href="#模块负责人" class="headerlink" title="模块负责人"></a>模块负责人</h2><p>在组件化初步开始时，我们的每个模块都有固定的负责人，每个人手上都有固定的若干个模块，责任人对自己负责的模块负责。</p>
<p>但是随着组内的人员变动和业务变动，导致一些模块频繁易主，一些模块的文档长期处于不被维护状态，README 和 CHANGELOG 常年失修。</p>
<p>依赖大风车的类库管理，重新为每个模块指定负责人，并且梳理现存类库哪些缺失文档，进行补全。自从大风车自动抄送类库发版 CHANGELOG 后，CHANGELOG 不全的情况也大幅改善，基本每个新的版本都会附上该版本所做修改。</p>
<p>同时，我们也强调 CodeReview 机制，每个模块在提测前进行 CodeReview，强制merge request 必须有人点赞后才能合并 master 分支等等代码审查机制。未来，我们可能会进一步实践负责人 backup 方案，主副负责人相互 review，扩大大家技术视野的同时，可以进一步提高大家的主人翁意识。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好的架构不是设计出来的，而是演进出来的。本文简单阐述了51信用卡 Android 架构演进的一些实践经验，同时我们坚信技术方案没有最优解，重要的是要选择选择适合自己的。脱离所处环境和问题本身谈技术方案，都将不能得到适合自身的开发架构。同时，我们也应当吸取和借鉴业界优秀的架构和设计理念，并将其根据自身适用场景加以改造，在理论和实践中逐渐交替探索演进。</p>
<p>当然，我们目前所使用的架构依然存在一些问题，比如组件拆分不完全、主工程业务仍然很多、CodeReview 机制不健全、代码扫描不够严格、一些组件库没有严格按照 api 工程来改造、一些老的组件依然没有 api module等等问题。我们也应该看到，正是因为这些实际的问题在推动我们进行技术改造，架构升级。同时，我们也要审视行业内大的方向，紧跟技术趋势，主动拥抱变化，毕竟技术世界唯一不变的，便是变化。</p>
<p>本文链接： <a href="http://w4lle.com/2018/11/16/51credit-android-architecture/">http://w4lle.com/2018/11/16/51credit-android-architecture/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着业务的快速扩张，原本小作坊式的单个工程的开发模式越来与不能满足实际需求。早在两年多以前，51信用卡管家就向下沉淀出了单独的公用基础库，一些通用的功能组件和个别独立的业务被拆分成 SDK，形成了一套中型项目、多人并行的开发模式，也为未来组件化拆分做准备。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android热补丁之Robust（三）坑和解</title>
    <link href="http://w4lle.com/2018/06/20/robust-2/"/>
    <id>http://w4lle.com/2018/06/20/robust-2/</id>
    <published>2018-06-20T08:18:16.000Z</published>
    <updated>2018-06-20T13:12:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前两篇文章中，分析了 Android 热补丁框架 Robust 中，几个重要的流程包括：</p>
<ul>
<li>补丁加载过程</li>
<li>基础包插桩过程</li>
<li>补丁包自动化生成过程</li>
</ul>
<p>本篇文章主要分析下集成过程中遇到的坑以及分析问题的思路和最终的解决方案。包含：</p>
<ul>
<li>打补丁包出错？</li>
<li>Robust 定义的 API 不够用怎么办？</li>
<li>插件 Plugin Transform 的顺序问题？</li>
<li>与 Aspectj 冲突怎么办？</li>
<li>static 方法中包含 super 方法怎么办？</li>
</ul>
<a id="more"></a>
<p>系列文章:</p>
<ul>
<li><a href="http://w4lle.com/2017/03/31/robust-0/">Android热补丁之Robust原理解析(一)</a></li>
<li><a href="http://w4lle.com/2018/05/28/robust-1/">Android热补丁之Robust（二）自动化补丁原理解析</a></li>
<li><a href="http://w4lle.com/2018/05/29/robust-2/">Android热补丁之Robust（三）坑和解</a></li>
</ul>
<h1 id="打补丁包出错？"><a href="#打补丁包出错？" class="headerlink" title="打补丁包出错？"></a>打补丁包出错？</h1><p>在打补丁包过程中，碰到了一个错误 <code>execute command java -jar /Users/wanglinglong/Develop/u51/Credit51/CreditCardManager/robust/dx.jar --dex --output=classes.dex  meituan.jar error</code>，找了一大圈最后发现是jdk老版本在Mac上的一个bug，升级jdk就好了，参考 <a href="https://stackoverflow.com/questions/43003012/class-javalaunchhelper-is-implemented-in-two-places?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa" target="_blank" rel="external">Class JavaLaunchHelper is implemented in two places</a></p>
<h1 id="Robust-定义的-API-不够用怎么办？"><a href="#Robust-定义的-API-不够用怎么办？" class="headerlink" title="Robust 定义的 API 不够用怎么办？"></a>Robust 定义的 API 不够用怎么办？</h1><p>Robust 提供了一些 API 可供开发者扩展使用，比如：<br>添加类库依赖 <code>compile &#39;com.meituan.robust:robust:0.4.82&#39;</code>，其中 <code>PatchManipulateImp</code> 类的一些可扩展方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> List&lt;Patch&gt; <span class="title">fetchPatchList</span><span class="params">(Context context)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">verifyPatch</span><span class="params">(Context context, Patch patch)</span></span>;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">ensurePatchExist</span><span class="params">(Patch patch)</span></span>;</div></pre></td></tr></table></figure>
<p>但是在一些情况下，这些可扩展方法并不能满足我们的需求。</p>
<p>为了满足定制化需求，可以弃用 <code>com.meituan.robust:robust</code>，自己实现一套补丁加载逻辑，这个实现起来难度并不太大，主要补丁加载流程都可以参考 Robust 官方实现，具体加载逻辑可参考本系列第一篇文章，这里不再深入。</p>
<h1 id="插件-Plugin-Transform-的顺序问题？"><a href="#插件-Plugin-Transform-的顺序问题？" class="headerlink" title="插件 Plugin Transform 的顺序问题？"></a>插件 Plugin Transform 的顺序问题？</h1><p>首先，要找到 Gradle Plugin 编译过程中对于自定义 Transform 的处理，具体流程读者可以自行搜索查看，这里只给出关键代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">TaskManager.java</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Creates the post-compilation tasks for the given Variant.</div><div class="line"> *</div><div class="line"> * These tasks create the dex file from the .class files, plus optional intermediary steps like</div><div class="line"> * proguard and jacoco</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPostCompilationTasks</span><span class="params">(</span></span></div><div class="line">        @NonNull <span class="keyword">final</span> VariantScope variantScope) &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// ---- Code Coverage first -----</span></div><div class="line">    ...</div><div class="line">    <span class="comment">// Merge Java Resources.</span></div><div class="line">    createMergeJavaResTransform(variantScope);</div><div class="line">    <span class="comment">// ----- External Transforms -----</span></div><div class="line">    <span class="comment">// apply all the external transforms.</span></div><div class="line">    List&lt;Transform&gt; customTransforms = extension.getTransforms();</div><div class="line">    List&lt;List&lt;Object&gt;&gt; customTransformsDependencies = extension.getTransformsDependencies();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = customTransforms.size(); i &lt; count; i++) &#123;</div><div class="line">        Transform transform = customTransforms.get(i);</div><div class="line">        List&lt;Object&gt; deps = customTransformsDependencies.get(i);</div><div class="line">        transformManager</div><div class="line">                .addTransform(taskFactory, variantScope, transform)</div><div class="line">                .ifPresent(</div><div class="line">                        t -&gt; &#123;</div><div class="line">                            <span class="keyword">if</span> (!deps.isEmpty()) &#123;</div><div class="line">                                t.dependsOn(deps);</div><div class="line">                            &#125;</div><div class="line">                            <span class="comment">// if the task is a no-op then we make assemble task depend on it.</span></div><div class="line">                            <span class="keyword">if</span> (transform.getScopes().isEmpty()) &#123;</div><div class="line">                                variantScope.getAssembleTask().dependsOn(t);</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在生成 Dex 任务之前，会处理所有的自定义 Transform 任务，逻辑是按照顺序遍历然后处理任务依赖关系，那么从dzhe’l这里我们可以知道，Transform 的执行顺序是按照插件的声明顺序来执行的，也就是说，哪个 plugin 的声明在前，其对应的 Transform 就在前执行，举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apply plugin: <span class="string">'pluginA'</span></div><div class="line">apply plugin: <span class="string">'pluginB'</span></div></pre></td></tr></table></figure>
<p>那么对应的 TransformA 任务就会先于 TransfromB 任务执行。</p>
<p>好了，知道了 Transform 的执行顺序问题，再来看下 Robust 插件的顺序问题。首先来看下基线包的处理插件 <code>apply plugin: &#39;robust&#39;</code>，其逻辑是在每个方法中前置插入补丁加载逻辑代码，用于拦截基线包中的原有逻辑，达到修复方法的目的。<br>如果 robust Plugin 是先于其他插件执行的，那么会出现 Robust 插入代码后，再执行其他插件的代码逻辑，这样会有问题吗？其实要具体问题具体分析，可能会有问题，也可能没有问题。举个例子，我们项目中使用了听云，而且是较老的版本(2.5.9)，其插件内部插入代码没有用到 Transform，而是用了另外一种技术，其会导致不管在哪里声明插件，其处理顺序都是最后执行，那么对于 Robust 基线包插件来说，当基线包插件插入完代码后，又会去执行听云插件的插入代码逻辑，所以可能会看到以下这种代码：</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/robust_tingyun.png" alt=""></p>
<p>实际上，我们最终想要的结果是这样的：</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/robust_tingyun_right.png" alt=""></p>
<p>然而，如果仔细观察这种错误的代码插入逻辑，实际上并没有对最终的热修复逻辑产生影响。是因为在生成补丁包过程中，他们的执行顺序也是这样的，即听云插件最后执行，这样的结果就是Robust 自动化补丁插件在生成插件后就强制停止了整个编译流程，听云插件根本就没有机会执行。所以最后补丁包中仅仅会包含剔除了Robust 基线包插件插入的代码以及听云插件插入的代码。可以理解为第一张图中把红框下面的代码通过热修复的方式移入了红框里面，然后return。</p>
<p>对于听云来说，2.8.x版本之后，插入代码的逻辑也由 Tranform 来执行，也就是说，对于听云来说，不管是怎么样的执行顺序，都不会与 Robust 发生兼容性问题。</p>
<p>所以还是要具体问题具体分析，这里仅仅提供一些排查问题的思路。</p>
<h1 id="与-Aspectj-冲突怎么办？"><a href="#与-Aspectj-冲突怎么办？" class="headerlink" title="与 Aspectj 冲突怎么办？"></a>与 Aspectj 冲突怎么办？</h1><p>我们项目中大量使用了 AOP 技术，涉及到的框架有 Aspectj、javassist、ASM。其中由于  javassist 和 ASM 完全是有自己控制的，所以不会有问题，而对于 Aspectj 来说就没这么简单了。</p>
<p>刚开始介入就碰到了这样一个问题 <code>Caused by: java.lang.ClassCastException: com.meituan.robust.patch.MainFragmentActivityPatch cannot be cast to com.zhangdan.app.activities.MainFragmentActivity</code>，是一个类型强转错误。</p>
<p>问题分析，由于 Aspectj 框架为开发者省略了很多逻辑，开发者只需要编写切面相关代码即可，所以需要梳理清楚 Aspectj 的原理：</p>
<p>首先贴下未混淆的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">MainFragmentActivity.class</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCreate_aroundBody2</span><span class="params">(MainFragmentActivity mainFragmentActivity, Bundle bundle, JoinPoint joinPoint)</span> </span>&#123;</div><div class="line">        onCreate_aroundBody1$advice(mainFragmentActivity, bundle, joinPoint, MainFragmentActivity$$Injector.aspectOf(), (ProceedingJoinPoint) joinPoint);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> onCreate_aroundBody1$advice(MainFragmentActivity mainFragmentActivity, Bundle bundle, JoinPoint joinPoint, MainFragmentActivity$$Injector mainFragmentActivity$$Injector, ProceedingJoinPoint proceedingJoinPoint) &#123;</div><div class="line">        <span class="keyword">if</span> (!PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;mainFragmentActivity, bundle, joinPoint, mainFragmentActivity$$Injector, proceedingJoinPoint&#125;, <span class="keyword">null</span>, changeQuickRedirect, <span class="keyword">true</span>, <span class="number">11888</span>, <span class="keyword">new</span> Class[]&#123;MainFragmentActivity.class, Bundle.class, JoinPoint.class, MainFragmentActivity$$Injector.class, ProceedingJoinPoint.class&#125;, Void.TYPE).isSupported) &#123;</div><div class="line">            MainFragmentActivity mainFragmentActivity2 = (MainFragmentActivity) proceedingJoinPoint.getTarget();</div><div class="line">            onCreate_aroundBody0(mainFragmentActivity, bundle, proceedingJoinPoint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;bundle&#125;, <span class="keyword">this</span>, changeQuickRedirect, <span class="keyword">false</span>, <span class="number">11849</span>, <span class="keyword">new</span> Class[]&#123;Bundle.class&#125;, Void.TYPE).isSupported) &#123;</div><div class="line">            JoinPoint makeJP = Factory.makeJP(ajc$tjp_0, <span class="keyword">this</span>, <span class="keyword">this</span>, bundle);</div><div class="line">            MainFragmentActivity$$Injector.aspectOf().onCreate(<span class="keyword">new</span> AjcClosure3(<span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>, bundle, makeJP&#125;).linkClosureAndJoinPoint(<span class="number">69648</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCreate_aroundBody0</span><span class="params">(MainFragmentActivity mainFragmentActivity, Bundle bundle, JoinPoint joinPoint)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;mainFragmentActivity, bundle, joinPoint&#125;, <span class="keyword">null</span>, changeQuickRedirect, <span class="keyword">true</span>, <span class="number">11887</span>, <span class="keyword">new</span> Class[]&#123;MainFragmentActivity.class, Bundle.class, JoinPoint.class&#125;, Void.TYPE).isSupported) &#123;</div><div class="line">            <span class="keyword">super</span>.onCreate(bundle);</div><div class="line">            JudgeEmulatorUtil.uploadEmulatorInfoIfNeed(mainFragmentActivity);</div><div class="line">            instance = mainFragmentActivity;</div><div class="line">            mainFragmentActivity.setContentView(R.layout.main_activity);</div><div class="line">            ButterKnife.bind((Activity) mainFragmentActivity);</div><div class="line">            mainFragmentActivity.initUserCenterManager();</div><div class="line">            mainFragmentActivity.mainPagerAdapter = <span class="keyword">new</span> MainPagerAdapter(mainFragmentActivity, mainFragmentActivity.getSupportFragmentManager());</div><div class="line">            mainFragmentActivity.userInfoPresenter = <span class="keyword">new</span> UserInfoPresenter();</div><div class="line">            mainFragmentActivity.refreshOldDataPresenter = <span class="keyword">new</span> RefreshOldDataPresenter();</div><div class="line">            mainFragmentActivity.tabRedPointPresenter = <span class="keyword">new</span> TabRedPointPresenter(mainFragmentActivity);</div><div class="line">            mainFragmentActivity.getMsgCenterRedPresenter = <span class="keyword">new</span> GetMsgCenterRedPresenter(mainFragmentActivity);</div><div class="line">            mainFragmentActivity.userInfoPresenter.setUserInfoView(mainFragmentActivity);</div><div class="line">            mainFragmentActivity.userInfoPresenter.startGetCurUserInfoDBUseCase();</div><div class="line">            INSTANCE_FLAG = <span class="number">1</span>;</div><div class="line">            BaiduLocation.getInstance(ZhangdanApplication.getInstance()).start();</div><div class="line">            mainFragmentActivity.initToolBar();</div><div class="line">            mainFragmentActivity.showImportBillDialog();</div><div class="line">            mainFragmentActivity.onLoginCreate(bundle);</div><div class="line">            mainFragmentActivity.getLoggerABConfig();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>对应的patch 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragmentActivityPatch</span> </span>&#123;</div><div class="line">    MainFragmentActivity originClass;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainFragmentActivityPatch</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.originClass = (MainFragmentActivity) obj;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        StaticPart staticPart = (StaticPart) EnhancedRobustUtils.getStaticFieldValue(<span class="string">"ajc$tjp_0"</span>, MainFragmentActivity.class);</div><div class="line">        Log.d(<span class="string">"robust"</span>, <span class="string">"get static  value is ajc$tjp_0     No:  1"</span>);</div><div class="line">        JoinPoint joinPoint = (JoinPoint) EnhancedRobustUtils.invokeReflectStaticMethod(<span class="string">"makeJP"</span>, Factory.class, getRealParameter(<span class="keyword">new</span> Object[]&#123;staticPart, <span class="keyword">this</span>, <span class="keyword">this</span>, savedInstanceState&#125;), <span class="keyword">new</span> Class[]&#123;StaticPart.class, Object.class, Object.class, Object.class&#125;);</div><div class="line">        Object obj = (Injector) EnhancedRobustUtils.invokeReflectStaticMethod(<span class="string">"aspectOf"</span>, Injector.class, getRealParameter(<span class="keyword">new</span> Object[<span class="number">0</span>]), <span class="keyword">null</span>);</div><div class="line">        Object[] objArr = <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>, savedInstanceState, joinPoint&#125;;</div><div class="line">        Log.d(<span class="string">"robust"</span>, <span class="string">"  inner Class new      No:  2"</span>);</div><div class="line">        Object obj2 = (AjcClosure3) EnhancedRobustUtils.invokeReflectConstruct(<span class="string">"com.zhangdan.app.activities.MainFragmentActivity$AjcClosure3"</span>, getRealParameter(<span class="keyword">new</span> Object[]&#123;objArr&#125;), <span class="keyword">new</span> Class[]&#123;Object[].class&#125;);</div><div class="line">        <span class="keyword">if</span> (obj2 == <span class="keyword">this</span>) &#123;</div><div class="line">            obj2 = ((MainFragmentActivityPatch) obj2).originClass;</div><div class="line">        &#125;</div><div class="line">        ProceedingJoinPoint proceedingJoinPoint = (ProceedingJoinPoint) EnhancedRobustUtils.invokeReflectMethod(<span class="string">"linkClosureAndJoinPoint"</span>, obj2, getRealParameter(<span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> Integer(<span class="number">69648</span>)&#125;), <span class="keyword">new</span> Class[]&#123;Integer.TYPE&#125;, AroundClosure.class);</div><div class="line">        Log.d(<span class="string">"robust"</span>, <span class="string">"invoke  method is       No:  3 linkClosureAndJoinPoint"</span>);</div><div class="line">        <span class="keyword">if</span> (obj == <span class="keyword">this</span>) &#123;</div><div class="line">            obj = ((MainFragmentActivityPatch) obj).originClass;</div><div class="line">        &#125;</div><div class="line">        EnhancedRobustUtils.invokeReflectMethod(<span class="string">"onCreate"</span>, obj, getRealParameter(<span class="keyword">new</span> Object[]&#123;proceedingJoinPoint&#125;), <span class="keyword">new</span> Class[]&#123;ProceedingJoinPoint.class&#125;, Injector.class);</div><div class="line">        Log.d(<span class="string">"robust"</span>, <span class="string">"invoke  method is       No:  4 onCreate"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们往下跟下 Aspectj 的调用流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">AjcClosure 类</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AroundClosure</span> </span>&#123;</div><div class="line">   ...</div><div class="line">    <span class="keyword">protected</span> Object[] state;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AroundClosure</span><span class="params">(Object[] state)</span> </span>&#123;</div><div class="line">    	<span class="keyword">this</span>.state = state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Object[] getState() &#123;</div><div class="line">      <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * This takes in the same arguments as are passed to the proceed</div><div class="line">	 * call in the around advice (with primitives coerced to Object types)</div><div class="line">	 */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">run</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ProceedingJoinPoint <span class="title">linkClosureAndJoinPoint</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">        <span class="comment">//TODO is this cast safe ?</span></div><div class="line">        ProceedingJoinPoint jp = (ProceedingJoinPoint)state[state.length-<span class="number">1</span>];</div><div class="line">        jp.set$AroundClosure(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">this</span>.bitflags = flags;</div><div class="line">        <span class="keyword">return</span> jp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AjcClosure 接收一个 Object 的对象数组，在基础包中，它的实现是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>, bundle, makeJP&#125;</div></pre></td></tr></table></figure>
<p>注意这个 <code>this</code>，代表的是MainFragmentActivity 对象。<br>相对应的看下patch包中的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object[] objArr = <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>, savedInstanceState, joinPoint&#125;;</div></pre></td></tr></table></figure>
<p>这里调用了下 <code>getRealParameter(new Object[]{objArr})</code> 进行了 this 转换，所以这里的this 也是MainFragmentActivity对象，这里是没问题的。<br>然后调用 <code>linkClosureAndJoinPoint</code> 方法得到 ProceedingJoinPoint 对象，当做参数传递给 MainFragmentActivity$$Injector.onCreate(ProceedingJoinPoint joinPoint)  方法，看下这个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">MainFragmentActivity$$Injector.class</div><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragmentActivity</span>$$<span class="title">Injector</span> </span>&#123;</div><div class="line">  <span class="meta">@Around</span>(<span class="string">"execution(* com.zhangdan.app.activities.MainFragmentActivity.onCreate(..))"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    MainFragmentActivity target = (MainFragmentActivity)joinPoint.getTarget();</div><div class="line">    ...</div><div class="line">    joinPoint.proceed();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>调用了 ProceedingJoinPoint.proceed 抽象方法，实现在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   JoinPointImpl.<span class="function">java</span></div><div class="line"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</div><div class="line">	<span class="comment">// when called from a before advice, but be a no-op</span></div><div class="line">		<span class="keyword">return</span> arc.run(arc.getState());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 <code>arc</code> 是 AroundClosure，<code>arc.getState()</code> 返回的是构造 AroundClosure 时传递过来的对象数组。<br>最后调用了抽象方法 <code>run(Object[] args)</code>，实现在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragmentActivity</span>$<span class="title">AjcClosure3</span> <span class="keyword">extends</span> <span class="title">AroundClosure</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ChangeQuickRedirect changeQuickRedirect;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> MainFragmentActivity$AjcClosure3(Object[] objArr) &#123;</div><div class="line">        <span class="keyword">super</span>(objArr);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">(Object[] objArr)</span> </span>&#123;</div><div class="line">        PatchProxyResult proxy = PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;objArr&#125;, <span class="keyword">this</span>, changeQuickRedirect, <span class="keyword">false</span>, <span class="number">11911</span>, <span class="keyword">new</span> Class[]&#123;Object[].class&#125;, Object.class);</div><div class="line">        <span class="keyword">if</span> (proxy.isSupported) &#123;</div><div class="line">            <span class="keyword">return</span> proxy.result;</div><div class="line">        &#125;</div><div class="line">        Object[] objArr2 = <span class="keyword">this</span>.state;</div><div class="line">        MainFragmentActivity.onCreate_aroundBody2((MainFragmentActivity) objArr2[<span class="number">0</span>], (Bundle) objArr2[<span class="number">1</span>], (JoinPoint) objArr2[<span class="number">2</span>]);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后调用 <code>MainFragmentActivity.onCreate_aroundBody2((MainFragmentActivity) objArr2[0], (Bundle) objArr2[1], (JoinPoint) objArr2[2]);</code>，整个 AOP 的流程就走通了。</p>
<p>最后总结下 Aspectj 的调用流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MainFragmentActivity.onCreate -&gt; </div><div class="line">MainFragmentActivity$$Injector.onCreate(ProceedingJoinPoint joinPoint) -&gt; </div><div class="line">ProceedingJoinPoint.proceed() -&gt; </div><div class="line">AroundClosure.run(Object[] args) -&gt;  </div><div class="line">MainFragmentActivity$AjcClosure3.run(Object[] objArr) -&gt; </div><div class="line">MainFragmentActivity.onCreate_aroundBody2((MainFragmentActivity) objArr2[<span class="number">0</span>], (Bundle) objArr2[<span class="number">1</span>], (JoinPoint) objArr2[<span class="number">2</span>]); -&gt; </div><div class="line">MainFragmentActivity.onCreate_aroundBody1$advice -&gt; </div><div class="line">MainFragmentActivity.onCreate_aroundBody0();</div></pre></td></tr></table></figure>
<p>最后的 <code>MainFragmentActivity.onCreate_aroundBody0();</code>方法实际上就是onCreate()的原始方法逻辑。</p>
<p>另外，对于修改后的代码，没有被打入补丁，也是可以解释的。<br>对于 auto-path-plugin，Transform 的顺序是 Aspectj -&gt; auto-patch.<br>那么，对于标记修改的 onCreate 方法来说，Aspectj 处理完后，onCreate 方法被替换成了代理，真正的方法实现被新生成的方法隐藏起来了。<br>而我们仅仅标记了旧的 onCreate 方法，其结果就是，Aspectj 的代理 onCreate 方法被 patch 了，而实际的方法虽然方法体内有我们的修复，但是由于没有标记 <code>@modify</code> 而被忽略。</p>
<p>因为是强转 crash，所以在 $$Injector 代码中插入一些 Log</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">MainFragmentActivity$$Injector.class</div><div class="line">    <span class="meta">@Around</span>(<span class="string">"execution(* com.zhangdan.app.activities.MainFragmentActivity.onCreate(..))"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;proceedingJoinPoint&#125;, <span class="keyword">this</span>, changeQuickRedirect, <span class="keyword">false</span>, <span class="number">11892</span>, <span class="keyword">new</span> Class[]&#123;ProceedingJoinPoint.class&#125;, Void.TYPE).isSupported) &#123;</div><div class="line">            MainFragmentActivity target = (MainFragmentActivity) proceedingJoinPoint.getTarget();</div><div class="line">            ...</div><div class="line">            Log.d(<span class="string">"robust-wll"</span>, <span class="string">"test for aspectj start "</span>);</div><div class="line">            ...</div><div class="line">            Log.d(<span class="string">"robust-wll"</span>, <span class="string">"getTarget : "</span> + proceedingJoinPoint.getTarget().getClass().getSimpleName());</div><div class="line">            Log.d(<span class="string">"robust-wll"</span>, <span class="string">"getThis : "</span> + proceedingJoinPoint.getThis().getClass().getSimpleName());</div><div class="line">            Log.d(<span class="string">"robust-wll"</span>, <span class="string">"getArgs[0] : "</span> + (proceedingJoinPoint.getArgs()[<span class="number">0</span>] != <span class="keyword">null</span> ? proceedingJoinPoint.getArgs()[<span class="number">0</span>].getClass().getSimpleName() : <span class="keyword">null</span>));</div><div class="line">            Field arcField = proceedingJoinPoint.getClass().getDeclaredField(<span class="string">"arc"</span>);</div><div class="line">            arcField.setAccessible(<span class="keyword">true</span>);</div><div class="line">            AroundClosure arc = (AroundClosure) arcField.get(proceedingJoinPoint);</div><div class="line">            <span class="keyword">if</span> (!(arc == <span class="keyword">null</span> || arc.getState() == <span class="keyword">null</span> || arc.getState().length &lt; <span class="number">3</span>)) &#123;</div><div class="line">                Object[] states = arc.getState();</div><div class="line">                Log.d(<span class="string">"robust-wll"</span>, <span class="string">"states[0] : "</span> + (states[<span class="number">0</span>] != <span class="keyword">null</span> ? states[<span class="number">0</span>].getClass().getSimpleName() : <span class="keyword">null</span>));</div><div class="line">                Log.d(<span class="string">"robust-wll"</span>, <span class="string">"states[1] : "</span> + (states[<span class="number">1</span>] != <span class="keyword">null</span> ? states[<span class="number">1</span>].getClass().getSimpleName() : <span class="keyword">null</span>));</div><div class="line">                Log.d(<span class="string">"robust-wll"</span>, <span class="string">"states[2] : "</span> + (states[<span class="number">2</span>] != <span class="keyword">null</span> ? states[<span class="number">2</span>].getClass().getSimpleName() : <span class="keyword">null</span>));</div><div class="line">            &#125;</div><div class="line">            Log.d(<span class="string">"robust-wll"</span>, <span class="string">"test for aspectj end "</span>);</div><div class="line">            proceedingJoinPoint.proceed();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在不加载补丁情况下的 log 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.184</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: test <span class="keyword">for</span> aspectj start </div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.184</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: getTarget : MainFragmentActivity</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.185</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: getThis : MainFragmentActivity</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.185</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: getArgs[<span class="number">0</span>] : <span class="keyword">null</span></div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.185</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: states[<span class="number">0</span>] : MainFragmentActivity</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.185</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: states[<span class="number">1</span>] : <span class="keyword">null</span></div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.186</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: states[<span class="number">2</span>] : JoinPointImpl</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.186</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: test <span class="keyword">for</span> aspectj end</div></pre></td></tr></table></figure>
<p>加载补丁后，log 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.885</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: test <span class="keyword">for</span> aspectj start </div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.885</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: getTarget : MainFragmentActivity</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.886</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: getThis : MainFragmentActivity</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.886</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: getArgs[<span class="number">0</span>] : <span class="keyword">null</span></div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.886</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: states[<span class="number">0</span>] : MainFragmentActivityPatch</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.886</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: states[<span class="number">1</span>] : <span class="keyword">null</span></div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.886</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: states[<span class="number">2</span>] : JoinPointImpl</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.886</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: test <span class="keyword">for</span> aspectj end</div></pre></td></tr></table></figure>
<p><strong>states[0] : MainFragmentActivityPatch</strong> 这个明显是不对的，所以我们知道了原因，是因为在构造 <code>AroundClosure</code> 时候传进来的参数不对。<br>报错地方对应于上面的分析，也就是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object[] objArr = <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>, savedInstanceState, joinPoint&#125;;</div><div class="line">Object obj2 = (AjcClosure3) EnhancedRobustUtils.invokeReflectConstruct(<span class="string">"com.zhangdan.app.activities.MainFragmentActivity$AjcClosure3"</span>, getRealParameter(<span class="keyword">new</span> Object[]&#123;objArr&#125;), <span class="keyword">new</span> Class[]&#123;Object[].class&#125;);</div></pre></td></tr></table></figure></p>
<p>结果就是，把一个含有3个对象的一维数据，编程了含有一个对象的二维数组，然后去 getRealParameter。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Object[] getRealParameter(Object[] objArr) &#123;</div><div class="line">    <span class="keyword">if</span> (objArr == <span class="keyword">null</span> || objArr.length &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> objArr;</div><div class="line">    &#125;</div><div class="line">    Object[] objArr2 = <span class="keyword">new</span> Object[objArr.length];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objArr.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (objArr[i] == <span class="keyword">this</span>) &#123;</div><div class="line">            objArr2[i] = <span class="keyword">this</span>.originClass;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            objArr2[i] = objArr[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> objArr2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而这个方法只判断了一维数组的情况，没有判断二维或多维数组的情况。终于找到原因了 😃<br>对应的修改方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Object[] getRealParameter(Object[] objArr) &#123;</div><div class="line">    <span class="keyword">if</span> (objArr == <span class="keyword">null</span> || objArr.length &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> objArr;</div><div class="line">    &#125;</div><div class="line">    Object[] objArr2 = <span class="keyword">new</span> Object[objArr.length];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objArr.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (objArr[i] <span class="keyword">instanceof</span> Object[]) &#123;</div><div class="line">            objArr2[i] = getRealParameter(((Object[]) objArr[i]));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (objArr[i] == <span class="keyword">this</span>) &#123;</div><div class="line">                objArr2[i] = <span class="keyword">this</span>.originClass;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                objArr2[i] = objArr[i];</div><div class="line">            &#125;</div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> objArr2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>castException 终于是搞定了。具体解决方法见 <a href="https://github.com/Meituan-Dianping/Robust/pull/259" target="_blank" rel="external">merge request #259</a>。</p>
<h1 id="static-方法中包含-super-方法怎么办？"><a href="#static-方法中包含-super-方法怎么办？" class="headerlink" title="static 方法中包含 super 方法怎么办？"></a>static 方法中包含 super 方法怎么办？</h1><p>看到这个标题可能会一脸懵逼，static 方法中怎么可能包含 super 调用？别急慢慢往下看。</p>
<p>书接上节，至于被 Aspectj  处理过的方法无法被打入 patch 的问题，理论上来说跟泛型的桥方法是类似的，解决方案也是 <code>@Modify -&gt; RobustModify.modify();</code>，修改后经验证，会报错。log如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">Caused by: javassist.CannotCompileException: [source error] not-available: <span class="keyword">this</span></div><div class="line">        at javassist.expr.MethodCall.replace(MethodCall.java:<span class="number">241</span>)</div><div class="line">        at javassist.expr.MethodCall$replace$<span class="number">2</span>.call(Unknown Source)</div><div class="line">        at com.meituan.robust.autopatch.PatchesFactory$<span class="number">1</span>.edit(PatchesFactory.groovy:<span class="number">144</span>)</div><div class="line">        at javassist.expr.ExprEditor.loopBody(ExprEditor.java:<span class="number">224</span>)</div><div class="line">        at javassist.expr.ExprEditor.doit(ExprEditor.java:<span class="number">91</span>)</div><div class="line">        at javassist.CtBehavior.instrument(CtBehavior.java:<span class="number">712</span>)</div><div class="line">        at javassist.CtBehavior$instrument$<span class="number">1</span>.call(Unknown Source)</div><div class="line">        at com.meituan.robust.autopatch.PatchesFactory.createPatchClass(PatchesFactory.groovy:<span class="number">76</span>)</div><div class="line">        at com.meituan.robust.autopatch.PatchesFactory.createPatch(PatchesFactory.groovy:<span class="number">310</span>)</div><div class="line">        at com.meituan.robust.autopatch.PatchesFactory$createPatch.call(Unknown Source)</div><div class="line">        at robust.gradle.plugin.AutoPatchTransform.generatPatch(AutoPatchTransform.groovy:<span class="number">190</span>)</div><div class="line">        at robust.gradle.plugin.AutoPatchTransform$generatPatch$<span class="number">0</span>.callCurrent(Unknown Source)</div><div class="line">        at robust.gradle.plugin.AutoPatchTransform.autoPatch(AutoPatchTransform.groovy:<span class="number">138</span>)</div><div class="line">        at robust.gradle.plugin.AutoPatchTransform$autoPatch.callCurrent(Unknown Source)</div><div class="line">        at robust.gradle.plugin.AutoPatchTransform.transform(AutoPatchTransform.groovy:<span class="number">97</span>)</div><div class="line">        at com.android.build.api.transform.Transform.transform(Transform.java:<span class="number">290</span>)</div><div class="line">        at com.android.build.gradle.internal.pipeline.TransformTask$<span class="number">2</span>.call(TransformTask.java:<span class="number">185</span>)</div><div class="line">        at com.android.build.gradle.internal.pipeline.TransformTask$<span class="number">2</span>.call(TransformTask.java:<span class="number">181</span>)</div><div class="line">        at com.android.builder.profile.ThreadRecorder.record(ThreadRecorder.java:<span class="number">102</span>)</div><div class="line">        ... <span class="number">27</span> more</div><div class="line">Caused by: compile error: not-available: <span class="keyword">this</span></div><div class="line">        at javassist.compiler.CodeGen.atKeyword(CodeGen.java:<span class="number">1908</span>)</div><div class="line">        at javassist.compiler.ast.Keyword.accept(Keyword.java:<span class="number">35</span>)</div><div class="line">        at javassist.compiler.JvstCodeGen.atMethodArgs(JvstCodeGen.java:<span class="number">358</span>)</div><div class="line">        at javassist.compiler.MemberCodeGen.atMethodCallCore(MemberCodeGen.java:<span class="number">569</span>)</div><div class="line">        at javassist.compiler.MemberCodeGen.atCallExpr(MemberCodeGen.java:<span class="number">537</span>)</div><div class="line">        at javassist.compiler.JvstCodeGen.atCallExpr(JvstCodeGen.java:<span class="number">244</span>)</div><div class="line">        at javassist.compiler.ast.CallExpr.accept(CallExpr.java:<span class="number">46</span>)</div><div class="line">        at javassist.compiler.CodeGen.atStmnt(CodeGen.java:<span class="number">338</span>)</div><div class="line">        at javassist.compiler.ast.Stmnt.accept(Stmnt.java:<span class="number">50</span>)</div><div class="line">        at javassist.compiler.CodeGen.atStmnt(CodeGen.java:<span class="number">351</span>)</div><div class="line">        at javassist.compiler.ast.Stmnt.accept(Stmnt.java:<span class="number">50</span>)</div><div class="line">        at javassist.compiler.Javac.compileStmnt(Javac.java:<span class="number">569</span>)</div><div class="line">        at javassist.expr.MethodCall.replace(MethodCall.java:<span class="number">235</span>)</div><div class="line">        ... <span class="number">45</span> more</div></pre></td></tr></table></figure></p>
<p>问题分析，根据堆栈显示，这里是在做替换 super 方法的逻辑，跟了下 plugin 的 debug，生成需要 replace 的 javassist 代码为 <code>{staticRobustonCreate(this,originClass,$$);}</code>，然后在 replace 后，javac 编译这条语句的时候跪了。<br>分析下需要替换的 super 的方法，这个方法实际上是 Aspectj 处理后的方法，根据上面分析的 Aspectj 的调用流程得知，该方法实际上是 onCreate 方法原始的逻辑，反编译出来如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCreate_aroundBody0</span><span class="params">(MainFragmentActivity mainFragmentActivity, Bundle bundle, JoinPoint joinPoint)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;mainFragmentActivity, bundle, joinPoint&#125;, <span class="keyword">null</span>, changeQuickRedirect, <span class="keyword">true</span>, <span class="number">11887</span>, <span class="keyword">new</span> Class[]&#123;MainFragmentActivity.class, Bundle.class, JoinPoint.class&#125;, Void.TYPE).isSupported) &#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(bundle);<span class="comment">//这里是需要替换的地方</span></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而 auto-patch 做的工作是将<code>super.onCreate</code>方法包装成 static 方法，正常生成的patch代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivityPatch</span> </span>&#123;</div><div class="line">    SecondActivity originClass;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecondActivityPatch</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.originClass = (SecondActivity) obj;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</div><div class="line">        staticRobustonCreate(<span class="keyword">this</span>,originClass,bundle);</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticRobustonCreate</span><span class="params">(SecondActivityPatch secondActivityPatch, SecondActivity secondActivity, Bundle bundle)</span> </span>&#123;</div><div class="line">        SecondActivityPatchRobustAssist.staticRobustonCreate(secondActivityPatch, secondActivity, bundle);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivityPatchRobustAssist</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticRobustonCreate</span><span class="params">(SecondActivityPatch secondActivityPatch, SecondActivity secondActivity, Bundle bundle)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(bundle);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而对于已经被 Aspectj 处理过的方法，是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCreate_aroundBody0</span><span class="params">(MainFragmentActivity mainFragmentActivity, Bundle bundle, JoinPoint joinPoint)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;mainFragmentActivity, bundle, joinPoint&#125;, <span class="keyword">null</span>, changeQuickRedirect, <span class="keyword">true</span>, <span class="number">11887</span>, <span class="keyword">new</span> Class[]&#123;MainFragmentActivity.class, Bundle.class, JoinPoint.class&#125;, Void.TYPE).isSupported) &#123;</div><div class="line">        <span class="comment">//super.onCreate(bundle);//这里是需要替换的地方</span></div><div class="line">        staticRobustonCreate(<span class="keyword">this</span>,originClass,bundle);</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在static 方法中使用了 <code>this</code>关键字，当然编译出错啦。同理这个 <code>originClass</code> 也不可以出现，因为它是非 static 变量。<br>由于 xxPatchRobustAssist.staticRobustonCreate() 方法并没有用到前两个变量(patch, activity)，直接传 null 行不行呢？经验证是不行的，原因如下。<br>看了下生成xxxPatchRobustAssist类的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PatchesAssistFactory</span> </span>&#123;</div><div class="line">    <span class="function">def</span></div><div class="line">    <span class="keyword">static</span> <span class="title">createAssistClass</span><span class="params">(CtClass modifiedClass, String patchClassName, CtMethod removeMethod)</span> &#123;</div><div class="line">       ....</div><div class="line">        StringBuilder staticMethodBuidler = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">if</span> (removeMethod.parameterTypes.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            staticMethodBuidler.append(<span class="string">"public static  "</span> + removeMethod.returnType.name + <span class="string">"   "</span> + ReflectUtils.getStaticSuperMethodName(removeMethod.getName())</div><div class="line">                    + <span class="string">"("</span> + patchClassName + <span class="string">" patchInstance,"</span> + modifiedClass.getName() + <span class="string">" modifiedInstance,"</span> + JavaUtils.getParameterSignure(removeMethod) + <span class="string">")&#123;"</span>);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            staticMethodBuidler.append(<span class="string">"public static  "</span> + removeMethod.returnType.name + <span class="string">"   "</span> + ReflectUtils.getStaticSuperMethodName(removeMethod.getName())</div><div class="line">                    + <span class="string">"("</span> + patchClassName + <span class="string">" patchInstance,"</span> + modifiedClass.getName() + <span class="string">" modifiedInstance)&#123;"</span>);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        staticMethodBuidler.append(<span class="string">" return patchInstance."</span> + removeMethod.getName() + <span class="string">"("</span> + JavaUtils.getParameterValue(removeMethod.getParameterTypes().length) + <span class="string">");"</span>);</div><div class="line">        staticMethodBuidler.append(<span class="string">"&#125;"</span>);</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> assistClass;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上，最终生成的调用是 <code>xxPatch.superMethod($$);</code> ，$$代表全部参数。对于与上面的 onCreate 方法就是 <code>xxPatch.onCreate(bundle);</code>。<br>所以，patch 应该不能传 null 了，否则运行时会报空指针，那第二个参数 activity  能不能传 null 呢？继续往下看。<br>首先，根据常识，static 方法中肯定是不能调用 super方法的。从最终生成的代码也能看出，这并不是最终反编译出的的 <code>super.onCreate(bundle)</code>方法调用。所以处理的地方肯定在javassist修改编译之后，对应处理的地方在smali 层，代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">SmaliTool.<span class="function">java</span></div><div class="line">    <span class="keyword">private</span> String <span class="title">invokeSuperMethodInSmali</span><span class="params">(<span class="keyword">final</span> String line, String fullClassName)</span> &#123;</div><div class="line">                    ...</div><div class="line">                    result = line.replace(Constants.SMALI_INVOKE_VIRTUAL_COMMAND, Constants.SMALI_INVOKE_SUPER_COMMAND);</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (!ctMethod.getReturnType().isPrimitive()) &#123;</div><div class="line">                            returnType = <span class="string">"L"</span> + ctMethod.getReturnType().getName().replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>);</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            returnType = String.valueOf(((CtPrimitiveType) ctMethod.getReturnType()).getDescriptor());</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (NameManger.getInstance().getPatchNameMap().get(fullClassName).equals(fullClassName)) &#123;</div><div class="line">                            result = result.replace(<span class="string">"p0"</span>, <span class="string">"p1"</span>);</div><div class="line">                        &#125;</div><div class="line">                       ...</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">                    &#125;</div><div class="line">                ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>实际上就是把方法调用从 <code>invoke-invoke-virtual {p0, p2}, Lcom/meituan/robust/patch/SecondActivityPatch;-&gt;onCreate(Landroid/os/Bundle;)</code>V 转换成 <code>invoke-super {p1, p2}, Landroid/support/v7/app/AppCompatActivity;-&gt;onCreate(Landroid/os/Bundle;)V</code>，这步处理完才会真正的调用父类的super方法。<br>也就是说，在 smali 处理完后，参数从 p0 -&gt; p1，也就是参数从 xxpatch 换成了 Activity，第二个参数会在运行时用到，所以也不能传null。<br>分析完了总结下，第二个参数 originClass 肯定不能传 null，否则会空指针；第一个参数  xxPatch，由于在 smali 被替换成了第二个参数，所以有可能是可以传 null 的。</p>
<p>解决方案：</p>
<ol>
<li>修改 originClass 为static，并新增一个 static patch 变量</li>
<li>由于目前已经是在 static 方法中存在 super 方法，对应的 smali 代码：</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.<span class="function">method <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="title">onCreate_aroundBody0</span><span class="params">(Lcom/zhangdan/app/activities/MainFragmentActivity;Landroid/os/Bundle;Lorg/aspectj/lang/JoinPoint;)</span>V</span></div><div class="line"> ...</div><div class="line">invoke-<span class="keyword">super</span> &#123;p0, p1&#125;, Lcom/zhangdan/app/activities/WrapperAppCompatFragmentActivity;-&gt;onCreate(Landroid/os/Bundle;)V</div></pre></td></tr></table></figure>
</li>
</ol>
<p>所以只要不处理就好了，需要做的就是在 auto-plugin 中增加条件判断，符合 static 方法中带有 super 的不处理，一共有三处，一处是生成 xxPatchRobustAssist 辅助类，第二处在 javassit 替换 super 方法，第三处在 smali 处理补丁中的 super 方法。</p>
<p>对于方案1，问题：<br>如果 patch 和 originClass 都是 static，那么就会有内存泄露的风险。<br>并且如果被 patch 方法是 static 方法，那么在初始化 patch 时，originClass 会传 null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">accessDispatch</span><span class="params">(String methodName, Object[] paramArrayOfObject)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Log.d(<span class="string">"robust"</span>, <span class="keyword">new</span> StringBuffer().append(<span class="string">"arrivied in AccessDispatch "</span>).append(methodName).append(<span class="string">" paramArrayOfObject  "</span>).append(paramArrayOfObject).toString());</div><div class="line">        MainFragmentActivityPatch mainFragmentActivityPatch;</div><div class="line">        <span class="keyword">if</span> (!methodName.split(<span class="string">":"</span>)[<span class="number">2</span>].equals(<span class="string">"false"</span>)) &#123;</div><div class="line">            Log.d(<span class="string">"robust"</span>, <span class="string">"static method forward "</span>);</div><div class="line">            mainFragmentActivityPatch = <span class="keyword">new</span> MainFragmentActivityPatch(<span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<p>同样应该也是为了避免内存泄露，每修复一个方法就会生成一个 patch 对象并持有 static 的 originClass 引用。<br>对于方案2 ，问题：<br>首先，Aspectj 在 static 方法中插了个 super 方法（猜测也是在 smali 层做的修改），直接写的话 javac 编译时会报错，smali 处理吧还没到这一步。所以被修复后，这个 static 方法是在 xxPatch 类中的，auto-patch 即使不处理，运行时也不能正常运行，因为 xxPatch 不是 originClass 父类的子类，不能直接其调用 super 方法。</p>
<p>观察 Aspectj 生成的方法，所有 的static 方法，第一个参数都是当前类的引用，比如 <code>private static final void onCreate_aroundBody0(MainFragmentActivity mainFragmentActivity, Bundle bundle, JoinPoint joinPoint) {</code>。<br>所以比如根据上面的分析，得出一个可行的方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">def <span class="keyword">static</span> String <span class="title">invokeSuperString</span><span class="params">(MethodCall m, String originClass)</span> </span>&#123;</div><div class="line">       ...</div><div class="line">       stringBuilder.append(getStaticSuperMethodName(m.methodName) + <span class="string">"("</span> + <span class="keyword">null</span> + <span class="string">","</span> + originClass + <span class="string">",\$\$);"</span>);</div><div class="line">       ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是 static 方法中含有 super 方法，就如下处理。<br>第一个 xxPatch 对象传空，最后在 smali 处理的时候会被替换掉。<br>第二个参数是从类似<code>onCreate_aroundBody0()</code>中传过来的，后面的是其他参数。<br>最终结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticRobustonCreate</span><span class="params">(MainFragmentActivityPatch mainFragmentActivityPatch, MainFragmentActivity mainFragmentActivity, Bundle bundle)</span> </span>&#123;</div><div class="line">    MainFragmentActivityPatchRobustAssist.staticRobustonCreate(mainFragmentActivityPatch, mainFragmentActivity, bundle);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCreate_aroundBody0</span><span class="params">(MainFragmentActivity ajc$<span class="keyword">this</span>, Bundle savedInstanceState, JoinPoint joinPoint)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    staticRobustonCreate(<span class="keyword">null</span>, ajc$<span class="keyword">this</span>, savedInstanceState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里这个问题就分析完了，详细解决方发见 <a href="https://github.com/Meituan-Dianping/Robust/pull/265" target="_blank" rel="external">merge request #265</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个系列到这里基本就结束了。这篇文章主要介绍了在接入 Robust 过程中碰到的一些坑以及解决思路，其实根本还是熟读源码，碰到问题学习从源码中找答案。要坚信，坑踩的多了，也就不怕坑了。最后福利一张。</p>
<p><img src="http://wx3.sinaimg.cn/large/0078WU5Lgy1fsgrhhx37tj30o31040zf.jpg" alt=""></p>
<p>本文链接： <a href="http://w4lle.com/2018/06/20/robust-2/">http://w4lle.com/2018/06/20/robust-2/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前两篇文章中，分析了 Android 热补丁框架 Robust 中，几个重要的流程包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;补丁加载过程&lt;/li&gt;
&lt;li&gt;基础包插桩过程&lt;/li&gt;
&lt;li&gt;补丁包自动化生成过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇文章主要分析下集成过程中遇到的坑以及分析问题的思路和最终的解决方案。包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打补丁包出错？&lt;/li&gt;
&lt;li&gt;Robust 定义的 API 不够用怎么办？&lt;/li&gt;
&lt;li&gt;插件 Plugin Transform 的顺序问题？&lt;/li&gt;
&lt;li&gt;与 Aspectj 冲突怎么办？&lt;/li&gt;
&lt;li&gt;static 方法中包含 super 方法怎么办？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
      <category term="热补丁" scheme="http://w4lle.com/tags/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>Android热补丁之Robust（二）自动化补丁原理解析</title>
    <link href="http://w4lle.com/2018/05/28/robust-1/"/>
    <id>http://w4lle.com/2018/05/28/robust-1/</id>
    <published>2018-05-28T11:47:06.000Z</published>
    <updated>2018-05-29T08:40:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android 热补丁框架 Robust 中，几个重要的流程包括：</p>
<ul>
<li>补丁加载过程</li>
<li>基础包插桩过程</li>
<li>补丁包生成过程</li>
</ul>
<p>在上一篇文章<a href="http://w4lle.com/2017/03/31/robust-0/">Android热补丁之Robust原理解析(一)</a>中，我们分析了前两个，补丁加载过程和基础包插桩过程，分析的版本为 <code>0.3.2</code>。<br>该篇文章为该系列的第二篇文章，主要分析补丁自动化生成的过程，分析的版本为<code>0.4.82</code>。<br><a id="more"></a><br>时间跨度有点大…</p>
<p>系列文章:</p>
<ul>
<li><a href="http://w4lle.com/2017/03/31/robust-0/">Android热补丁之Robust原理解析(一)</a></li>
<li><a href="http://w4lle.com/2018/05/28/robust-1/">Android热补丁之Robust（二）自动化补丁原理解析</a></li>
<li><a href="http://w4lle.com/2018/05/29/robust-2/">Android热补丁之Robust（三）坑和解</a></li>
</ul>
<h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p>首先在 Gradle 插件中注册了一个名为 AutoPatchTranform 的 Tranform </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPatchTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project target)</span> </span>&#123;</div><div class="line">    initConfig();</div><div class="line">    project.android.registerTransform(<span class="keyword">this</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">def <span class="title">initConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">    NameManger.init();</div><div class="line">    InlineClassFactory.init();</div><div class="line">    ReadMapping.init();</div><div class="line">    Config.init();</div><div class="line">    ...</div><div class="line">    ReadXML.readXMl(project.projectDir.path);</div><div class="line">    Config.methodMap = JavaUtils.getMapFromZippedFile(project.projectDir.path + Constants.METHOD_MAP_PATH)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该类为插件的入口，实现了 GradlePlugin 并继承自 Transform，在入口处初始化配置并注册 Transform。配置主要是读取 Robust xml 配置、混淆优化后的 mapping 文件、插庄过程中生成的 methodsMap.robust 文件、初始化内联工厂类等等。<br>然后最主要的是<code>transform</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(Context context, Collection&lt;TransformInput&gt; inputs, Collection&lt;TransformInput&gt; referencedInputs, TransformOutputProvider outputProvider, <span class="keyword">boolean</span> isIncremental)</span> <span class="keyword">throws</span> IOException, TransformException, InterruptedException </span>&#123;</div><div class="line">    project.android.bootClasspath.each &#123;</div><div class="line">        Config.classPool.appendClassPath((String) it.absolutePath)</div><div class="line">    &#125;</div><div class="line">    def box = ReflectUtils.toCtClasses(inputs, Config.classPool)</div><div class="line">    ...</div><div class="line">    autoPatch(box)</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">def <span class="title">autoPatch</span><span class="params">(List&lt;CtClass&gt; box)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    ReadAnnotation.readAnnotation(box, logger);</div><div class="line">    <span class="keyword">if</span>(Config.supportProGuard) &#123;</div><div class="line">        ReadMapping.getInstance().initMappingInfo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    generatPatch(box,patchPath);</div><div class="line"></div><div class="line">    zipPatchClassesFile()</div><div class="line">    executeCommand(jar2DexCommand)</div><div class="line">    executeCommand(dex2SmaliCommand)</div><div class="line">    SmaliTool.getInstance().dealObscureInSmali();</div><div class="line">    executeCommand(smali2DexCommand)</div><div class="line">    <span class="comment">//package patch.dex to patch.jar</span></div><div class="line">    packagePatchDex2Jar()</div><div class="line">    deleteTmpFiles()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>transform</code> 方法中，使用 javassist API 把所有需要处理的类加载到待扫描队列中，然后调用<code>autoPatch</code>方法自动生成补丁。<br>在 <code>autoPatch</code>方法中，主要做了这么几件事情：</p>
<ol>
<li>读取被 @Add、@Modify、RobustModify.modify() 标注的方法或类并记录</li>
<li>解析 mapping 文件并记录每个类和类中方法混淆前后对应的信息，其中方法存储的信息有：返回值，方法名，参数列表，混淆后的名字；字段存储的信息有：字段名，混淆后的名字</li>
<li>根据得到的信息，<code>generatPatch</code> 方法实际生成补丁</li>
<li>将生成的补丁class打包成jar包</li>
<li>jar -&gt; dex</li>
<li>dex -&gt; smali</li>
<li>处理 smali，主要是处理 super 方法和处理混淆关系</li>
<li>smali -&gt; dex</li>
<li>dex -&gt; jar</li>
</ol>
<p>1、2 比较好懂就不逐步分析了，主要看3；后面的5、6、7、8、9 都是为了 7 中处理 smali，所以只要搞懂smali处理就好了。下面我们分步来看。</p>
<h1 id="生成补丁"><a href="#生成补丁" class="headerlink" title="生成补丁"></a>生成补丁</h1><p>主要逻辑在 <code>generatPatch</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function">def  <span class="title">generatPatch</span><span class="params">(List&lt;CtClass&gt; box,String patchPath)</span></span>&#123;</div><div class="line">...</div><div class="line">    InlineClassFactory.dealInLineClass(patchPath, Config.newlyAddedClassNameList)</div><div class="line">    initSuperMethodInClass(Config.modifiedClassNameList);</div><div class="line">    <span class="comment">//auto generate all class</span></div><div class="line">    <span class="keyword">for</span> (String fullClassName : Config.modifiedClassNameList) &#123;</div><div class="line">        CtClass ctClass = Config.classPool.get(fullClassName)</div><div class="line">        CtClass patchClass = PatchesFactory.createPatch(patchPath, ctClass, <span class="keyword">false</span>, NameManger.getInstance().getPatchName(ctClass.name), Config.patchMethodSignatureSet)</div><div class="line">        patchClass.writeFile(patchPath)</div><div class="line">        patchClass.defrost();</div><div class="line">        createControlClass(patchPath, ctClass)</div><div class="line">    &#125;</div><div class="line">    createPatchesInfoClass(patchPath);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分为两个部分</p>
<h2 id="逐步翻译"><a href="#逐步翻译" class="headerlink" title="逐步翻译"></a>逐步翻译</h2><p>首先调用<code>InlineClassFactory.dealInLineClass(patchPath, Config.newlyAddedClassNameList)</code>识别被优化过的方法，这里的优化是泛指，包括被优化、内联、新增过的类和方法，具体的逻辑为扫描修改后的所有类和类中的方法，如果这些类和方法不在 mapping 文件中存在，那么可以定义为被优化过，其中包括<code>@Add</code>新增的类或方法。<br>然后调用<code>initSuperMethodInClass</code>方法识别修改后的所有类和类中的方法中，分析是否如包含 <code>super</code> 方法，如果有那么缓存下来。<br>然后调用 <code>PatchesFactory.createPatch</code> 反射翻译修改的类和方法，具体的实现在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> CtClass <span class="title">createPatchClass</span><span class="params">(CtClass modifiedClass, <span class="keyword">boolean</span> isInline, String patchName, Set patchMethodSignureSet, String patchPath)</span> <span class="keyword">throws</span> CannotCompileException, IOException, NotFoundException </span>&#123;</div><div class="line">    <span class="comment">//清洗需要处理的方法，略..</span></div><div class="line"></div><div class="line">    CtClass temPatchClass = cloneClass(modifiedClass, patchName, methodNoNeedPatchList);</div><div class="line">    </div><div class="line">    JavaUtils.addPatchConstruct(temPatchClass, modifiedClass);</div><div class="line">    CtMethod reaLParameterMethod = CtMethod.make(JavaUtils.getRealParamtersBody(), temPatchClass);</div><div class="line">    temPatchClass.addMethod(reaLParameterMethod);</div><div class="line"></div><div class="line">    dealWithSuperMethod(temPatchClass, modifiedClass, patchPath);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (CtMethod method : temPatchClass.getDeclaredMethods()) &#123;</div><div class="line">        <span class="comment">//  shit !!too many situations need take into  consideration</span></div><div class="line">        <span class="comment">//   methods has methodid   and in  patchMethodSignatureSet</span></div><div class="line">        <span class="keyword">if</span> (!Config.addedSuperMethodList.contains(method) &amp;&amp; reaLParameterMethod != method &amp;&amp; !method.getName().startsWith(Constants.ROBUST_PUBLIC_SUFFIX)) &#123;</div><div class="line">            method.instrument(</div><div class="line">                    <span class="keyword">new</span> ExprEditor() &#123;</div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">edit</span><span class="params">(FieldAccess f)</span> <span class="keyword">throws</span> CannotCompileException </span>&#123;</div><div class="line">                            ...</div><div class="line">                                <span class="keyword">if</span> (f.isReader()) &#123; f.replace(ReflectUtils.getFieldString(f.getField(), memberMappingInfo, temPatchClass.getName(), modifiedClass.getName()));</div><div class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.isWriter()) &#123;</div><div class="line">                                    f.replace(ReflectUtils.setFieldString(f.getField(), memberMappingInfo, temPatchClass.getName(), modifiedClass.getName()));</div><div class="line">                                &#125;</div><div class="line">                            ...</div><div class="line">                        &#125;</div><div class="line"></div><div class="line"></div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(NewExpr e)</span> <span class="keyword">throws</span> CannotCompileException </span>&#123;</div><div class="line">                            <span class="comment">//inner class in the patched class ,not all inner class</span></div><div class="line">                            ...</div><div class="line">                                <span class="keyword">if</span> (!ReflectUtils.isStatic(Config.classPool.get(e.getClassName()).getModifiers()) &amp;&amp; JavaUtils.isInnerClassInModifiedClass(e.getClassName(), modifiedClass)) &#123;</div><div class="line">                                    e.replace(ReflectUtils.getNewInnerClassString(e.getSignature(), temPatchClass.getName(), ReflectUtils.isStatic(Config.classPool.get(e.getClassName()).getModifiers()), getClassValue(e.getClassName())));</div><div class="line">                                    <span class="keyword">return</span>;</div><div class="line">                                &#125;</div><div class="line">                            ...</div><div class="line"></div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(Cast c)</span> <span class="keyword">throws</span> CannotCompileException </span>&#123;</div><div class="line">                            MethodInfo thisMethod = ReflectUtils.readField(c, <span class="string">"thisMethod"</span>);</div><div class="line">                            CtClass thisClass = ReflectUtils.readField(c, <span class="string">"thisClass"</span>);</div><div class="line"></div><div class="line">                            def isStatic = ReflectUtils.isStatic(thisMethod.getAccessFlags());</div><div class="line">                            <span class="keyword">if</span> (!isStatic) &#123;</div><div class="line">                                <span class="comment">//inner class in the patched class ,not all inner class</span></div><div class="line">                                <span class="keyword">if</span> (Config.newlyAddedClassNameList.contains(thisClass.getName()) || Config.noNeedReflectClassSet.contains(thisClass.getName())) &#123;</div><div class="line">                                    <span class="keyword">return</span>;</div><div class="line">                                &#125;</div><div class="line">                                <span class="comment">// static函数是没有this指令的，直接会报错。</span></div><div class="line">                                c.replace(ReflectUtils.getCastString(c, temPatchClass))</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(MethodCall m)</span> <span class="keyword">throws</span> CannotCompileException </span>&#123;</div><div class="line">                            ...</div><div class="line">                                <span class="keyword">if</span> (!repalceInlineMethod(m, method, <span class="keyword">false</span>)) &#123;</div><div class="line">                                    Map memberMappingInfo = getClassMappingInfo(m.getMethod().getDeclaringClass().getName());</div><div class="line">                                    <span class="keyword">if</span> (invokeSuperMethodList.contains(m.getMethod())) &#123;</div><div class="line">                                        <span class="keyword">int</span> index = invokeSuperMethodList.indexOf(m.getMethod());</div><div class="line">                                        CtMethod superMethod = invokeSuperMethodList.get(index);</div><div class="line">                                        <span class="keyword">if</span> (superMethod.getLongName() != <span class="keyword">null</span> &amp;&amp; superMethod.getLongName() == m.getMethod().getLongName()) &#123;</div><div class="line">                                            String firstVariable = <span class="string">""</span>;</div><div class="line">                                            <span class="keyword">if</span> (ReflectUtils.isStatic(method.getModifiers())) &#123;</div><div class="line">                                                <span class="comment">//修复static 方法中含有super的问题，比如Aspectj处理后的方法</span></div><div class="line">                                                MethodInfo methodInfo = method.getMethodInfo();</div><div class="line">                                                LocalVariableAttribute table = methodInfo.getCodeAttribute().getAttribute(LocalVariableAttribute.tag);</div><div class="line">                                                <span class="keyword">int</span> numberOfLocalVariables = table.tableLength();</div><div class="line">                                                <span class="keyword">if</span> (numberOfLocalVariables &gt; <span class="number">0</span>) &#123;</div><div class="line">                                                    <span class="keyword">int</span> frameWithNameAtConstantPool = table.nameIndex(<span class="number">0</span>);</div><div class="line">                                                    firstVariable = methodInfo.getConstPool().getUtf8Info(frameWithNameAtConstantPool)</div><div class="line">                                                &#125;</div><div class="line">                                            &#125;</div><div class="line">                                            m.replace(ReflectUtils.invokeSuperString(m, firstVariable));</div><div class="line">                                            <span class="keyword">return</span>;</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;</div><div class="line">                                    m.replace(ReflectUtils.getMethodCallString(m, memberMappingInfo, temPatchClass, ReflectUtils.isStatic(method.getModifiers()), isInline));</div><div class="line">                                &#125;</div><div class="line">                            ...</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//remove static code block,pay attention to the  class created by cloneClassWithoutFields which construct's</span></div><div class="line">    CtClass patchClass = cloneClassWithoutFields(temPatchClass, patchName, <span class="keyword">null</span>);</div><div class="line">    patchClass = JavaUtils.addPatchConstruct(patchClass, modifiedClass);</div><div class="line">    <span class="keyword">return</span> patchClass;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码其实是这个插件的核心部分，总体来说就是将修改后的代码全部翻译成反射调用生成 xxxPatch 类。<br>我们先只关注<code>method.instrument()</code>这个方法，这个Javassist的API，作用是遍历方法中的代码逻辑，包括：</p>
<ul>
<li>FieldAccess，字段访问操作。分为字段读和写两种，分别调用<code>ReflectUtils.getFieldString</code>方法，将代码逻辑使用Javassist翻译成反射调用，然后替换。</li>
<li>NewExpr，new 对象操作。也分为两种<ul>
<li>非静态内部类，调用<code>ReflectUtils.getNewInnerClassString</code>翻译成反射，然后替换</li>
<li>外部类，调用<code>ReflectUtils.getCreateClassString</code>翻译成反射，然后替换</li>
</ul>
</li>
<li>Cast，强转操作。调用<code>ReflectUtils.getCastString</code>翻译成反射，然后替换</li>
<li>MethodCall，方法调用操作。情况比较复杂，以下几种情形<ul>
<li>lamda表达式，调用<code>ReflectUtils.getNewInnerClassString</code>生成内部类的方法并翻译成反射，然后替换</li>
<li>修改的方法是内联方法，调用<code>ReflectUtils.getInLineMemberString</code>方法生成占位内联类<code>xxInLinePatch</code>，并在改类中把修改的方法翻译成反射，然后替换调用，这方法中又有一些其他情况判断，感兴趣的读者可以自行阅读</li>
<li>如果是super方法，这个情况后面单独拎出来说</li>
<li>正常方法，调用<code>ReflectUtils.getMethodCallString</code>方法翻译成反射，然后替换</li>
</ul>
</li>
<li>生成补丁类并增加构造方法</li>
</ul>
<p>请注意，以上所有方法和需要处理的方法都需要特别注意方法签名！</p>
<h2 id="控制补丁行为"><a href="#控制补丁行为" class="headerlink" title="控制补丁行为"></a>控制补丁行为</h2><p>最后调用 <code>createControlClass(patchPath, ctClass)</code>、<code>createPatchesInfoClass(patchPath);</code>生成 PatchesInfoImpl、xxxPatchControl 写入补丁信息和控制补丁行为。</p>
<p>其中，<code>PatchesInfoImpl</code>中包含所有补丁类的一一对应关系，比如 <code>MainActivity -&gt; MainActivityPatch</code>，不清楚的可以参考该系列的上一篇文章。生成的<code>xxxPatchControl</code>类用于生成<code>xxPatch</code>类，并判断补丁中的方法是否和methods.robust中的方法id匹配，如果匹配才会去调用补丁中方法。</p>
<p>至此整体流程基本梳理完成。后面会针对具体的复杂情况加以解析。</p>
<h1 id="this-如何处理"><a href="#this-如何处理" class="headerlink" title="this 如何处理"></a>this 如何处理</h1><p>首先，在补丁类中 xxPatch 中，<code>this</code>指代的是xxPatch类的对象，而我们是想要的对象是被补丁的类的对象。</p>
<p>在<code>PatchesFactory.createPatchClass()</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">CtMethod reaLParameterMethod = CtMethod.make(JavaUtils.getRealParamtersBody(), temPatchClass);</div><div class="line">temPatchClass.addMethod(reaLParameterMethod);</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getRealParamtersBody</span><span class="params">()</span> </span>&#123;</div><div class="line">    StringBuilder realParameterBuilder = <span class="keyword">new</span> StringBuilder();</div><div class="line">    realParameterBuilder.append(<span class="string">"public  Object[] "</span> + Constants.GET_REAL_PARAMETER + <span class="string">" (Object[] args)&#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"if (args == null || args.length &lt; 1) &#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" return args;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"&#125;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" Object[] realParameter = new Object[args.length];"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"for (int i = 0; i &lt; args.length; i++) &#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"if (args[i] instanceof Object[]) &#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"realParameter[i] ="</span> + Constants.GET_REAL_PARAMETER + <span class="string">"((Object[]) args[i]);"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"&#125; else &#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"if (args[i] ==this) &#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" realParameter[i] =this."</span> + ORIGINCLASS + <span class="string">";"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"&#125; else &#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" realParameter[i] = args[i];"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" &#125;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" &#125;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" &#125;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"  return realParameter;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" &#125;"</span>);</div><div class="line">    <span class="keyword">return</span> realParameterBuilder.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段的作用是，在每个xxPatch补丁类中都插入一个<code>getRealParameter()</code>方法，反编译出来最终的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Object[] getRealParameter(Object[] objArr) &#123;</div><div class="line">    <span class="keyword">if</span> (objArr == <span class="keyword">null</span> || objArr.length &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> objArr;</div><div class="line">    &#125;</div><div class="line">    Object[] objArr2 = <span class="keyword">new</span> Object[objArr.length];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objArr.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (objArr[i] <span class="keyword">instanceof</span> Object[]) &#123;</div><div class="line">            objArr2[i] = getRealParameter((Object[]) objArr[i]);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objArr[i] == <span class="keyword">this</span>) &#123;</div><div class="line">            objArr2[i] = <span class="keyword">this</span>.originClass;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            objArr2[i] = objArr[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> objArr2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的作用是，在每个xxPatch中使用的<code>this</code>，都转换成xx被补丁类的对象。其中的<code>originClass</code>就是补丁类的对象。</p>
<h1 id="super-如何处理"><a href="#super-如何处理" class="headerlink" title="super 如何处理"></a>super 如何处理</h1><p>同<code>this</code>类似，xxPatch中调用 <code>super</code> 方法同样需要转为调用被补丁类中相关方法的<code>super</code>调用。</p>
<p>还是在<code>PatchesFactory.createPatchClass()</code>方法中有<code>dealWithSuperMethod(temPatchClass, modifiedClass, patchPath);</code>调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dealWithSuperMethod</span><span class="params">(CtClass patchClass, CtClass modifiedClass, String patchPath)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException, IOException </span>&#123;</div><div class="line">    ...</div><div class="line">    methodBuilder.append(<span class="string">"public  static "</span> + invokeSuperMethodList.get(index).getReturnType().getName() + <span class="string">"  "</span> + ReflectUtils.getStaticSuperMethodName(invokeSuperMethodList.get(index).getName()) + <span class="string">"("</span> + patchClass.getName() + <span class="string">" patchInstance,"</span> + modifiedClass.getName() + <span class="string">" modifiedInstance,"</span> + JavaUtils.getParameterSignure(invokeSuperMethodList.get(index)) + <span class="string">")&#123;"</span>);</div><div class="line">    ...</div><div class="line">    CtClass assistClass = PatchesAssistFactory.createAssistClass(modifiedClass, patchClass.getName(), invokeSuperMethodList.get(index));</div><div class="line">    ...</div><div class="line">    methodBuilder.append(NameManger.getInstance().getAssistClassName(patchClass.getName()) + <span class="string">"."</span> + ReflectUtils.getStaticSuperMethodName(invokeSuperMethodList.get(index).getName())  + <span class="string">"(patchInstance,modifiedInstance"</span>);</div><div class="line">    ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>保留主要代码，根据方法签名生成了一个新的方法，以<code>staticRobust+methodName</code>命名，方法中调用以<code>RobustAssist</code>结尾的类中的同名方法，并调用 <code>PatchesAssistFactory.createAssistClass</code> 方法生成该类，这个类的父类是被补丁类的父类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">PatchesAssistFactory.createAssistClass:</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">createAssistClass</span><span class="params">(CtClass modifiedClass, String patchClassName, CtMethod removeMethod)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    staticMethodBuidler.append(<span class="string">"public static  "</span> + removeMethod.returnType.name + <span class="string">"   "</span> + ReflectUtils.getStaticSuperMethodName(removeMethod.getName())</div><div class="line">            + <span class="string">"("</span> + patchClassName + <span class="string">" patchInstance,"</span> + modifiedClass.getName() + <span class="string">" modifiedInstance)&#123;"</span>);</div><div class="line">                </div><div class="line">    staticMethodBuidler.append(<span class="string">" return patchInstance."</span> + removeMethod.getName() + <span class="string">"("</span> + JavaUtils.getParameterValue(removeMethod.getParameterTypes().length) + <span class="string">");"</span>);</div><div class="line">    staticMethodBuidler.append(<span class="string">"&#125;"</span>);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在遍历<code>MethodCall</code>过程中，处理方法调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">m.replace(ReflectUtils.invokeSuperString(m, firstVariable));</div><div class="line">...</div><div class="line"><span class="function">def <span class="keyword">static</span> String <span class="title">invokeSuperString</span><span class="params">(MethodCall m, String originClass)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    stringBuilder.append(getStaticSuperMethodName(m.methodName) + <span class="string">"(this,"</span> + Constants.ORIGINCLASS + <span class="string">",\$\$);"</span>);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>传递的参数，patch、originClass（被补丁类对象）、方法实际参数列表。</p>
<p>反编译出的结果实际是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">MainFragmentActivity:</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(bundle);</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">MainFragmentActivityPatch:</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticRobustonCreate</span><span class="params">(MainFragmentActivityPatch mainFragmentActivityPatch, MainFragmentActivity mainFragmentActivity, Bundle bundle)</span> </span>&#123;</div><div class="line">    MainFragmentActivityPatchRobustAssist.staticRobustonCreate(mainFragmentActivityPatch, mainFragmentActivity, bundle);</div><div class="line">&#125;</div><div class="line"></div><div class="line">MainFragmentActivityPatchRobustAssist:</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragmentActivityPatchRobustAssist</span> <span class="keyword">extends</span> <span class="title">WrapperAppCompatFragmentActivity</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticRobustonCreate</span><span class="params">(MainFragmentActivityPatch mainFragmentActivityPatch, MainFragmentActivity mainFragmentActivity, Bundle bundle)</span> </span>&#123;</div><div class="line">        mainFragmentActivityPatch.onCreate(bundler);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数是按照实际的方法参数传进去的，最后调用了xxPatch.superMethod方法。但是这样也并没有实现<code>super</code>方法的转义啊，再往下看。</p>
<p>在处理smali过程中，有这么一段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">invokeSuperMethodInSmali</span><span class="params">(<span class="keyword">final</span> String line, String fullClassName)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    result = line.replace(Constants.SMALI_INVOKE_VIRTUAL_COMMAND, Constants.SMALI_INVOKE_SUPER_COMMAND);</div><div class="line">    ...</div><div class="line">    result = result.replace(<span class="string">"p0"</span>, <span class="string">"p1"</span>);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在处理之前，smali是长这样的：<code>invoke-invoke-virtual {p0, p2}, Lcom/meituan/robust/patch/SecondActivityPatch;-&gt;onCreate(Landroid/os/Bundle;)V</code>,<br>处理之后是这样的：<code>invoke-super {p1, p2}, Landroid/support/v7/app/AppCompatActivity;-&gt;onCreate(Landroid/os/Bundle;)V</code>，意思就是本来是调用正常方法，现在转为调用super方法，并且把参数换了一下，把p0(补丁类对象)换成了p1（被补丁类对象），这样就完成了<code>super</code>的处理。反编译后最终结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragmentActivityPatchRobustAssist</span> <span class="keyword">extends</span> <span class="title">WrapperAppCompatFragmentActivity</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticRobustonCreate</span><span class="params">(MainFragmentActivityPatch mainFragmentActivityPatch, MainFragmentActivity mainFragmentActivity, Bundle bundle)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(bundle);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="内联怎么处理"><a href="#内联怎么处理" class="headerlink" title="内联怎么处理"></a>内联怎么处理</h1><p>内联是个广义的概念，包括了混淆过程中的优化(修改方法签名、删除方法等)、内联。在上面的分析中处理zi方法基本也提到了，缺啥补啥：就是把内联掉的方法再补回来。<br>对于内联的方法，不能用<code>@Modify</code>注解标注，只能使用<code>RobustModify.modify()</code>标注，因为在基础包中方法都没了，打了l补丁方法也没用。</p>
<p>主要逻辑在遍历<code>MethodCall</code> -&gt; <code>repalceInlineMethod()</code> -&gt; <code>ReflectUtils.getInLineMemberString()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">stringBuilder.append(<span class="string">" instance=new "</span> + NameManger.getInstance().getInlinePatchName(method.declaringClass.name) + <span class="string">"(\$0);"</span>)</div><div class="line">stringBuilder.append(<span class="string">"\$_=(\$r)instance."</span> + getInLineMethodName(method) + <span class="string">"("</span> + parameterBuilder.toString() + <span class="string">");"</span>)</div><div class="line">...</div></pre></td></tr></table></figure>
<p>作用就是把内联掉的方法调用替换为InLine类中的新增方法。</p>
<p>结果就是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String first=<span class="keyword">null</span>;</div><div class="line">    <span class="comment">//privateMethod被内联了</span></div><div class="line">    <span class="comment">// private void privateMethod(String fir)&#123;</span></div><div class="line">    <span class="comment">//    System.out.println(fir);</span></div><div class="line">    <span class="comment">//&#125;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(String fir)</span></span>&#123;</div><div class="line">        first=fir;</div><div class="line">        Parent children=<span class="keyword">new</span> Children();</div><div class="line">        <span class="comment">//children.privateMethod("Robust");</span></div><div class="line">        <span class="comment">//内联替换的逻辑</span></div><div class="line">        ParentInline inline= <span class="keyword">new</span> ParentInline(children);</div><div class="line">        inline.privateMethod(<span class="string">"Robust"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentInline</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Parent children ;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentInline</span><span class="params">(Parent p)</span></span>&#123;</div><div class="line">       children=p;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//混淆为c</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">(String fir)</span></span>&#123;</div><div class="line">        System.out.println(fir);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Robust 的核心其实就是自动化生成补丁这块，至于插庄、补丁加载这些都是很好实现的，因为没有很多的特殊情况需要处理。<br>这篇文章主要分析了自动化补丁插件的主要工作流程，和一些特殊情况的处理，文章有限，当然还有很多特殊情况没有分析，这里只是提供一些分析源码的思路，碰到特殊情况可以按照这个思路排查解决问题。</p>
<p>就像代码中有一行注释，我觉得特别能概括自动化生成补丁的团队的心里路程，在此也再次感谢美团团队对开源做出的贡献。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  shit !!too many situations need take into  consideration</span></div></pre></td></tr></table></figure></p>
<p>总体来说，Robust 坑是有的，但是它也是高可用性、高兼容性的热修复框架，尤其是在Android 系统开放性越来越收紧的趋势下，Robust  作为不 hook 系统 API 的热修复框架优势更加突出。虽然其中可能有一些坑，只要我们对原理熟悉掌握，才有信心能搞定这些问题。</p>
<p>下一篇文章，主要就讲下Robust与其他框架搭配使用出现的一些坑。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://tech.meituan.com/android_autopatch.html" target="_blank" rel="external">Android热更新方案Robust开源，新增自动化补丁工具</a></li>
<li><a href="https://www.jianshu.com/p/b9b3ff0e1bf8" target="_blank" rel="external">Javassist 使用指南（二）</a></li>
<li><a href="https://juejin.im/entry/579ef6e37db2a2005a6350d8" target="_blank" rel="external">[转] 深入理解 Dalvik 字节码指令及 Smali 文件</a></li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2018/05/28/robust-1/">http://w4lle.com/2018/05/28/robust-1/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Android 热补丁框架 Robust 中，几个重要的流程包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;补丁加载过程&lt;/li&gt;
&lt;li&gt;基础包插桩过程&lt;/li&gt;
&lt;li&gt;补丁包生成过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上一篇文章&lt;a href=&quot;http://w4lle.com/2017/03/31/robust-0/&quot;&gt;Android热补丁之Robust原理解析(一)&lt;/a&gt;中，我们分析了前两个，补丁加载过程和基础包插桩过程，分析的版本为 &lt;code&gt;0.3.2&lt;/code&gt;。&lt;br&gt;该篇文章为该系列的第二篇文章，主要分析补丁自动化生成的过程，分析的版本为&lt;code&gt;0.4.82&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
      <category term="热补丁" scheme="http://w4lle.com/tags/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>使用 Python 处理 pdf</title>
    <link href="http://w4lle.com/2018/02/02/python-pdf/"/>
    <id>http://w4lle.com/2018/02/02/python-pdf/</id>
    <published>2018-02-02T01:34:45.000Z</published>
    <updated>2018-02-05T01:33:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近老婆工作中碰到一些困难，总是跟我抱怨工作好烦，不开心。<br>主要是是因为要处理一些报告，这些 pdf 格式的样本报告比较多，基本都是人工操作比较容易出错，也比较琐碎，好心情都被磨没了。</p>
<p>然后我说要么写个小程序吧，帮你处理这些琐碎的工作，然后就大概梳理了一下主要需求：</p>
<a id="more"></a>
<p>内部报告：</p>
<ol>
<li>首先需要从系统出导出一个大的 pdf，包含很多小的 pdf</li>
<li>每个小的 pdf 报告中包含一些信息，比如 报告标题、姓名、编号、医院、总页数</li>
<li>拿到这些信息之后，分割大的 pdf，将小的 pdf 报告剥离处理</li>
<li>然后重命名这些报告，格式为 <code>姓名-编号.pdf</code></li>
<li>将这些报告移动到对应医院的目录下，然后将这些医院目录压缩</li>
</ol>
<p>外部报告：</p>
<ol>
<li>外部会发过来压缩包，其中包含单个的 pdf 报告</li>
<li>解压缩后将报告拿出来，提取其中的信息，信息基本同内部报告</li>
<li>重命名</li>
<li>移动到对应的医院目录下，并压缩</li>
</ol>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>人生苦短，我用python。<br>嗯，python大法好，处理这些琐碎的事情写个 python 脚本跑一下不就好了吗。<br>python 版本使用的python 3.x。</p>
<p>梳理了下输球，首先需要解析大 pdf 中的一些关键信息，转化为我们需要的报告信息，首先写个Model叫做 <code>Sample</code>，包含 title、number、name、total_page、hospital 等等，然后依次解析 pdf 生成组成 samples 列表，最后根据报告列表分割处理pdf 就好了。</p>
<h2 id="解析-pdf"><a href="#解析-pdf" class="headerlink" title="解析 pdf"></a>解析 pdf</h2><p>有个 python 库叫做 <a href="https://github.com/euske/pdfminer" target="_blank" rel="external">pdfminer</a>，这个库已经不支持python 3.x 版本了，该项目注明了可以使用 <a href="https://github.com/pdfminer/pdfminer.six" target="_blank" rel="external">pdfminer.six</a>来支持3.x的版本。</p>
<p>基本语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_samples</span><span class="params">()</span>:</span></div><div class="line">    fp = open(get_origin_report_path(), <span class="string">'rb'</span>)  <span class="comment"># 以二进制读模式打开</span></div><div class="line">    <span class="comment"># 用文件对象来创建一个pdf文档分析器</span></div><div class="line">    praser = PDFParser(fp)</div><div class="line">    <span class="comment"># 创建一个PDF文档</span></div><div class="line">    doc = PDFDocument()</div><div class="line">    <span class="comment"># 连接分析器 与文档对象</span></div><div class="line">    praser.set_document(doc)</div><div class="line">    doc.set_parser(praser)</div><div class="line"></div><div class="line">    <span class="comment"># 提供初始化密码</span></div><div class="line">    <span class="comment"># 如果没有密码 就创建一个空的字符串</span></div><div class="line">    doc.initialize()</div><div class="line"></div><div class="line">    <span class="comment"># 检测文档是否提供txt转换，不提供就忽略</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> doc.is_extractable:</div><div class="line">        <span class="keyword">raise</span> PDFTextExtractionNotAllowed</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="comment"># 创建PDf 资源管理器 来管理共享资源</span></div><div class="line">        rsrcmgr = PDFResourceManager()</div><div class="line">        <span class="comment"># 创建一个PDF设备对象</span></div><div class="line">        laparams = LAParams()</div><div class="line">        device = PDFPageAggregator(rsrcmgr, laparams=laparams)</div><div class="line">        <span class="comment"># 创建一个PDF解释器对象</span></div><div class="line">        interpreter = PDFPageInterpreter(rsrcmgr, device)</div><div class="line"></div><div class="line">        <span class="comment"># 循环遍历列表，每次处理一个page的内容</span></div><div class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> doc.get_pages():  <span class="comment"># doc.get_pages() 获取page列表</span></div><div class="line">            number_index = <span class="number">0</span></div><div class="line">            name_index = <span class="number">0</span></div><div class="line">            sample = Sample()</div><div class="line">            interpreter.process_page(page)</div><div class="line">            <span class="comment"># 接受该页面的LTPage对象</span></div><div class="line">            layout = device.get_result()</div><div class="line">            <span class="comment"># 这里layout是一个LTPage对象 里面存放着 这个page解析出的各种对象 一般包括LTTextBox, LTFigure, LTImage, LTTextBoxHorizontal 等等 想要获取文本就获得对象的text属性，</span></div><div class="line">            <span class="keyword">for</span> index, out <span class="keyword">in</span> enumerate(layout):</div><div class="line">                <span class="comment"># if hasattr(out, "get_text"):</span></div><div class="line">                <span class="comment"># if (isinstance(out, LTTextBoxHorizontal)):</span></div><div class="line">                <span class="keyword">if</span> (isinstance(out, LTTextBox)):</div><div class="line">                    <span class="keyword">with</span> open(get_log_path(), <span class="string">'a'</span>) <span class="keyword">as</span> outfile:</div><div class="line">                        results = out.get_text().replace(<span class="string">u'\xa0'</span>, <span class="string">u' '</span>)</div><div class="line">                        parse()</div><div class="line">                        ...</div><div class="line">                        ....</div></pre></td></tr></table></figure>
<p>官网给出的 layout 布局</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/pdfminer_layout.png" alt="layout"></p>
<p>我们主要拿其中的文本信息，所以拿到每一页 pdf 的LTPage后，遍历其中的包含 text 属性的控件就好了，拿到文本信息，根据正则匹配到关心的文本信息，赋值给新建的<code>sample</code>，依次循环，最后组成 <code>samples</code> 报告列表给后面使用。<br>解析完了后就需要处理 pdf 了。</p>
<h3 id="分割-pdf"><a href="#分割-pdf" class="headerlink" title="分割 pdf"></a>分割 pdf</h3><p>首先要做的是将大的 pdf 分割成小的 pdf，搜了下分割 pdf 有个python 库叫做 <a href="https://pythonhosted.org/PyPDF2/" target="_blank" rel="external">PyPDF2</a>，参考API 写了一个工具方法用来分割 pdf。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_pdf</span><span class="params">(infn, outfn, start_page, end_page)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    分割pdf文档，如果需要的话</div><div class="line"></div><div class="line">    :param infn: 源报告目录</div><div class="line">    :param outfn: 分割后输出文档目录</div><div class="line">    :param start_page:</div><div class="line">    :param end_page:</div><div class="line">    :return:</div><div class="line">    """</div><div class="line">    pdf_output = PdfFileWriter()</div><div class="line">    pdf_input = PdfFileReader(open(infn, <span class="string">'rb'</span>))</div><div class="line">    <span class="comment"># 获取 pdf 共用多少页</span></div><div class="line">    page_count = pdf_input.getNumPages()</div><div class="line">    <span class="comment"># 将 pdf 的分割页面，输出到一个新的文件</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start_page, end_page):</div><div class="line">        pdf_output.addPage(pdf_input.getPage(i))</div><div class="line">    pdf_output.write(open(outfn, <span class="string">'wb'</span>))</div><div class="line">    print(<span class="string">'---分割pdf完毕--'</span>)</div></pre></td></tr></table></figure>
<p>根据第一步得出的 samples，循环一下拿出其中的total_page，依次分割就好了。</p>
<p>最后就是重命名、移动、压缩，不写了。</p>
<h1 id="打包成-exe-可执行文件"><a href="#打包成-exe-可执行文件" class="headerlink" title="打包成 exe 可执行文件"></a>打包成 exe 可执行文件</h1><p>老婆使用的是 Windowns，所以最后要打包成 <code>.exe</code> 可执行文件，搜了下 pyinstaller 可以解决，但是还是需要在对应的平台才能打出对应平台的可执行文件，可就是说想要打出 <code>.exe</code> 必须在 Windows 下打包，这就有点蛋疼了。然后弄了一下，发现 Windows 用来做开发真的是难用无比。<br>最后也没打 <code>.exe</code>，直接在 Windows 下装了python，双击 <code>.py</code> 文件好了，有bug的话替换一下文件好了，不用重新打包。</p>
<h1 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h1><p>项目交付老婆使用后，极其的好用，大幅提升了工作效率，减少出错概率，老婆甚至发了个朋友圈夸奖了一番，感觉美滋滋。</p>
<p>美了不到两天就出 bug 了。</p>
<p>bug是这样的，比如有个编号<code>编号：G201802020108</code> 正常解析出来 <code>sample.number = G201802020108</code> 才对，但是结果可能是这样的<code>G20180202</code>，后面少了几位。拿到原始的大 pdf 跑了一遍发现确实是这样，每个 pdf 在解析时我都把文本信息存了下来以便查问题用，这时派上了用场，打开看了下文本信息被这样处理了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">编号：G20180202</div><div class="line"><span class="number">0108</span></div></pre></td></tr></table></figure>
<p>本来在一行或者说在一个 <code>LTTextBox</code> 中的内容被分割成了两个，所以出现了内容少的问题。</p>
<p>找到了问题原因就好处理了。<br>首先想到了一个方案，每个 <code>LTxx</code> 控件在当页 pdf 中的位置由坐标表示，左上角坐标是 <code>{x0:0,y0:0, x1:0,y1:0}</code>，只要框住了编号信息所在的坐标范围，只要在该范围内的，所有文本信息 append 一下然后再正则匹配就好了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">in_number_area</span><span class="params">(text_box)</span>:</span></div><div class="line">    <span class="comment"># x0,y0,x1,y1</span></div><div class="line">    scope = (<span class="number">370</span>, <span class="number">700</span>, <span class="number">560</span>, <span class="number">740</span>)</div><div class="line">    <span class="keyword">if</span> in_area(text_box.bbox, scope):</div><div class="line">        print(<span class="string">'样本编号匹配！坐标点：'</span>, text_box.bbox)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    </div><div class="line"></div><div class="line"><span class="comment"># 判断TextBox坐标范围是否在规定范围内</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">in_area</span><span class="params">(bbox, scope)</span>:</span></div><div class="line">    <span class="keyword">if</span> bbox[<span class="number">0</span>] &gt; scope[<span class="number">0</span>] <span class="keyword">and</span> bbox[<span class="number">1</span>] &gt; scope[<span class="number">1</span>] <span class="keyword">and</span> bbox[<span class="number">2</span>] &lt; scope[<span class="number">2</span>] <span class="keyword">and</span> bbox[<span class="number">3</span>] &lt; scope[<span class="number">3</span>]:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>给定固定坐标范围，找到在该坐标范围内的控件，然后再去匹配。</p>
<p>跑了一下确实生效了，但是问题依然没有解决，为什么呢？因为报告种类不一，导致格式就不一样，坐标范围也不一样，也就是说不能动态的找到坐标范围。该方案失败。</p>
<p>于是又想到了第二个方案，直接看代码吧</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 解析编号</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> utils.number_legal_for_internal(sample.number):</div><div class="line">    num = utils.parse_sample_num(results)</div><div class="line">    <span class="keyword">if</span> num:</div><div class="line">        number_index = index</div><div class="line">        sample.number = num</div><div class="line">        <span class="keyword">continue</span></div><div class="line">    <span class="comment"># 解决编号被分成两段的问题</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> utils.number_legal_for_internal(sample.number) <span class="keyword">and</span> number_index <span class="keyword">and</span> (</div><div class="line">            index == number_index + <span class="number">1</span> <span class="keyword">or</span> index == number_index + <span class="number">2</span>):</div><div class="line">        print(<span class="string">'修正后的编号：'</span>)</div><div class="line">        num = utils.parse_sample_num(<span class="string">'样本编号：'</span> + sample.number + results)</div><div class="line">        sample.number = num</div><div class="line">        <span class="keyword">if</span> utils.number_legal_for_internal(num):</div><div class="line">            number_index = <span class="number">0</span></div><div class="line">            <span class="keyword">continue</span></div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>基本解决。</p>
<p>其实第二个方案也不太完美，为什么呢？编号还好说，一般都是字母加数字，如果出现这个bug一般都能比较好判断是否合法，比如编号长度 &gt;=11，但是，如果是名字呢，就没有很好的合法规则来判断，比如<code>名字：张三丰</code>，<code>丰</code>字被分割了，而合法判断是名字长度 &gt;=2，那最后结果就是<code>张三</code>而不是<code>张三丰</code>。</p>
<p>所以，其实还有一个优化方案，在方案一和方案二的基础上，第一步先匹配关键字，比如<code>姓名：</code>，匹配到了以后再框定坐标范围，一般名字都是6字以内，编号是20位以内，划定坐标范围后将范围内的匹配控件文本信息都拿出来再一起解析。基本做到了动态判断坐标范围。</p>
<p>外部报告跟内部报告基本是一样的，区别是首先需要解压一下，然后解析、处理，不写了。</p>
<h1 id="还有哪些可以做"><a href="#还有哪些可以做" class="headerlink" title="还有哪些可以做"></a>还有哪些可以做</h1><p>前面写了怎么解析处理pdf，其实还有一部分工作也可以用脚本来处理，比如，大的pdf 下载可以通过脚本处理；处理好的 pdf 报告要通过邮件法发送给客户，也可以通过脚本处理；有时还需要把解析出的信息填到表格中，也是可以用脚本处理的。</p>
<p>总结下来一共有这几个功能：</p>
<ul>
<li>爬虫，从系统中导出大的 pdf 报告</li>
<li>pdf 解析和分割</li>
<li>归类，压缩</li>
<li>生成表格</li>
<li>发送邮件</li>
</ul>
<p>目前只做了2 和3 ，其余的有时间慢慢写。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>为什么写这篇文章呢？<br>其实用到的东西很简单，看几分钟 python 入门然后再找两个开源库就搞定了，也没必要记录什么技术知识点。<br>我真正想说的是一些感悟，程序员碰到这种问题一般都会想办法写一些脚本处理，没什么稀奇的。但是对于不会写程序的人来说，有这个程序和没有这个程序简直就是不一样的工作，就拿这件事来说，用了这个程序之后，我老婆的工作效率明显提升，每天能节省出1-2小时时间做别的事情，从交付那天起，基本没听过老婆再抱怨工作了。简直开心。</p>
<p>还有就是以前总感觉程序员这个工作对生活的帮助简直就是没啥用，比如，你看谁谁现在是医生，去医院都不用挂号，直接就能看病；谁谁是老师，孩子上学的事情根本不用愁等等诸如此类，职业除了能养活自己之外能够反哺生活，在生活中提供一些价值。反观程序员对生活上的帮助简直就是0，甚至可以说是负数。</p>
<p>现在是高速发展的信息时代，干什么工作都离不开手机、电脑，甚至人工智能在某些方面都开始取代人力去做一些工作，所以我觉得越来越能体现出程序员的价值，可以控制机器取代人工去做一些重复性的、机械性的工作，所以在有能力的前提下学习一些开发知识会大有裨益。就像每个人都学英语一样，在未来，编程也有可能是一门基础学科，每个人都应该掌握。</p>
<p>回到现在，简单的用一些简单的脚本提升生活幸福感，把这些烦人的工作交给机器去做，人类最擅长的是浪费时间，恩。</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/machine_time1.jpg" alt=""></p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/machine_time2.jpg" alt=""></p>
<p>本文链接： <a href="http://w4lle.com/2018/02/02/python-pdf/">http://w4lle.com/2018/02/02/python-pdf/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近老婆工作中碰到一些困难，总是跟我抱怨工作好烦，不开心。&lt;br&gt;主要是是因为要处理一些报告，这些 pdf 格式的样本报告比较多，基本都是人工操作比较容易出错，也比较琐碎，好心情都被磨没了。&lt;/p&gt;
&lt;p&gt;然后我说要么写个小程序吧，帮你处理这些琐碎的工作，然后就大概梳理了一下主要需求：&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://w4lle.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="其他" scheme="http://w4lle.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>区块链（一）区块链和以太坊</title>
    <link href="http://w4lle.com/2017/10/27/ethereum-0/"/>
    <id>http://w4lle.com/2017/10/27/ethereum-0/</id>
    <published>2017-10-27T11:37:06.000Z</published>
    <updated>2017-10-27T13:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区块链是什么"><a href="#区块链是什么" class="headerlink" title="区块链是什么"></a>区块链是什么</h1><blockquote>
<p>区块链（英语：blockchain 或 block chain）是用分布式数据库识别、传播和记载信息的智能化对等网络, 也称为价值互联网。中本聪在2008年，于《比特币白皮书》中提出“区块链”概念，并在2009年创立了比特币社会网络，开发出第一个区块，即“创世区块”。</p>
</blockquote>
<a id="more"></a>
<p>区块链，简单的讲就是一个分布式存储的一个大账本，由一条条的交易记录（block）组成，并且任何人都可以拥有这个账本并且可以存储交易记录，几乎在同一时间这条记录就会被同步到全世界的副本上，这就使得没有人能够修改本地账本中的记录，使其拥有了去中心化的能力。可以理解为这就是区块链技术的基本内容，比特币和以太坊和其他代币都是以此为基础。最有名气的就属比特币了。</p>
<p>考虑现实生活，比如想去找一个陌生人借钱，那么就必须有一个双方都认可的第三方存在，比如银行。由于区块链的存在，这个第三方就可以不需要了。比如，我要借给 A 一块钱，我要在账本上写一条，我要借给 A 一块钱，首先会去检查你有没有一块钱，如果有的话就会记录下来，并且同时在你的账户中扣掉一块钱同时在 A 的账户中增加一块钱，同时同步到所有持有该账本的账户上。</p>
<p>因此，区块链具有以下特点：</p>
<ul>
<li>去中心化</li>
<li>分布式</li>
<li>密码性安全</li>
</ul>
<h1 id="以太坊是什么"><a href="#以太坊是什么" class="headerlink" title="以太坊是什么"></a>以太坊是什么</h1><blockquote>
<p>以太坊是一个全新开放的区块链平台，它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。</p>
</blockquote>
<p>以太坊相比于区块链有了更进一步的发展，它可以在链上创建一些自动运行的程序称之为智能合约，只要这个智能合约发布到了链上，任何人都无法修改它，并且它是对任何人透明的，任何人都可以看到其代码。任何人都可以发布智能合约，编写智能合约所使用的高级语言也是图灵完备的（意味着语言可以使用计图灵机完成任何图灵机可以完成的任务），这就使得这是可编程的，任何人支付一笔费用 (Gas) 都可以部署编写的智能合约供其他人使用。</p>
<p>考虑现实生活，比如说使用基于以太坊的智能合约存钱，该合约约定月利率1%，那么假如我存了100块钱进去，一个月后来取，那么我能取到的金额必然是 100 + 100 * 0.01。</p>
<p>所以相对于区块链，以太坊多了两个特点：</p>
<ul>
<li>智能合约</li>
<li>图灵完备</li>
</ul>
<h1 id="挖矿是怎么回事？"><a href="#挖矿是怎么回事？" class="headerlink" title="挖矿是怎么回事？"></a>挖矿是怎么回事？</h1><p>以太坊的本质就是一个基于交易的状态机(transaction-based state machine)。以太坊的状态包含很多交易，这些交易被打包到区块中（block），也就是说每个 block 包含了一系列的交易，每个区块与它的前一个区块链接起来组成区块链。<br><img src="http://7xs23g.com1.z0.glb.clouddn.com/blockchain.png" alt="blockchain"><br>为了让交易被认为是有效的，都必须要经历一个验证的过程，这个过程其实就是挖矿。挖矿实际上就是矿工用他们的计算资源来创建一个包含有效交易的区块出来。然而当你在计算区块的时候别的矿工同样也在计算，如果大家同时提交的话，怎么证明谁的区块是有效的？所以在提交区块到区块链上时，都需要提供一个数学机制的证明，称之为工作量证明（proof of work），所以一个矿工必须要比其他矿工更快的提供出这个证明来抢占区块的有效性将之合并到区块两上，与此同时，别的矿工会及时的将区块链的状态更新至最新。证实了一个新区块的矿工都会被奖励一定价值的奖赏。奖赏就是以太坊使的用一种内在数字代币—以太币(Ether)。</p>
<p>另外，以太坊和区块链的架构不同在于，以太坊区块不仅包含交易记录和最近的状态，还包含区块序号和难度值。</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/ethereum-blockchain.png" alt=""></p>
<h1 id="我们能用来干嘛"><a href="#我们能用来干嘛" class="headerlink" title="我们能用来干嘛"></a>我们能用来干嘛</h1><p>我们公司 1024 程序员节当天搞了个 HackathonDay 活动，我们报名参加了下，并且选题就是基于区块链的实际应用，虽然基本只有一天的时间来学习区块链的相关知识，我们还是做出了一些 Demo，基本算是入门。<br>所以接下来的文章会写到基于以太坊搭建一个私有链、创建账户、进行挖矿、进行转账交易、基于 Solidity 语言编写智能合约、部署到区块链上、编写 DApp 来使用智能合约等等。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://github.com/ethereum/wiki/wiki/%5B%E4%B8%AD%E6%96%87%5D-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6" target="_blank" rel="external">以太坊白皮书</a></li>
<li><a href="http://ethfans.org/posts/how-does-ethereum-work-anyway" target="_blank" rel="external">以太坊的工作原理</a></li>
<li><a href="http://wangxiaoming.com/blog/2016/05/05/blockchain-tech-what-is-blockchain/" target="_blank" rel="external">区块链是什么？</a></li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2017/10/27/ethereum-0/">http://w4lle.com/2017/10/27/ethereum-0/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;区块链是什么&quot;&gt;&lt;a href=&quot;#区块链是什么&quot; class=&quot;headerlink&quot; title=&quot;区块链是什么&quot;&gt;&lt;/a&gt;区块链是什么&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;区块链（英语：blockchain 或 block chain）是用分布式数据库识别、传播和记载信息的智能化对等网络, 也称为价值互联网。中本聪在2008年，于《比特币白皮书》中提出“区块链”概念，并在2009年创立了比特币社会网络，开发出第一个区块，即“创世区块”。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="区块链" scheme="http://w4lle.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>热修复总结</title>
    <link href="http://w4lle.com/2017/05/04/hotpatch-summary/"/>
    <id>http://w4lle.com/2017/05/04/hotpatch-summary/</id>
    <published>2017-05-04T10:45:31.000Z</published>
    <updated>2017-05-15T02:51:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="热修复总结"><a href="#热修复总结" class="headerlink" title="热修复总结"></a>热修复总结</h1><table>
<thead>
<tr>
<th style="text-align:center">平台</th>
<th style="text-align:center">阿里 AndFix</th>
<th style="text-align:center">阿里 HotFix1.x</th>
<th style="text-align:center">Nuwa</th>
<th style="text-align:center">微信Tinker</th>
<th style="text-align:center">美团Robust</th>
<th style="text-align:center">阿里 HotFix2.x</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">即时生效</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">看情况</td>
</tr>
<tr>
<td style="text-align:center">性能损耗</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较大</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较小</td>
</tr>
<tr>
<td style="text-align:center">补丁包大小</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">较大</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较小</td>
</tr>
<tr>
<td style="text-align:center">占Rom体积</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">较大</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">看情况</td>
</tr>
<tr>
<td style="text-align:center">接入复杂度</td>
<td style="text-align:center">简单</td>
<td style="text-align:center">简单</td>
<td style="text-align:center">简单</td>
<td style="text-align:center">复杂</td>
<td style="text-align:center">简单</td>
<td style="text-align:center">简单</td>
</tr>
<tr>
<td style="text-align:center">安全校验</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">类替换</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">资源替换</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">即将支持</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">so替换</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">即将支持</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">全平台支持</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">开发透明</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">gradle支持</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">接口文档</td>
<td style="text-align:center">较少</td>
<td style="text-align:center">丰富</td>
<td style="text-align:center">较少</td>
<td style="text-align:center">丰富</td>
<td style="text-align:center">丰富</td>
<td style="text-align:center">丰富</td>
</tr>
<tr>
<td style="text-align:center">成功率</td>
<td style="text-align:center">较低</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">较高</td>
<td style="text-align:center">最高</td>
<td style="text-align:center">较高</td>
</tr>
<tr>
<td style="text-align:center">后台管理</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">加固兼容</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">部分兼容</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">不确定</td>
</tr>
</tbody>
</table>
<p>上表基本涵盖了具有代表性的各种热修复方案，涉及到的各种关键指标的横向对比。</p>
<p>Slider 中大概总结了各种方案的实现方式，以及常见的问题。</p>
<p>Slider 地址： <a href="http://w4lle.github.io/sliders/hot-fix/index.html" target="_blank" rel="external">http://w4lle.github.io/sliders/hot-fix/index.html</a></p>
<p>详细的各种方案分析：</p>
<ul>
<li><a href="http://w4lle.github.io/2016/03/03/Android%E7%83%AD%E8%A1%A5%E4%B8%81%E4%B9%8BAndFix%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">Android热补丁之AndFix原理解析</a></li>
<li><a href="http://w4lle.github.io/2016/05/02/%E4%BB%8EInstant%20run%E8%B0%88Android%E6%9B%BF%E6%8D%A2Application%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">从Instant run谈Android替换Application和动态加载机制</a></li>
<li><a href="http://w4lle.github.io/2016/12/16/tinker/" target="_blank" rel="external">Android热补丁之Tinker原理解析</a></li>
<li><a href="http://w4lle.github.io/2017/03/31/robust-0/" target="_blank" rel="external">Android热补丁之Robust原理解析(一)</a></li>
</ul>
<p>水平有限，难免有写的不对的地方，欢迎交流。</p>
<p>本文链接： <a href="http://w4lle.com/2017/05/04/hotpatch-summary/">http://w4lle.com/2017/05/04/hotpatch-summary/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;热修复总结&quot;&gt;&lt;a href=&quot;#热修复总结&quot; class=&quot;headerlink&quot; title=&quot;热修复总结&quot;&gt;&lt;/a&gt;热修复总结&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;平台&lt;/th&gt;
&lt;t
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
      <category term="热补丁" scheme="http://w4lle.com/tags/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>Android热补丁之Robust原理解析(一)</title>
    <link href="http://w4lle.com/2017/03/31/robust-0/"/>
    <id>http://w4lle.com/2017/03/31/robust-0/</id>
    <published>2017-03-31T07:58:12.000Z</published>
    <updated>2018-05-29T08:40:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>早在16年9月份，美团技术团队就写过一篇文章描述 Android 热补丁框架Robust的简单实现原理，但是并没有开源；然后在17年3月份，美团团队宣布正式开源 Robust并且配套了自动打补丁包工具。本系列文章主要解析Robust实现原理，分为几个方面</p>
<ul>
<li>补丁加载过程</li>
<li>基础包插桩过程</li>
<li>补丁包生成过程</li>
</ul>
<p>本文为第一篇，主要讲解补丁加载过程和基础包插桩过程，分析版本 <code>0.3.2</code>。</p>
<a id="more"></a>
<p>系列文章:</p>
<ul>
<li><a href="http://w4lle.com/2017/03/31/robust-0/">Android热补丁之Robust原理解析(一)</a></li>
<li><a href="http://w4lle.com/2018/05/28/robust-1/">Android热补丁之Robust（二）自动化补丁原理解析</a></li>
<li><a href="http://w4lle.com/2018/05/29/robust-2/">Android热补丁之Robust（三）坑和解</a></li>
</ul>
<h1 id="从-InstantRun-说起"><a href="#从-InstantRun-说起" class="headerlink" title="从 InstantRun 说起"></a>从 InstantRun 说起</h1><p>不得不说 InstantRun 真是个好东西。目前主流的热修复框架都有或多或少的参考 InstantRun 的某些技术点，比如 <a href="https://github.com/Tencent/tinker" target="_blank" rel="external">Tinker</a> 的官方文章中明确考虑过 InstantRun 中的 Application 替换，虽然最后没有采用，但是身为其兄弟库的 <a href="http://tinkerpatch.com/Docs/intro" target="_blank" rel="external">TinkerPatch</a> 中一键接入方案就采用的该技术点。关于该技术点，可以参考我之前写的一篇文章 <a href="http://w4lle.github.io/2017/01/05/one-key-for-tinker/" target="_blank" rel="external">一键接入Tinker</a> 。</p>
<p>我们知道，InstantRun 对应三种更新机制：</p>
<ul>
<li>冷插拔，我们称之为重启更新机制</li>
<li>温插拔，我们称之为重启Activity更新机制</li>
<li>热插拔，我们称之为热更新机制</li>
</ul>
<p>如果你还不熟悉 InstantRun，请参考我的这篇文章<a href="http://w4lle.github.io/2016/05/02/%E4%BB%8EInstant%20run%E8%B0%88Android%E6%9B%BF%E6%8D%A2Application%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">从Instant run谈Android替换Application和动态加载机制</a></p>
<p>而这篇文章的主角 Robust ，其热修复的关键技术点就是采用了 InstantRun 中的热更新机制，对应于多 ClassLoader 的动态加载方案，即一个 dex 文件对应一个新建 ClassLoader 。</p>
<h1 id="Robust-原理解析"><a href="#Robust-原理解析" class="headerlink" title="Robust 原理解析"></a>Robust 原理解析</h1><p>Robust 的原理可以简单描述为：</p>
<ol>
<li>打基础包时插桩，在每个方法前插入一段类型为 <code>ChangeQuickRedirect</code> 静态变量的逻辑</li>
<li>加载补丁时，从补丁包中读取要替换的类及具体替换的方法实现，新建 ClassLoader 加载补丁dex。</li>
</ol>
<p>我们来分别分析。</p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>打基础包时，Robust 为每个类新增了一个类型为 <code>ChangeQuickRedirect</code> 的静态变量，并且在每个方法前，增加判断该变量是否为空的逻辑，如果不为空，走打基础包时插桩的逻辑，否则走正常逻辑。我们反编译出基础包中的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SecondActivity</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ChangeQuickRedirect u;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (u != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (PatchProxy.isSupport(<span class="keyword">new</span> Object[]&#123;bundle&#125;, <span class="keyword">this</span>, u, <span class="keyword">false</span>, <span class="number">78</span>)) &#123;</div><div class="line">                PatchProxy.accessDispatchVoid(<span class="keyword">new</span> Object[]&#123;bundle&#125;, <span class="keyword">this</span>, u, <span class="keyword">false</span>, <span class="number">78</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">super</span>.onCreate(bundle);</div><div class="line">        ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>对应于补丁文件，需要有三个文件</p>
<ul>
<li><code>PatchesInfoImpl</code> 用于记录修改的类，及其对应的 <code>ChangeQuickRedirect</code> 接口的实现，我们反编译补丁包得出以下结果，其中的类名是混淆后的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatchesInfoImpl</span> <span class="keyword">implements</span> <span class="title">PatchesInfo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">getPatchedClassesInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">        List arrayList = <span class="keyword">new</span> ArrayList();</div><div class="line">        arrayList.add(<span class="keyword">new</span> PatchedClassInfo(<span class="string">"com.meituan.sample.robusttest.l"</span>, <span class="string">"com.meituan.robust.patch.SampleClassPatchControl"</span>));</div><div class="line">        arrayList.add(<span class="keyword">new</span> PatchedClassInfo(<span class="string">"com.meituan.sample.robusttest.p"</span>, <span class="string">"com.meituan.robust.patch.SuperPatchControl"</span>));</div><div class="line">        arrayList.add(<span class="keyword">new</span> PatchedClassInfo(<span class="string">"com.meituan.sample.SecondActivity"</span>, <span class="string">"com.meituan.robust.patch.SecondActivityPatchControl"</span>));</div><div class="line">        EnhancedRobustUtils.isThrowable = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> arrayList;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>xxxPatchControl</code> 是 <code>ChangeQuickRedirect</code> 接口的具体实现，是一个代理，具体的替换方法是在 <code>xxxPatch</code> 类中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivityPatchControl</span> <span class="keyword">implements</span> <span class="title">ChangeQuickRedirect</span> </span>&#123;</div><div class="line">...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSupport</span><span class="params">(String methodName, Object[] paramArrayOfObject)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"78:79:90:"</span>.contains(methodName.split(<span class="string">":"</span>)[<span class="number">3</span>]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">accessDispatch</span><span class="params">(String methodName, Object[] paramArrayOfObject)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            SecondActivityPatch secondActivityPatch;</div><div class="line">            ...</div><div class="line">            Object obj = methodName.split(<span class="string">":"</span>)[<span class="number">3</span>];</div><div class="line">            <span class="keyword">if</span> (<span class="string">"78"</span>.equals(obj)) &#123;</div><div class="line">                secondActivityPatch.onCreate((Bundle) paramArrayOfObject[<span class="number">0</span>]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (<span class="string">"79"</span>.equals(obj)) &#123;</div><div class="line">                <span class="keyword">return</span> secondActivityPatch.getTextInfo((String) paramArrayOfObject[<span class="number">0</span>]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (<span class="string">"90"</span>.equals(obj)) &#123;</div><div class="line">                secondActivityPatch.RobustPubliclambda$onCreate$<span class="number">0</span>((View) paramArrayOfObject[<span class="number">0</span>]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</div><div class="line">            th.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终调用 <code>accessDispatch</code> 方法，该方法会根据传递过来的方法签名，调用<code>xxxPatch</code>的修改过的方法。</p>
<ul>
<li><code>xxxPatch</code> 具体的替换实现类，代码就不贴了。</li>
</ul>
<p>其过程可以简单描述为，下发补丁包后，新建 DexClassLoader 加载补丁 dex 文件，反射得到 <code>PatchesInfoImpl</code> class，并创建其对象，调用 <code>getPatchedClassesInfo()</code> 方法得到哪些修改的类（比如 SecondActivity），然后再通过反射循环拿到每个修改类在当前环境中的的class，将其中类型为 <code>ChangeQuickRedirect</code> 的静态变量反射修改为 <code>xxxPatchControl.java</code> 这个class new 出来的对象。</p>
<p>用官方的一种图很好的表达了替换原理。</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/patching.png" alt="Robust"></p>
<h2 id="补丁加载过程分析"><a href="#补丁加载过程分析" class="headerlink" title="补丁加载过程分析"></a>补丁加载过程分析</h2><p>demo中的补丁加载就一句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> PatchExecutor(getApplicationContext(), <span class="keyword">new</span> PatchManipulateImp(),  <span class="keyword">new</span> Callback()).start();</div></pre></td></tr></table></figure>
<p><code>PatchExecutor</code> 是个 Thread</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public class PatchExecutor extends Thread &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        ...</div><div class="line">        applyPatchList(patches);</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 应用补丁列表</div><div class="line">     */</div><div class="line">    protected void applyPatchList(List&lt;Patch&gt; patches) &#123;</div><div class="line">        ...</div><div class="line">        for (Patch p : patches) &#123;</div><div class="line">            ...</div><div class="line">            currentPatchResult = patch(context, p);</div><div class="line">            ...</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected boolean patch(Context context, Patch patch) &#123;</div><div class="line">        ...</div><div class="line">        DexClassLoader classLoader = new DexClassLoader(patch.getTempPath(), context.getCacheDir().getAbsolutePath(),</div><div class="line">                null, PatchExecutor.class.getClassLoader());</div><div class="line">        patch.delete(patch.getTempPath());</div><div class="line">        ...</div><div class="line">        try &#123;</div><div class="line">            patchsInfoClass = classLoader.loadClass(patch.getPatchesInfoImplClassFullName());</div><div class="line">            patchesInfo = (PatchesInfo) patchsInfoClass.newInstance();</div><div class="line">            &#125; catch (Throwable t) &#123;</div><div class="line">             ...</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">        for (PatchedClassInfo patchedClassInfo : patchedClasses) &#123;</div><div class="line">            ...</div><div class="line">            try &#123;</div><div class="line">                oldClass = classLoader.loadClass(patchedClassName.trim());</div><div class="line">                Field[] fields = oldClass.getDeclaredFields();</div><div class="line">                for (Field field : fields) &#123;</div><div class="line">                    if (TextUtils.equals(field.getType().getCanonicalName(), ChangeQuickRedirect.class.getCanonicalName()) &amp;&amp; TextUtils.equals(field.getDeclaringClass().getCanonicalName(), oldClass.getCanonicalName())) &#123;</div><div class="line">                        changeQuickRedirectField = field;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                ...</div><div class="line">                try &#123;</div><div class="line">                    patchClass = classLoader.loadClass(patchClassName);</div><div class="line">                    Object patchObject = patchClass.newInstance();</div><div class="line">                    changeQuickRedirectField.setAccessible(true);</div><div class="line">                    changeQuickRedirectField.set(null, patchObject);</div><div class="line">                    &#125; catch (Throwable t) &#123;</div><div class="line">                    ...</div><div class="line">                &#125;</div><div class="line">            &#125; catch (Throwable t) &#123;</div><div class="line">                 ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>开启一个子线程，通过指定的路径去读patch文件的jar包，patch文件可以为多个，每个patch文件对应一个 DexClassLoader 去加载，每个patch文件中存在PatchInfoImp，通过遍历其中的类信息进而反射修改其中 <code>ChangeQuickRedirect</code> 对象的值。</p>
<h2 id="基础包插桩过程分析"><a href="#基础包插桩过程分析" class="headerlink" title="基础包插桩过程分析"></a>基础包插桩过程分析</h2><p>类似 InstantRun ， Robust 也是使用 Transform API 修改字节码文件，该 API 允许第三方插件在  .class 文件打包为 dex 文件之前操作编译好的 .class 字节码文件。</p>
<p>Robust 中的 <code>Gradle-Plugin</code> 就是操作字节码的名为 <code>robust</code> 的 gradle 插件项目。我们来简单看下实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobustTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project target)</span> </span>&#123;</div><div class="line">            <span class="comment">//解析项目下robust.xml配置文件</span></div><div class="line">            robust = <span class="keyword">new</span> XmlSlurper().parse(<span class="keyword">new</span> File(<span class="string">"$&#123;project.projectDir&#125;/$&#123;Constants.ROBUST_XML&#125;"</span>))</div><div class="line">            ...</div><div class="line">            project.android.registerTransform(<span class="keyword">this</span>)</div><div class="line">            project.afterEvaluate(<span class="keyword">new</span> RobustApkHashAction())</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(Context context, Collection&lt;TransformInput&gt; inputs, Collection&lt;TransformInput&gt; referencedInputs, TransformOutputProvider outputProvider, <span class="keyword">boolean</span> isIncremental)</span> <span class="keyword">throws</span> IOException, TransformException, InterruptedException </span>&#123;</div><div class="line">    ...</div><div class="line">    ClassPool classPool = <span class="keyword">new</span> ClassPool()</div><div class="line">    project.android.bootClasspath.each &#123;</div><div class="line">        logger.debug <span class="string">"android.bootClasspath   "</span> + (String) it.absolutePath</div><div class="line">        classPool.appendClassPath((String) it.absolutePath)</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    def box = ConvertUtils.toCtClasses(inputs, classPool)</div><div class="line">    insertRobustCode(box, jarFile)</div><div class="line">    writeMap2File(methodMap, Constants.METHOD_MAP_OUT_PATH)</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先读取 robust.xml 配置文件并初始化，可配置选项包括：</p>
<ul>
<li>一些开关选项</li>
<li>需要热补丁的包名或者类名，这些包名下的所有类都被会插入代码</li>
<li>不需要热补的包名或者类名，可以在需要热补的包中剔除指定的类或者包</li>
</ul>
<p>然后通过 <code>Transform</code> API 调用 <code>transform()</code> 方法，扫描所有类加入到 <code>classPool</code> 中，调用 <code>insertRobustCode()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="function">def <span class="title">insertRobustCode</span><span class="params">(List&lt;CtClass&gt; box, File jarFile)</span> </span>&#123;</div><div class="line">    ZipOutputStream outStream=<span class="keyword">new</span> JarOutputStream(<span class="keyword">new</span> FileOutputStream(jarFile));</div><div class="line">    <span class="keyword">new</span> ForkJoinPool().submit &#123;</div><div class="line">        box.each &#123; ctClass -&gt;</div><div class="line">            <span class="keyword">if</span> (isNeedInsertClass(ctClass.getName())) &#123;</div><div class="line">               <span class="comment">//将class设置为public ctClass.setModifiers(AccessFlag.setPublic(ctClass.getModifiers()))</span></div><div class="line">                <span class="keyword">boolean</span> addIncrementalChange = <span class="keyword">false</span>;</div><div class="line">                ctClass.declaredBehaviors.findAll &#123;</div><div class="line">                <span class="comment">//规避接口和无方法类</span></div><div class="line">                    <span class="keyword">if</span> (ctClass.isInterface() || ctClass.declaredMethods.length &lt; <span class="number">1</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (!addIncrementalChange) &#123;</div><div class="line">                    <span class="comment">//插入 public static ChangeQuickRedirect changeQuickRedirect;</span></div><div class="line">                        addIncrementalChange = <span class="keyword">true</span>;</div><div class="line">                        ClassPool classPool = it.declaringClass.classPool</div><div class="line">                        CtClass type = classPool.getOrNull(Constants.INTERFACE_NAME);</div><div class="line">                        CtField ctField = <span class="keyword">new</span> CtField(type, Constants.INSERT_FIELD_NAME, ctClass);</div><div class="line">                        ctField.setModifiers(AccessFlag.PUBLIC | AccessFlag.STATIC)</div><div class="line">                        ctClass.addField(ctField)</div><div class="line">                        logger.debug <span class="string">"ctClass: "</span> + ctClass.getName();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (it.getMethodInfo().isStaticInitializer()) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="comment">// synthetic 方法暂时不aop 比如AsyncTask 会生成一些同名 synthetic方法,对synthetic 以及private的方法也插入的代码，主要是针对lambda表达式</span></div><div class="line">                    <span class="keyword">if</span> ((it.getModifiers() &amp; AccessFlag.SYNTHETIC) != <span class="number">0</span> &amp;&amp; !AccessFlag.isPrivate(it.getModifiers())) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//不支持构造方法</span></div><div class="line">                    <span class="keyword">if</span> (it.getMethodInfo().isConstructor()) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//规避抽象方法</span></div><div class="line">                    <span class="keyword">if</span> ((it.getModifiers() &amp; AccessFlag.ABSTRACT) != <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//规避NATIVE方法</span></div><div class="line">                    <span class="keyword">if</span> ((it.getModifiers() &amp; AccessFlag.NATIVE) != <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//规避接口</span></div><div class="line">                    <span class="keyword">if</span> ((it.getModifiers() &amp; AccessFlag.INTERFACE) != <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (it.getMethodInfo().isMethod()) &#123;</div><div class="line">                        <span class="keyword">if</span> (AccessFlag.isPackage(it.modifiers)) &#123;</div><div class="line">                            it.setModifiers(AccessFlag.setPublic(it.modifiers))</div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">//判断是否有方法调用，返回是否插庄</span></div><div class="line">                        <span class="keyword">boolean</span> flag = modifyMethodCodeFilter(it)</div><div class="line">                        <span class="keyword">if</span> (!flag) &#123;</div><div class="line">                            <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//方法过滤</span></div><div class="line">                    <span class="keyword">if</span> (isExceptMethodLevel &amp;&amp; exceptMethodList != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">for</span> (String exceptMethod : exceptMethodList) &#123;</div><div class="line">                            <span class="keyword">if</span> (it.name.matches(exceptMethod)) &#123;</div><div class="line">                                <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (isHotfixMethodLevel &amp;&amp; hotfixMethodList != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">for</span> (String name : hotfixMethodList) &#123;</div><div class="line">                            <span class="keyword">if</span> (it.name.matches(name)) &#123;</div><div class="line">                                <span class="keyword">return</span> <span class="keyword">true</span></div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">return</span> !isHotfixMethodLevel</div><div class="line">                &#125;.each &#123; ctBehavior -&gt;</div><div class="line">                    <span class="comment">// methodMap must be put here</span></div><div class="line">                    methodMap.put(ctBehavior.longName, insertMethodCount.incrementAndGet());</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (ctBehavior.getMethodInfo().isMethod()) &#123;</div><div class="line">                            <span class="keyword">boolean</span> isStatic = ctBehavior.getModifiers() &amp; AccessFlag.STATIC;</div><div class="line">                            CtClass returnType = ctBehavior.getReturnType0();</div><div class="line">                            String returnTypeString = returnType.getName();</div><div class="line">                            def body = <span class="string">"if ($&#123;Constants.INSERT_FIELD_NAME&#125; != null) &#123;"</span></div><div class="line">                            body += <span class="string">"Object argThis = null;"</span></div><div class="line">                            <span class="keyword">if</span> (!isStatic) &#123;</div><div class="line">                                body += <span class="string">"argThis = \$0;"</span></div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            body += <span class="string">"   if (com.meituan.robust.PatchProxy.isSupport(\$args, argThis, $&#123;Constants.INSERT_FIELD_NAME&#125;, $isStatic, "</span> + methodMap.get(ctBehavior.longName) + <span class="string">")) &#123;"</span></div><div class="line">                            body += getReturnStatement(returnTypeString, isStatic, methodMap.get(ctBehavior.longName));</div><div class="line">                            body += <span class="string">"   &#125;"</span></div><div class="line">                            body += <span class="string">"&#125;"</span></div><div class="line">                            ctBehavior.insertBefore(body);</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">catch</span> (Throwable t ) &#123;</div><div class="line">                        logger.error <span class="string">"ctClass: "</span> + ctClass.getName() + <span class="string">" error: "</span> + t.toString();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                &#125;</div><div class="line">            zipFile(ctClass.toBytecode(),outStream,ctClass.name.replaceAll(<span class="string">"\\."</span>,<span class="string">"/"</span>)+<span class="string">".class"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;.get()</div><div class="line">    outStream.close();</div><div class="line">    logger.debug <span class="string">"robust insertMethodCount: "</span> + insertMethodCount.get()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法做了以下几件事：</p>
<ul>
<li>将class设置为public</li>
<li>规避 接口</li>
<li>规避 无方法类</li>
<li>规避 构造方法</li>
<li>规避 抽象方法</li>
<li>规避 native方法</li>
<li>规避 synthetic方法</li>
<li>过滤配置文件中不需要修复的类</li>
<li>通过 javassist 在类中插入 <code>public static ChangeQuickRedirect changeQuickRedirect;</code></li>
<li>通过 javassist 在方法中插入逻辑代码段</li>
<li>通过 zipFile() 方法写回class文件</li>
</ul>
<p>最后调用 <code>writeMap2File()</code> 将插桩的方法信息写入 robust/methodsMap.robust 文件中，此文件和混淆的mapping文件需要备份。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里本篇文章结束，主要讲了下基础原理、补丁加载流程和插桩过程。我们也可以简单的对 Robust 做下总结。</p>
<p>优点：</p>
<ul>
<li>由于使用多ClassLoader方案（补丁中无新增Activity，所以不算激进类型的动态加载，无需hook system），兼容性和稳定性更好，不存在preverify的问题</li>
<li>由于采用 InstantRun 的热更新机制，所以可以即时生效，不需要重启</li>
<li>支持Android2.3-7.X版本</li>
<li>对性能影响较小，不需要合成patch</li>
<li>支持方法级别的修复，支持静态方法</li>
<li>支持新增方法和类</li>
<li>支持ProGuard的混淆、内联、编译器优化后引起的问题(桥方法、lambda、内部类等)等操作</li>
</ul>
<p>当然，有优点就会有缺点：</p>
<ul>
<li>暂时不支持新增字段，但可以通过新增类解决</li>
<li>暂时不支持修复构造方法，已经在内测</li>
<li>暂时不支持资源和 so 修复，不过这个问题不大，因为独立于 dex 补丁，已经有很成熟的方案了，就看怎么打到补丁包中以及 diff 方案。</li>
<li>对于返回值是 this 的方法支持不太好</li>
<li><strong>没有安全校验，需要开发者在加载补丁之前自己做验证</strong></li>
<li>可能会出现深度方法内联导致的不可预知的错误(几率很小可以忽略)</li>
</ul>
<p>总的来说，Robust是可用的、高稳定性的、成功率很高（官方说99.9%）的、无侵入的一款优秀的热修复框架。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://tech.meituan.com/android_robust.html" target="_blank" rel="external">Android热更新方案Robust</a></li>
<li><a href="http://tech.meituan.com/android_autopatch.html" target="_blank" rel="external">Android热更新方案Robust开源，新增自动化补丁工具
</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26036302" target="_blank" rel="external">热修复框架研究之Robust原理</a></li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2017/03/31/robust-0/">http://w4lle.com/2017/03/31/robust-0/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早在16年9月份，美团技术团队就写过一篇文章描述 Android 热补丁框架Robust的简单实现原理，但是并没有开源；然后在17年3月份，美团团队宣布正式开源 Robust并且配套了自动打补丁包工具。本系列文章主要解析Robust实现原理，分为几个方面&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;补丁加载过程&lt;/li&gt;
&lt;li&gt;基础包插桩过程&lt;/li&gt;
&lt;li&gt;补丁包生成过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文为第一篇，主要讲解补丁加载过程和基础包插桩过程，分析版本 &lt;code&gt;0.3.2&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
      <category term="热补丁" scheme="http://w4lle.com/tags/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>再见，薄荷！</title>
    <link href="http://w4lle.com/2017/03/08/goodbye-boohee/"/>
    <id>http://w4lle.com/2017/03/08/goodbye-boohee/</id>
    <published>2017-03-07T16:00:00.000Z</published>
    <updated>2017-03-08T12:56:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015.3.23 - 2017.3.8 </p>
<p>两年时光，匆匆而逝。</p>
<p>来到薄荷已经两年时间，说长不长，说短不短。</p>
<a id="more"></a>
<p>两年来在公司也成长了很多，包括技术和技术以外的其他东西。</p>
<p>薄荷是很注重技术氛围的公司，我们的技术团队是我工作以来技术氛围最为浓厚的团队，具体体现在每周三晚的技术分享和每周末每人一篇的技术博客。坚持写作是薄荷长久以来的优秀传统，我之前一直在CSDN写博客，隔三差五写一篇有时候不够积极，但是从加入薄荷后写作的积极性也有了提高，个人博客从2016年搭建至今也持续写了一些文章，其中包括一些质量还不错的文章被广泛阅读，一年的时间博客也有了6w的访问量，虽然不多，对我来说也是一种激励，说明分享的东西也会对别人有用。</p>
<p>至于Android组，我们有充分自由的技术栈选择，在可用性和稳定性的前提下，都可以引入项目中使用。在这两年时间里，我也主动承担了一些基础工作，慢慢也成长为Android组的负责人，有付出就会有回报，不用着急，想要的，时光都会给你。两年时间更新了多少版本已经记不得，但是每一个版本更新都有我的付出。有过开心，有过失落，不管怎样，这段工作已经过去，付出的汗水终究没有白费。</p>
<p>要感谢stormzhang对我工作的信任和帮助，也要谢谢skykai、loody、ttdevs这些小伙伴们，是大家的工作态度让我们这个团队这么有凝聚力。每当别人问起你心中的理想团队是什么样子，我都会毫不犹豫的回答，我现在所在的团队就是我向往的团队。大家对技术的热情，工作的积极态度，团队足够open的氛围，遇到问题永不服输的精神，生活中的互相帮助，碰巧也有共同的爱好，我说这就是我理想的团队。</p>
<p>在薄荷的这两年，也完成了人生中的两件大事。结婚、生子。我很感恩。感恩有个贤惠的媳妇儿，感恩我们有健康漂亮的小jojo，自从有了jojo我们家欢笑就没断过，每天哈哈哈。男人不就是这样，妻儿老小一人扛，家庭幸福比啥都强。希望时间可以慢点走，我们的小jojo慢慢健康长大，让我们多享受小jojo成长带给我们的快乐。</p>
<p>由于个人原因离开公司，今天下午办的离职手续，临走之前，提交了最后一行代码，commit message是“Goodbye”。团队小伙伴们一直把我送到地铁站才离去，我的心里也是很多不舍，但是人生不就是这样么，天下没有不散的筵席，只能心中默念祝大家都好！</p>
<p>虽然有些不舍，但我心里更多的是对新生活的期待，期待美好的明天，期待给家人一个稳定的家，期待简单的稳稳的幸福。期待父母身体健康，期待老婆贤惠漂亮，期待jojo健康成长。期待永远年轻，永远热泪盈眶，永远相信梦想。</p>
<p>已经远去的，带着美好记忆挥挥手说声拜拜。</p>
<p>将要到来的，怀着期待张开双手迎接未来。</p>
<p>再见，薄荷。</p>
<p>你好，明天。</p>
<p>本文链接： <a href="http://w4lle.com/2017/03/08/goodbye-boohee/">http://w4lle.com/2017/03/08/goodbye-boohee/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015.3.23 - 2017.3.8 &lt;/p&gt;
&lt;p&gt;两年时光，匆匆而逝。&lt;/p&gt;
&lt;p&gt;来到薄荷已经两年时间，说长不长，说短不短。&lt;/p&gt;
    
    </summary>
    
    
      <category term="其他" scheme="http://w4lle.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Gradle模块化配置</title>
    <link href="http://w4lle.com/2017/01/22/gradle-modules/"/>
    <id>http://w4lle.com/2017/01/22/gradle-modules/</id>
    <published>2017-01-22T01:53:37.000Z</published>
    <updated>2017-01-23T00:56:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文以<a href="https://github.com/shwenzhang/AndResGuard" target="_blank" rel="external">AndResGuard</a>和<a href="https://github.com/Tencent/tinker" target="_blank" rel="external">Tinker</a>为例讲解下如何模块化配置Gradle，以及一键打Tinker补丁包的实现方法。<br><a id="more"></a></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>随着项目越来越大，引用第三方库的gradle愈来愈多，app的build.gradle文件也越来越长，拿薄荷App为例已经达到了1000行左右，一大坨代码赛在一起看起来很不爽。并且将第三方库的配置移植到新项目也很困难，稍微不注意就会出错。</p>
<h1 id="AndResGuard配置"><a href="#AndResGuard配置" class="headerlink" title="AndResGuard配置"></a>AndResGuard配置</h1><p>首先新建resguard.gradle文件，配置内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">apply plugin: <span class="string">'AndResGuard'</span></div><div class="line">andResGuard &#123;</div><div class="line">    use7zip = <span class="keyword">true</span></div><div class="line">    useSign = <span class="keyword">true</span></div><div class="line">    keepRoot = <span class="keyword">false</span></div><div class="line">    whiteList&#123;...&#125;</div><div class="line">    compressFilePattern&#123;...&#125;</div><div class="line">    sevenzip&#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在主项目的build.gradle中加入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">apply from: <span class="string">'../resguard.gradle'</span></div><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath (<span class="string">'com.tencent.mm:AndResGuard-gradle-plugin:1.1.16'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就配置好了，子Project依赖resguard脚本，sync下就能看到resguard Task了。那么移植到新项目只需要把resguard.gradle拷贝过去就ok了。</p>
<h1 id="Tinker配置"><a href="#Tinker配置" class="headerlink" title="Tinker配置"></a>Tinker配置</h1><p>由于要配合AndResGuard使用，Tinker的gradle配置相对来说复杂些，然后我又在中间插入了自动备份和多渠道打包的task，然后就可以一键打Release包和补丁包。</p>
<p>首先新建tinker.gralde文件，首先把Tinker的官方基本配置copy进来此处代码略。先看下Project的build.gradle文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">apply from: <span class="string">'../tinker.gradle'</span></div><div class="line">apply from: <span class="string">'../utils.gradle'</span></div><div class="line">dependencies &#123;</div><div class="line">    classpath (<span class="string">"com.tencent.tinker:tinker-patch-gradle-plugin:$&#123;TINKER_VERSION&#125;"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Project只需要配置这两行代码就可以了。其中的utils.gradle是一个工具脚本文件，其中有一些常用的工具方法。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//utils.gradle</span></div><div class="line">ext &#123;</div><div class="line">    releaseTime = <span class="keyword">this</span>.&amp;releaseTime</div><div class="line">    packageChannel = <span class="keyword">this</span>.&amp;packageChannel</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">def <span class="title">releaseTime</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date().format(<span class="string">"yyyy-MM-dd"</span>, TimeZone.getTimeZone(<span class="string">"UTC"</span>))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//多渠道打包，使用的美团方案</span></div><div class="line"><span class="function">def <span class="title">packageChannel</span><span class="params">(String releaseApk)</span> </span>&#123;</div><div class="line">    print <span class="string">"begin package Channel! \n "</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        def stdout = <span class="keyword">new</span> ByteArrayOutputStream()</div><div class="line">        exec &#123;</div><div class="line">            commandLine <span class="string">'python'</span>, rootProject.getRootDir().getAbsolutePath() + <span class="string">"/app/multi_build.py"</span>, releaseApk</div><div class="line">            standardOutput = stdout</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stdout.toString().trim()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (ignored) &#123;</div><div class="line">        print <span class="string">"package Channel Error! \n "</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"UnKnown"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的多渠道打包方案仍然使用的美团之前的往META-INF插入空文件的做法，是因为AndResGuard赞不支持v2签名，暂时无法使用新一代的v2签名多渠道打包方案<a href="https://github.com/Meituan-Dianping/walle" target="_blank" rel="external">walle</a>。</p>
<p>继续看tinker.gradle，首先需要配置依赖库和打包时的插入代码比如版本号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    defaultConfig &#123;</div><div class="line">        <span class="comment">//每次发补丁需要更改此处 增加patch版本号。升级app 版本要还原0.0</span></div><div class="line">        buildConfigField <span class="string">"String"</span>, <span class="string">"PATCH_VERSION"</span>, <span class="string">"\"0.0\""</span></div><div class="line">        buildConfigField <span class="string">"String"</span>, <span class="string">"PLATFORM"</span>, <span class="string">"\"all\""</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    provided(<span class="string">"com.tencent.tinker:tinker-android-anno:$&#123;cfg.TINKER_VERSION&#125;"</span>)</div><div class="line">    compile(<span class="string">"com.tencent.tinker:tinker-android-lib:$&#123;cfg.TINKER_VERSION&#125;"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样配置完Tinker就可以可用了，然后我们要处理和AndResGuard配置使用以及自动备份自动打渠道包，步骤如下：</p>
<ol>
<li>使用resguard打正式包后需要备份apk、R、mapping、Resource mapping；并且打渠道包</li>
<li>打补丁包需要自动填入resguard新打出包的路径buildApkPath，apk、R、mapping、Resource mapping文件的对应路径。</li>
<li>打补丁包时resguard新打出的包不需要备份</li>
<li>需要区分debug和release切换备份路径</li>
</ol>
<p>对应以上几点，给出关键代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div></pre></td><td class="code"><pre><div class="line">def cfg = rootProject.ext</div><div class="line">def bakPath = file(<span class="string">"$&#123;buildDir.parent&#125;/tinkerBackup/"</span>)</div><div class="line">def bakResguard = file(<span class="string">"$&#123;bakPath&#125;"</span>)</div><div class="line">def debugBakPath = file(<span class="string">"$&#123;buildDir.absolutePath&#125;/tinkerBackup"</span>)</div><div class="line">ext &#123;</div><div class="line">    appName = <span class="string">"nicepro"</span></div><div class="line">    ...</div><div class="line">    省略tinker配置</div><div class="line">&#125;</div><div class="line">    def isNeedBackup = <span class="keyword">true</span></div><div class="line">    task AtinkerPatchPrepare &lt;&lt; &#123;</div><div class="line">        isNeedBackup = <span class="keyword">false</span></div><div class="line">        def backUpVersion = <span class="string">""</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">new</span> File(<span class="string">"$&#123;bakResguard&#125;/version.txt"</span>).exists()) &#123;</div><div class="line">            backUpVersion = <span class="keyword">new</span> File(<span class="string">"$&#123;bakResguard&#125;/version.txt"</span>).getText()</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!backUpVersion.isEmpty()) &#123;</div><div class="line">            print <span class="string">"app version : + $&#123;backUpVersion&#125; \n"</span></div><div class="line">            project.tinkerPatch.oldApk = <span class="string">"$&#123;bakResguard&#125;/$&#123;backUpVersion&#125;.apk"</span></div><div class="line">            project.tinkerPatch.buildConfig.applyResourceMapping = <span class="string">"$&#123;bakResguard&#125;/$&#123;backUpVersion&#125;_R.txt"</span></div><div class="line">            project.andResGuard.mappingFile = file(<span class="string">"$&#123;bakResguard&#125;/resource_mapping_$&#123;backUpVersion&#125;.txt"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * bak apk and mapping</div><div class="line">     */</div><div class="line">    android.applicationVariants.all &#123; variant -&gt;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * task type, you want to bak</div><div class="line">         */</div><div class="line">        def taskName = <span class="string">'release'</span></div><div class="line"><span class="comment">//        def taskName = 'debug'</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (taskName.equals(<span class="string">"debug"</span>)) &#123;</div><div class="line">            bakResguard = file(<span class="string">"$&#123;buildDir.absolutePath&#125;/tinkerBackup"</span>)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        tasks.all &#123;</div><div class="line">            <span class="keyword">if</span> (variant.buildType.name == taskName) &#123;</div><div class="line"></div><div class="line">                def backUpVersion = <span class="string">""</span></div><div class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> File(<span class="string">"$&#123;bakResguard&#125;/version.txt"</span>).exists()) &#123;</div><div class="line">                    backUpVersion = <span class="keyword">new</span> File(<span class="string">"$&#123;bakResguard&#125;/version.txt"</span>).getText()</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (<span class="string">"tinkerPatch$&#123;taskName.capitalize()&#125;"</span>.equalsIgnoreCase(it.name)) &#123;</div><div class="line">                    def resguardTask</div><div class="line">                    tasks.all &#123;</div><div class="line">                        <span class="keyword">if</span> (it.name.equalsIgnoreCase(<span class="string">"resguard$&#123;taskName.capitalize()&#125;"</span>)) &#123;</div><div class="line">                            resguardTask = it</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    it.doFirst(&#123;</div><div class="line">                        <span class="comment">// change build apk path</span></div><div class="line">                        it.buildApkPath = <span class="string">"$&#123;buildDir&#125;/outputs/apk/AndResGuard_$&#123;appName&#125;_$&#123;cfg.versionName&#125;_$&#123;releaseTime()&#125;/$&#123;appName&#125;_$&#123;cfg.versionName&#125;_$&#123;releaseTime()&#125;_signed_7zip_aligned.apk"</span></div><div class="line">                        project.android.ext.tinkerOldApkPath = <span class="string">"$&#123;bakResguard&#125;/$&#123;backUpVersion&#125;.apk"</span></div><div class="line">                        project.android.ext.tinkerApplyResourcePath = <span class="string">"$&#123;bakResguard&#125;/$&#123;backUpVersion&#125;_R.txt"</span></div><div class="line">                    &#125;)</div><div class="line">                    it.dependsOn AtinkerPatchPrepare</div><div class="line">                    it.dependsOn resguardTask</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (<span class="string">"resguard$&#123;taskName.capitalize()&#125;"</span>.equalsIgnoreCase(it.name)) &#123;</div><div class="line">                    <span class="keyword">if</span> (!backUpVersion.isEmpty() &amp;&amp; <span class="keyword">new</span> File(<span class="string">"$&#123;backUpVersion&#125;_mapping.txt"</span>).exists()) &#123;</div><div class="line">                        ext.andResMappingFile = <span class="keyword">new</span> File(<span class="string">"$&#123;backUpVersion&#125;_mapping.txt"</span>)</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        ext.andResMappingFile = <span class="keyword">null</span></div><div class="line">                    &#125;</div><div class="line">                    it.doLast &#123;</div><div class="line">                        <span class="keyword">if</span> (!isNeedBackup) &#123;</div><div class="line">                            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">                        &#125;</div><div class="line">                        def date = <span class="keyword">new</span> Date().format(<span class="string">"MMdd-HH-mm-ss"</span>)</div><div class="line">                        def orgAndresPrefix = <span class="string">"AndResGuard_$&#123;appName&#125;_$&#123;cfg.versionName&#125;_$&#123;releaseTime()&#125;"</span></div><div class="line">                        def orgApkPrefix = <span class="string">"$&#123;appName&#125;_$&#123;cfg.versionName&#125;_$&#123;releaseTime()&#125;"</span></div><div class="line">                        def targetApkPrefix = <span class="string">"$&#123;appName&#125;_$&#123;taskName.capitalize()&#125;_$&#123;cfg.versionName&#125;_$&#123;date&#125;"</span></div><div class="line"></div><div class="line">                        <span class="comment">//backUpVersion</span></div><div class="line">                        File version = <span class="keyword">new</span> File(<span class="string">"$&#123;bakResguard&#125;/version.txt"</span>)</div><div class="line">                        <span class="keyword">if</span> (!version.parentFile.exists()) &#123;</div><div class="line">                            version.parentFile.mkdir()</div><div class="line">                        &#125;</div><div class="line">                        version.write(<span class="string">"$&#123;targetApkPrefix&#125;"</span>)</div><div class="line"></div><div class="line">                        copy &#123;</div><div class="line">                            from <span class="string">"$&#123;buildDir&#125;/outputs/apk/$&#123;orgAndresPrefix&#125;/$&#123;orgApkPrefix&#125;_signed_7zip_aligned.apk"</span></div><div class="line">                            <span class="function">into <span class="title">file</span><span class="params">(bakResguard.absolutePath)</span></span></div><div class="line">                            rename &#123; String fileName -&gt;</div><div class="line">                                <span class="keyword">try</span> &#123;</div><div class="line">                                    fileName.replace(<span class="string">"$&#123;orgApkPrefix&#125;_signed_7zip_aligned.apk"</span>, <span class="string">"$&#123;targetApkPrefix&#125;.apk"</span>)</div><div class="line">                                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                                    print <span class="string">"rename apk mapping error"</span></div><div class="line">                                    e.printStackTrace()</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                            from <span class="string">"$&#123;buildDir&#125;/outputs/mapping/$&#123;taskName&#125;/mapping.txt"</span></div><div class="line">                            <span class="function">into <span class="title">file</span><span class="params">(bakResguard.absolutePath)</span></span></div><div class="line">                            rename &#123; String fileName -&gt;</div><div class="line">                                fileName.replace(<span class="string">"mapping.txt"</span>, <span class="string">"$&#123;targetApkPrefix&#125;_mapping.txt"</span>)</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            from <span class="string">"$&#123;buildDir&#125;/intermediates/symbols/$&#123;taskName&#125;/R.txt"</span></div><div class="line">                            <span class="function">into <span class="title">file</span><span class="params">(bakResguard.absolutePath)</span></span></div><div class="line">                            rename &#123; String fileName -&gt;</div><div class="line">                                fileName.replace(<span class="string">"R.txt"</span>, <span class="string">"$&#123;targetApkPrefix&#125;_R.txt"</span>)</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            from <span class="string">"$&#123;buildDir&#125;/outputs/apk/$&#123;orgAndresPrefix&#125;/resource_mapping_$&#123;orgApkPrefix&#125;.txt"</span></div><div class="line">                            <span class="function">into <span class="title">file</span><span class="params">(bakResguard.absolutePath)</span></span></div><div class="line">                            rename &#123; String fileName -&gt;</div><div class="line">                                <span class="keyword">try</span> &#123;</div><div class="line">                                    fileName.replace(<span class="string">"resource_mapping_$&#123;orgApkPrefix&#125;.txt"</span>, <span class="string">"resource_mapping_$&#123;targetApkPrefix&#125;.txt"</span>)</div><div class="line">                                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                                    print <span class="string">"rename resource mapping error"</span></div><div class="line">                                    e.printStackTrace()</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                            print <span class="string">"one resguard backup tinker base apk ok! \n"</span></div><div class="line">                        &#125;</div><div class="line">                        packageChannel(<span class="string">"$&#123;buildDir&#125;/outputs/apk/$&#123;orgAndresPrefix&#125;/$&#123;orgApkPrefix&#125;_signed_7zip_aligned.apk"</span>)</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>配置完成。发补丁包只需执行<code>./gradlew resguardRelease</code>便会打出多渠道包以及备份tinker需要的文件。</p>
<p>打tinker补丁不需要手动填依赖文件，包只需执行<code>./gradlew tinkerProcessRelease</code>。</p>
<p>正好现在并行三个项目，移植过程很快，copy两个gradle配置文件就搞定了。app的build.gradle代码也只有不到200行。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p> <a href="http://blog.csdn.net/innost/article/details/48228651" target="_blank" rel="external">深入理解Android之Gradle</a></p>
<p>本文链接： <a href="http://w4lle.com/2017/01/22/gradle-modules/">http://w4lle.com/2017/01/22/gradle-modules/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文以&lt;a href=&quot;https://github.com/shwenzhang/AndResGuard&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AndResGuard&lt;/a&gt;和&lt;a href=&quot;https://github.com/Tencent/tinker&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Tinker&lt;/a&gt;为例讲解下如何模块化配置Gradle，以及一键打Tinker补丁包的实现方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Things初探</title>
    <link href="http://w4lle.com/2017/01/06/AndroidThings-0/"/>
    <id>http://w4lle.com/2017/01/06/AndroidThings-0/</id>
    <published>2017-01-06T09:26:47.000Z</published>
    <updated>2017-01-08T08:57:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Android Things是Google推出的全新物联网操作系统<br><a id="more"></a><br>前身是去年发布的物联网平台 Brillo。Brillo 使用 C/C++ 基于 NDK 进行开发，而Android Things使用JAVA、Android Studio、Android SDK、NDK等进行开发，另外还新增了名为<code>Things Support Library</code>的库这个库有两个主要功能：通过多种协议和接口（GPIO、PWM、I2C、SPI、UART等）访问传感器和执行器的外围I/O API；以及一个用户驱动API（User Driver API），可以给应用程序添加新的设备驱动，用于将硬件事件注入系统，使它们可以为应用程序所用。还有，Android Things 天生支持物联网通讯协议 Weave，可让所有类型的设备能够连上云端并与其他服务如 Google Assistant 交互。Android Things目前支持三种硬件平台：Intel Edison、NXP Pico、Raspberry Pi 3。</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/things0.png" alt=""></p>
<p>简单来说，通过Android Things，开发者可以像开发Android应用一样简单地控制硬件设备。</p>
<h1 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h1><p>硬件平台选择了树莓派3，需要准备的硬件设备：</p>
<ul>
<li>树莓派3开发板一个</li>
<li>SD卡一张，我买的32G</li>
<li>USB插口线一条</li>
<li>HDMI视频输出线一条</li>
<li>显示器一台</li>
<li>有线鼠标一个</li>
<li>LED灯2个</li>
<li>杜邦线若干条</li>
<li>网线一条</li>
</ul>
<p>然后准备把从官网下载解压好的img文件烧入SD卡，步骤参考<a href="https://developer.android.com/things/hardware/developer-kits.html" target="_blank" rel="external">官网</a>和<a href="https://www.raspberrypi.org/documentation/installation/installing-images/mac.md" target="_blank" rel="external">树莓派官网</a>，我按照官网操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo dd bs=1m if=iot_rpi3.img of=/dev/disk2</div></pre></td></tr></table></figure>
<p>提示<code>Resource busy</code>，<a href="http://raspberrypi.stackexchange.com/questions/9217/resource-busy-error-when-using-dd-to-copy-disk-img-to-sd-card" target="_blank" rel="external">解决方案</a>如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">df -h</div><div class="line">sudo diskutil unmount /dev/disk2s1</div><div class="line">sudo dd bs=<span class="number">1</span>m <span class="keyword">if</span>=iot_rpi3.img of=/dev/rdisk2</div></pre></td></tr></table></figure>
<p>烧好后把SD卡插入开发板的卡槽里，USB线连电脑，HDMI连显示器。然后通电开机。</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/things1.jpg" alt=""><br><img src="http://7xs23g.com1.z0.glb.clouddn.com/things2.jpg" alt=""></p>
<p>看到这个界面就启动好了，实际上这个界面就是Android应用Launcher的一个Activity IoTLauncher。IoT(Internet of Things)物联网的简称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ code &gt;adb shell dumpsys activity | grep <span class="string">"mFocusedActivity"</span></div><div class="line">  mFocusedActivity: ActivityRecord&#123;a7148f7 u0 com.android.iotlauncher/.IoTLauncher t1&#125;</div></pre></td></tr></table></figure>
<p>然后插网线，内网IP会显示在Launcher界面，然后用adb连接开发板，连wifi</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">adb connect 192.168.1.143</div><div class="line">adb shell am startservice \\n    </div><div class="line">-n com.google.wifisetup/.WifiSetupService \\n    </div><div class="line">-a WifiSetupService.Connect \\n</div><div class="line">-e ssid ssid \\n</div><div class="line">-e passphrase ***</div><div class="line">adb shell ping 8.8.8.8</div></pre></td></tr></table></figure>
<h1 id="连接led灯"><a href="#连接led灯" class="headerlink" title="连接led灯"></a>连接led灯</h1><p>根据demo给的图连接led灯</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/rpi3_schematics.png" alt=""></p>
<p>这张图给出了两根线一个插地线，一个插绿色的GPIO。<br>这里放上一张图展示了树莓派上对应的针脚类型和name，接下来的操作led需要name才能控制。</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/gpio.png" alt=""></p>
<h1 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h1><p>官网提供了几个Sample，我们下载下来然后运行第一个Sample-Blink。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">PeripheralManagerService service = <span class="keyword">new</span> PeripheralManagerService();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    mLedGpio = service.openGpio(<span class="string">"BCM5"</span>);</div><div class="line">    mLedGpio.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW);</div><div class="line">&#125; <span class="keyword">catch</span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>openGpio方法中的参数就是上面提到的针脚对应的name。程序跑起来之后就可以看到每隔一秒led闪一下，挺有意思。</p>
<p>我们稍微改造下，写一个xml文件中有一个button，每次点击button控制led灯的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">findViewById(R.id.btn_blink).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mLedGpio.setValue(!mLedGpio.getValue());</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>外接鼠标，每点一下button改变一下led的亮灭。<br>然后再改下，插两个led灯，第二个在BCM21 <code>mLedGpio2 = service.openGpio(&quot;BCM21&quot;);</code><br>然后每隔1s控制两个灯的状态取反。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mLedGpio2.setValue(mLedGpio.getValue());</div><div class="line">mLedGpio.setValue(!mLedGpio.getValue());</div></pre></td></tr></table></figure>
<p>效果如图，gif压缩太严重，凑合看吧。<br><img src="http://7xs23g.com1.z0.glb.clouddn.com/things3.gif" alt=""></p>
<p>对于开发者来说，通过Android Things控制硬件真的感觉跟开发一款Android App没有太大什么区别，同样的开发工具，同样的开发环境，甚至SDK大于24的Andriod App同样可以安装运行在Android Things系统上；而对于NDK开发，跟Android上也是一模一样。</p>
<h1 id="Android-Everywhere"><a href="#Android-Everywhere" class="headerlink" title="Android Everywhere"></a>Android Everywhere</h1><p>还记得RoyLi在做的名为Ruff的物联网平台，RoyLi是这样介绍它的</p>
<blockquote>
<p> Ruff 让不会做硬件的软件工程师根据产品经理的创意编写应用，(软件工程师)不用关心底层实现和驱动移植问题，通过开发者建立的应用生态最终解决物联网软件落后的问题。<br>Ruff的目的就是要做物联网领域的Android平台，采用比较流行的JavaScript作为编程语言直接操作硬件。</p>
</blockquote>
<p>而现在Android Things已经移植到了物联网领域，Google的野心也可见一斑，其对于像Ruff这样的创业项目的冲击也可想而知。放一张2015年Google I/O大会上的旧图</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/google_to.png" alt=""></p>
<p>Android有庞大的开发者支持，完善的开发工具配套，也许Android真的可以做到连接万物的可能，Android在不远的未来真的可能无处不在，乘此东风，Android开发者也可大有可为。</p>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p>说到物联网就不得不说安全，在软件层面盗个号，个人信息被窃取可能感觉问题不大，但是对于联网的硬件来说就很可怕了，比如说门锁被破解，你家的煤气被远程控制，半夜你家电视突然响了，就问你怕不怕。</p>
<p>Google既然想统一IoT标准，那么IoT的安全性必须重视，因为在标准未统一之前破解某一款硬件设备性意义不大，而标准统一之后，只要破解这个平台就搞定了一切。真心希望Google可以做到让人满意的安全性。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://developer.android.com/things/hardware/index.html" target="_blank" rel="external">Android Things</a><br><a href="https://github.com/androidthings" target="_blank" rel="external">Android Things Sample</a><br><a href="http://www.jianshu.com/nb/3704305" target="_blank" rel="external">ttdevs的树莓派专题</a></p>
<p>本文链接： <a href="http://w4lle.com/2017/01/06/AndroidThings-0/">http://w4lle.com/2017/01/06/AndroidThings-0/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Android Things是Google推出的全新物联网操作系统&lt;br&gt;
    
    </summary>
    
    
      <category term="Android Things" scheme="http://w4lle.com/tags/Android-Things/"/>
    
  </entry>
  
  <entry>
    <title>一键接入Tinker</title>
    <link href="http://w4lle.com/2017/01/05/one-key-for-tinker/"/>
    <id>http://w4lle.com/2017/01/05/one-key-for-tinker/</id>
    <published>2017-01-05T06:15:49.000Z</published>
    <updated>2018-02-05T01:32:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Tinker开源挺长时间了，使用的开发者也越来越多，对于一些小白开发者来说对接Tinker的成本还是挺高的，其中主要因素还是不能理解为什么Application要修改成ApplicationLike，以及改造后对项目中使用Application的地方也要同步修改。</p>
<p>在上篇文章<a href="http://w4lle.github.io/2016/12/16/tinker/" target="_blank" rel="external">Android热补丁之Tinker原理解析</a>中我们已经讲解了这样做的目的以及Tinker的加载补丁的流程，本篇文章主要讲一下一键接入Tinker的实现思路。</p>
<h1 id="InstantRun"><a href="#InstantRun" class="headerlink" title="InstantRun"></a>InstantRun</h1><p>我们的目的是要实现不修改Application达到替换Application的效果，在这篇文章<a href="http://w4lle.github.io/2016/05/02/%E4%BB%8EInstant%20run%E8%B0%88Android%E6%9B%BF%E6%8D%A2Application%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">从Instant run谈Android替换Application和动态加载机制</a>中，详细讲述了如何动态替换Application，总结起来就两步：</p>
<ol>
<li>打包时替换Application标签，插入BootstrapApplication</li>
<li>运行时hook系统api，将BootstrapApplication换回MyApplication</li>
</ol>
<p>那么，我们依然可以用这套方案来实现Tinker的一键接入，动态替换Application。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>有了思路我们就可以敲代码了。</p>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>打包时我们要改变Manifest中Application的标签值，可以通过自定义Gradle插件来实现，关键代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@TaskAction</span></div><div class="line">    <span class="function">def <span class="title">updateManifest</span><span class="params">()</span> </span>&#123;</div><div class="line">        def ns = <span class="keyword">new</span> Namespace(<span class="string">"http://schemas.android.com/apk/res/android"</span>, <span class="string">"android"</span>)</div><div class="line">        def xml = <span class="keyword">new</span> XmlParser().parse(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(manifestPath), <span class="string">"utf-8"</span>))</div><div class="line"></div><div class="line">        def application = xml.application[<span class="number">0</span>]</div><div class="line">        <span class="keyword">if</span> (application) &#123;</div><div class="line">            def metaDataTags = application[<span class="string">'meta-data'</span>]</div><div class="line"></div><div class="line">            String rawApplicationName = application.attributes()[ns.name]</div><div class="line">            metaDataTags.findAll &#123;</div><div class="line">                it.attributes()[ns.name].equals(TINKER_APPLICATION)</div><div class="line">            &#125;.each &#123;</div><div class="line">                it.parent().remove(it)</div><div class="line">            &#125;</div><div class="line">            application.appendNode(<span class="string">'meta-data'</span>, [(ns.name): TINKER_APPLICATION, (ns.value): rawApplicationName])</div><div class="line">            application.attributes()[ns.name] = TINKER_APPLICATION_VALUE</div><div class="line"></div><div class="line">            def printer = <span class="keyword">new</span> XmlNodePrinter(<span class="keyword">new</span> PrintWriter(manifestPath, <span class="string">"utf-8"</span>))</div><div class="line">            printer.preserveWhitespace = <span class="keyword">true</span></div><div class="line">            printer.print(xml)</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>打包出的apk中的AndroidManifest.xml文件基本是这样的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;application android:name="com.w4lle.onekeytinker.BootstrapApplication"&gt;</div><div class="line">    ...</div><div class="line">    &lt;meta-data android:name="ONEKEY_TINKER_APPLICATION" android:value="com.w4lle.onekeytinker.App"/&gt;</div><div class="line">  &lt;/application&gt;</div></pre></td></tr></table></figure>
<p>其中的App是项目中原有的Application，BootstrapApplication是后期我们插入的Application。自定义Gradle插件时可以封装一个Extension配置参数，把Tinker的相关配置封装起来，一些不变的默认配置项都可以写到里面，这样项目的gradle配置可以更简洁。另外说一句，这个Gradle插件的顺序应该是打包工具生成Manifest之后，Tinker相关Task之前。</p>
<h2 id="运行时替换Application"><a href="#运行时替换Application" class="headerlink" title="运行时替换Application"></a>运行时替换Application</h2><p>这一步的主要工作也是分两步，第一就是解析Manifest文件，拿到realApplication(App)和BootstrapApplication；然后hook 系统完成替换。</p>
<p>InstantRun中的替换实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">monkeyPatchApplication</span><span class="params">(@Nullable Context context,</span></span></div><div class="line">                                              @Nullable Application bootstrap,</div><div class="line">                                              @Nullable Application realApplication) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// Find the ActivityThread instance for the current thread</span></div><div class="line">            Class&lt;?&gt; activityThread = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</div><div class="line">            Object currentActivityThread = getActivityThread(context, activityThread);</div><div class="line"></div><div class="line">            <span class="comment">// Find the mInitialApplication field of the ActivityThread to the real application</span></div><div class="line">            Field mInitialApplication = activityThread.getDeclaredField(<span class="string">"mInitialApplication"</span>);</div><div class="line">            mInitialApplication.setAccessible(<span class="keyword">true</span>);</div><div class="line">            Application initialApplication = (Application) mInitialApplication.get(currentActivityThread);</div><div class="line">            <span class="keyword">if</span> (realApplication != <span class="keyword">null</span> &amp;&amp; initialApplication == bootstrap) &#123;</div><div class="line">            <span class="comment">//**2.替换掉ActivityThread.mInitialApplication**</span></div><div class="line">                mInitialApplication.set(currentActivityThread, realApplication);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Replace all instance of the stub application in ActivityThread#mAllApplications with the</span></div><div class="line">            <span class="comment">// real one</span></div><div class="line">            <span class="keyword">if</span> (realApplication != <span class="keyword">null</span>) &#123;</div><div class="line">                Field mAllApplications = activityThread.getDeclaredField(<span class="string">"mAllApplications"</span>);</div><div class="line">                mAllApplications.setAccessible(<span class="keyword">true</span>);</div><div class="line">                List&lt;Application&gt; allApplications = (List&lt;Application&gt;) mAllApplications</div><div class="line">                        .get(currentActivityThread);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; allApplications.size(); i++) &#123;</div><div class="line">                    <span class="keyword">if</span> (allApplications.get(i) == bootstrap) &#123;</div><div class="line">                    <span class="comment">//**1.替换掉ActivityThread.mAllApplications**</span></div><div class="line">                        allApplications.set(i, realApplication);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Figure out how loaded APKs are stored.</span></div><div class="line"></div><div class="line">            <span class="comment">// API version 8 has PackageInfo, 10 has LoadedApk. 9, I don't know.</span></div><div class="line">            Class&lt;?&gt; loadedApkClass;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                loadedApkClass = Class.forName(<span class="string">"android.app.LoadedApk"</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">                loadedApkClass = Class.forName(<span class="string">"android.app.ActivityThread$PackageInfo"</span>);</div><div class="line">            &#125;</div><div class="line">            Field mApplication = loadedApkClass.getDeclaredField(<span class="string">"mApplication"</span>);</div><div class="line">            mApplication.setAccessible(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 10 doesn't have this field, 14 does. Fortunately, there are not many Honeycomb devices</span></div><div class="line">            <span class="comment">// floating around.</span></div><div class="line">            Field mLoadedApk = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                mLoadedApk = Application.class.getDeclaredField(<span class="string">"mLoadedApk"</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</div><div class="line">                <span class="comment">// According to testing, it's okay to ignore this.</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Enumerate all LoadedApk (or PackageInfo) fields in ActivityThread#mPackages and</span></div><div class="line">            <span class="comment">// ActivityThread#mResourcePackages and do two things:</span></div><div class="line">            <span class="comment">//   - Replace the Application instance in its mApplication field with the real one</span></div><div class="line">            <span class="comment">//   - Set Application#mLoadedApk to the found LoadedApk instance</span></div><div class="line">            <span class="keyword">for</span> (String fieldName : <span class="keyword">new</span> String[]&#123;<span class="string">"mPackages"</span>, <span class="string">"mResourcePackages"</span>&#125;) &#123;</div><div class="line">                Field field = activityThread.getDeclaredField(fieldName);</div><div class="line">                field.setAccessible(<span class="keyword">true</span>);</div><div class="line">                Object value = field.get(currentActivityThread);</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, WeakReference&lt;?&gt;&gt; entry :</div><div class="line">                        ((Map&lt;String, WeakReference&lt;?&gt;&gt;) value).entrySet()) &#123;</div><div class="line">                    Object loadedApk = entry.getValue().get();</div><div class="line">                    <span class="keyword">if</span> (loadedApk == <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (mApplication.get(loadedApk) == bootstrap) &#123;</div><div class="line">                        <span class="keyword">if</span> (realApplication != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">//**3.替换掉mApplication**</span></div><div class="line">                            mApplication.set(loadedApk, realApplication);</div><div class="line">                        &#125;</div><div class="line">                        </div><div class="line">                        <span class="keyword">if</span> (realApplication != <span class="keyword">null</span> &amp;&amp; mLoadedApk != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">//**4.替换掉mLoadedApk**</span></div><div class="line">                            mLoadedApk.set(realApplication, loadedApk);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>主要做了两件事：</p>
<ol>
<li>替换Application<ul>
<li>baseContext.mPackageInfo.mApplication 代码3处</li>
<li>baseContext.mPackageInfo.mActivityThread.mInitialApplication 代码2处</li>
<li>baseContext.mPackageInfo.mActivityThread.mAllApplications 代码1处</li>
</ul>
</li>
<li>替换mLoadedApk对象，代码4处</li>
</ol>
<p>详细请查看<a href="http://w4lle.github.io/2016/05/02/%E4%BB%8EInstant%20run%E8%B0%88Android%E6%9B%BF%E6%8D%A2Application%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">从Instant run谈Android替换Application和动态加载机制</a></p>
<p>做完上面这两步这样就可以实现一键接入了。</p>
<h1 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h1><p>在上篇文章中我们提到，由于该方案大量hook系统api，在国内Android碎片化如此严重的市场环境下，该方案兼容性有一些问题，大概有 1/1w的概率会出现替换失败的问题，如果替换失败，那么在系统中运行的Application还是BootstrapApplication，而我们App中的Application已经没有了Application的生命周期和作用。</p>
<p>所以我们要在失败catch中调用下Application的生命周期方法以保证程序能够正常初始化启动起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  ...</div><div class="line">&#125; <span class="keyword">catch</span> &#123;</div><div class="line">  e = <span class="keyword">true</span>;</div><div class="line">  realApplication.onCreate();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration paramConfiguration)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (e &amp;&amp; realApplication != <span class="keyword">null</span>) &#123;</div><div class="line">    realApplication.onConfigurationChanged(paramConfiguration);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">super</span>.onConfigurationChanged(paramConfiguration);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLowMemory</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (e &amp;&amp; realApplication != <span class="keyword">null</span>) &#123;</div><div class="line">    realApplication.onLowMemory();</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">super</span>.onLowMemory();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@TargetApi</span>(<span class="number">14</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> paramInt)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (e &amp;&amp; realApplication != <span class="keyword">null</span>) &#123;</div><div class="line">    realApplication.onTrimMemory(paramInt);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">super</span>.onTrimMemory(paramInt);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTerminate</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (e &amp;&amp; realApplication != <span class="keyword">null</span>) &#123;</div><div class="line">    realApplication.onTerminate();</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">super</span>.onTerminate();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这么做虽然能保证App能启动，但是实际上还会有隐性问题存在。比如App中有如下代码<code>((App) getApplication()).xxx();</code>，那么在替换失败的情况下可能就会崩了， 因为<code>getApplication()</code>得到的是BootstrapApplication，强转为<code>App</code>类型肯定就挂了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整体思路大概讲清楚了，虽然这种方案接入成本低，但是兼容性问题是个很麻烦的事情，说不定啥时候就崩了。推荐大家还是使用Tinker自有的接入方案。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://w4lle.github.io/2016/05/02/%E4%BB%8EInstant%20run%E8%B0%88Android%E6%9B%BF%E6%8D%A2Application%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">从Instant run谈Android替换Application和动态加载机制</a><br><a href="http://www.tinkerpatch.com/" target="_blank" rel="external">TinkerPatch</a></p>
<p>本文链接： <a href="http://w4lle.com/2017/01/05/one-key-for-tinker/">http://w4lle.com/2017/01/05/one-key-for-tinker/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Tinker开源挺长时间了，使用的开发者也越来越多，对于一些小白开发者来说对接Tinker的成本还是挺高的，其中主要因素还是不能理解为什么A
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
      <category term="热补丁" scheme="http://w4lle.com/tags/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>Android热补丁之Tinker原理解析</title>
    <link href="http://w4lle.com/2016/12/16/tinker/"/>
    <id>http://w4lle.com/2016/12/16/tinker/</id>
    <published>2016-12-16T01:49:06.000Z</published>
    <updated>2017-03-08T02:17:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Tinker系列文章：</p>
<ul>
<li><a href="http://w4lle.github.io/2016/12/16/tinker/" target="_blank" rel="external">Android热补丁之Tinker原理解析</a></li>
<li><a href="http://w4lle.github.io/2017/01/05/one-key-for-tinker/" target="_blank" rel="external">一键接入Tinker</a></li>
<li><a href="http://w4lle.github.io/2017/01/22/gradle-modules/" target="_blank" rel="external">Gradle模块化配置</a></li>
</ul>
<p>本文是第一篇。</p>
<blockquote>
<p>本文分析版本  <a href="https://github.com/Tencent/tinker/tree/93ecc9351367badc02a91fac25764bee50e6e6a6" target="_blank" rel="external">93ecc9351367badc02a91fac25764bee50e6e6a6</a><br>项目地址： <a href="https://github.com/Tencent/tinker/" target="_blank" rel="external">Tinker</a></p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在今年的MDCC大会上，微信开发团队宣布正式开源Tinker，在这之前微信团队已经发出过一些Tinker的相关文章，说实话在开源之前我们还是相当期待Tinker开源的，一方面是因为之前使用的热补丁一直存在一些兼容性问题，另一方面也好奇Tinker的实现方案。</p>
<a id="more"></a>
<p>在开源后我们团队第一时间着手研究Tinker，在详细阅读了源码之后，我们确定要在之后的一个版本集成Tinker上线，线上效果显示Tinker的修复效果果然牛逼，错误率明显下降的同时也没有报出兼容性的问题。附一张薄荷app使用Tinker修复前后的错误率对比。</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/fatal.png" alt=""></p>
<h1 id="从接入Tinker入手"><a href="#从接入Tinker入手" class="headerlink" title="从接入Tinker入手"></a>从接入Tinker入手</h1><p>想要深入某个框架，前提是要学会使用它。我们就从Tinker的接入入手一步一步解开它的实现原理。参照<a href="https://github.com/Tencent/tinker/wiki" target="_blank" rel="external">wiki</a>我们做了如下操作。</p>
<p>实现一个Application</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneApplicationForTinker</span> <span class="keyword">extends</span> <span class="title">TinkerApplication</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneApplicationForTinker</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(</div><div class="line">                <span class="comment">//tinkerFlags, tinker支持的类型，dex,library，还是全部都支持！</span></div><div class="line">                ShareConstants.TINKER_ENABLE_ALL,</div><div class="line">                <span class="comment">//ApplicationLike的实现类，只能传递字符串,不能使用class.getName()</span></div><div class="line">                <span class="string">"com.boohee.one.MyApplication"</span>,</div><div class="line">                <span class="comment">//加载Tinker的主类名，对于特殊需求可能需要使用自己的加载类。需要注意的是：</span></div><div class="line">                <span class="comment">//这个类以及它使用的类都是不能被补丁修改的，并且我们需要将它们加到dex.loader[]中。</span></div><div class="line">                <span class="comment">//一般来说，我们使用默认即可。</span></div><div class="line">                <span class="string">"com.tencent.tinker.loader.TinkerLoader"</span>,</div><div class="line">                <span class="comment">//由于合成过程中我们已经校验了各个文件的Md5，并将它们存放在/data/data/..目录中。</span></div><div class="line">                <span class="comment">// 默认每次加载时我们并不会去校验tinker文件的Md5,但是你也可通过开启loadVerifyFlag强制每次加载时校验，</span></div><div class="line">                <span class="comment">// 但是这会带来一定的时间损耗。</span></div><div class="line">                <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的几个参数做了详细说明，Tinker其实提供了注解的方式生成该类，但是我们为了更清楚的了解Tinker的原理，所以并没有使用注解。</p>
<p>然后在<code>AndroidManifest.xml</code>中声明该类为<code>application</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">&lt;application</div><div class="line">        android:name=".tinker.OneApplicationForTinker"</div><div class="line">        ...</div><div class="line">&lt;/application&gt;</div></pre></td></tr></table></figure>
<p>那我们就知道了，app的入口Application就是该类，该类继承自TinkerApplication。然后我们项目中的MyApplication继承自ApplicationLike，其实看到这里，就大概猜到了OneApplicationForTinker可能是一个代理，App中的Application的真正实现还是MyApplication。</p>
<h1 id="Application的替换"><a href="#Application的替换" class="headerlink" title="Application的替换"></a>Application的替换</h1><p>为了做分析前的铺垫，我们从最开始的接入入手，实现了OneApplicationForTinker，继承自TinkerApplication。我们继续往下看。<br>看下TinkerApplication的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TinkerApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TinkerApplication</span><span class="params">(<span class="keyword">int</span> tinkerFlags, String delegateClassName,</span></span></div><div class="line">                                String loaderClassName, <span class="keyword">boolean</span> tinkerLoadVerifyFlag) &#123;</div><div class="line">        <span class="keyword">this</span>.tinkerFlags = tinkerFlags;</div><div class="line">        <span class="keyword">this</span>.delegateClassName = delegateClassName;</div><div class="line">        <span class="keyword">this</span>.loaderClassName = loaderClassName;</div><div class="line">        <span class="keyword">this</span>.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">createDelegate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// Use reflection to create the delegate so it doesn't need to go into the primary dex.</span></div><div class="line">            <span class="comment">// And we can also patch it</span></div><div class="line">            Class&lt;?&gt; delegateClass = Class.forName(delegateClassName, <span class="keyword">false</span>, getClassLoader());</div><div class="line">            Constructor&lt;?&gt; constructor = delegateClass.getConstructor(Application.class, <span class="keyword">int</span>.class, <span class="keyword">boolean</span>.class, <span class="keyword">long</span>.class, <span class="keyword">long</span>.class,</div><div class="line">                Intent.class, Resources[].class, ClassLoader[].class, AssetManager[].class);</div><div class="line">            <span class="keyword">return</span> constructor.newInstance(<span class="keyword">this</span>, tinkerFlags, tinkerLoadVerifyFlag,</div><div class="line">                applicationStartElapsedTime, applicationStartMillisTime,</div><div class="line">                tinkerResultIntent, resources, classLoader, assetManager);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"createDelegate failed"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">ensureDelegate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (delegate == <span class="keyword">null</span>) &#123;</div><div class="line">            delegate = createDelegate();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Hook for sub-classes to run logic after the &#123;<span class="doctag">@link</span> Application#attachBaseContext&#125; has been</div><div class="line">     * called but before the delegate is created. Implementors should be very careful what they do</div><div class="line">     * here since &#123;<span class="doctag">@link</span> android.app.Application#onCreate&#125; will not have yet been called.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onBaseContextAttached</span><span class="params">(Context base)</span> </span>&#123;</div><div class="line">        applicationStartElapsedTime = SystemClock.elapsedRealtime();</div><div class="line">        applicationStartMillisTime = System.currentTimeMillis();</div><div class="line">        loadTinker();</div><div class="line">        ensureDelegate();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Method method = ShareReflectUtil.findMethod(delegate, <span class="string">"onBaseContextAttached"</span>, Context.class);</div><div class="line">            method.invoke(delegate, base);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"onBaseContextAttached method not found"</span>, t);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//重置安全模式次数，大于等于三次会进入安全模式不再加载</span></div><div class="line">        <span class="keyword">if</span> (useSafeMode) &#123;</div><div class="line">            String processName = ShareTinkerInternals.getProcessName(<span class="keyword">this</span>);</div><div class="line">            String preferName = ShareConstants.TINKER_OWN_PREFERENCE_CONFIG + processName;</div><div class="line">            SharedPreferences sp = getSharedPreferences(preferName, Context.MODE_PRIVATE);</div><div class="line">            sp.edit().putInt(ShareConstants.TINKER_SAFE_MODE_COUNT, <span class="number">0</span>).commit();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.attachBaseContext(base);</div><div class="line">        onBaseContextAttached(base);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delegateMethod</span><span class="params">(String methodName)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (delegate != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Method method = ShareReflectUtil.findMethod(delegate, methodName, <span class="keyword">new</span> Class[<span class="number">0</span>]);</div><div class="line">                method.invoke(delegate, <span class="keyword">new</span> Object[<span class="number">0</span>]);</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(String.format(<span class="string">"%s method not found"</span>, methodName), t);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">        ensureDelegate();</div><div class="line">        delegateMethod(<span class="string">"onCreate"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TinkerApplication继承自Application，说明它是正经的Application，而且在manifest文件中声明的也必须是它。然后在Application的各个声明周期方法中反射调用<code>delegate</code>同步Application的周期方法回调，其中的<code>delegate</code>是我们传过来的我们项目中的Application <code>MyApplication</code>。</p>
<p>其中的loaderTinker()方法是Tinker的加载流程，我们稍后会讲到，在反射调用MyApplication的attachBaseContext之前，loaderTinker()已经被调用完成，也就是说，Tinker是在加载完整个流程之后才去调用的app中的Application的attachBaseContext开始真正的整个App的生命周期。说白了就是采用了代理。</p>
<p>看到这里，如果你看过我之前写的<a href="http://w4lle.github.io/2016/05/02/%E4%BB%8EInstant%20run%E8%B0%88Android%E6%9B%BF%E6%8D%A2Application%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">从Instant run谈Android替换Application和动态加载机制</a>，就会发现跟这个好像。区别在于，InstantRun是在编译器修改manifest插入IncrementalClassLoader，运行时动态替换成项目中实际使用的MyApplication，进而替换了ClassLoader和资源等，开发者在毫不知情的情况下就完成了替换。</p>
<p>其中大量使用了反射，hook系统api，替换运行时系统中保有的Application的引用，最终完成替换，Tinker团队之前做过测试，100w人会有几十个在替换的时候出现问题，而且如果反射替换Application的问题，那么这个过程是不可逆的。Tinker为了兼容性问题考虑，采用了工程代理的方式，避免进入兼容性的坑。虽然可以用注解的方式生成，但是这种方式相比InstantRun的那一套接入成本还是增大不少，不过为了线上的稳定，这一切都是值得的。</p>
<p>还有一点需要注意的是，TinkerApplication是采用反射调用的MyApplication，为什么一定是反射，我们直接传过去MyApplication的引用直接调用不就好了吗？关于这一点，我们后面会详细说明。</p>
<h1 id="补丁加载"><a href="#补丁加载" class="headerlink" title="补丁加载"></a>补丁加载</h1><p>在补丁加载之前，我们需要知道补丁文件现在已经下发到app中，并且通过dexDiff合成并且校验然后push到<code>/data/data/package_name/tinker/</code>下。大概的文件目录：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">root@android:/data/data/tinker.sample.android/tinker # ls</div><div class="line">info.lock</div><div class="line">patch-bc7c9396</div><div class="line">patch.info</div><div class="line"></div><div class="line">root@android:/data/data/tinker.sample.android/tinker/patch-bc7c9396 # ls</div><div class="line">dex</div><div class="line">odex</div><div class="line">patch-bc7c9396.apk</div><div class="line">res</div></pre></td></tr></table></figure>
<p>刚才讲到loadTinker()方法是实现Tinker加载补丁的关键，我们继续看下实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadTinker</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//disable tinker, not need to install</span></div><div class="line">    <span class="keyword">if</span> (tinkerFlags == TINKER_DISABLE) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    tinkerResultIntent = <span class="keyword">new</span> Intent();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//reflect tinker loader, because loaderClass may be define by user!</span></div><div class="line">        Class&lt;?&gt; tinkerLoadClass = Class.forName(loaderClassName, <span class="keyword">false</span>, getClassLoader());</div><div class="line"></div><div class="line">        Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class, <span class="keyword">int</span>.class, <span class="keyword">boolean</span>.class);</div><div class="line">        Constructor&lt;?&gt; constructor = tinkerLoadClass.getConstructor();</div><div class="line">        tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), <span class="keyword">this</span>, tinkerFlags, tinkerLoadVerifyFlag);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        <span class="comment">//has exception, put exception error code</span></div><div class="line">        ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);</div><div class="line">        tinkerResultIntent.putExtra(INTENT_PATCH_EXCEPTION, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的<code>loaderClassName</code>是我们传过来的<code>&quot;com.tencent.tinker.loader.TinkerLoader&quot;</code>，反射调用TinkerLoader的tryLoad()方法拿到加载补丁结果，这里为什么也要用反射，是因为Tinker做了很多扩展性的工作，TinkerLoader只是默认实现，开发者完全可以自己定义加载器完成加载流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//TinkerLoader</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * only main process can handle patch version change or incomplete</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Intent <span class="title">tryLoad</span><span class="params">(TinkerApplication app, <span class="keyword">int</span> tinkerFlag, <span class="keyword">boolean</span> tinkerLoadVerifyFlag)</span> </span>&#123;</div><div class="line">        Intent resultIntent = <span class="keyword">new</span> Intent();</div><div class="line"></div><div class="line">        <span class="keyword">long</span> begin = SystemClock.elapsedRealtime();</div><div class="line">        tryLoadPatchFilesInternal(app, tinkerFlag, tinkerLoadVerifyFlag, resultIntent);</div><div class="line">        <span class="keyword">long</span> cost = SystemClock.elapsedRealtime() - begin;</div><div class="line">        ShareIntentUtil.setIntentPatchCostTime(resultIntent, cost);</div><div class="line">        <span class="keyword">return</span> resultIntent;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>调用tryLoadPatchFilesInternal()方法，然后计算消耗时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryLoadPatchFilesInternal</span><span class="params">(TinkerApplication app, <span class="keyword">int</span> tinkerFlag, <span class="keyword">boolean</span> tinkerLoadVerifyFlag, Intent resultIntent)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    ...</div><div class="line">        <span class="comment">//tinker/patch.info</span></div><div class="line">        File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectoryPath);</div><div class="line"></div><div class="line">        <span class="comment">//old = 641e634c5b8f1649c75caf73794acbdf</span></div><div class="line">        <span class="comment">//new = 2c150d8560334966952678930ba67fa8</span></div><div class="line">        File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectoryPath);</div><div class="line"></div><div class="line">        patchInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);</div><div class="line"></div><div class="line">        String oldVersion = patchInfo.oldVersion;</div><div class="line">        String newVersion = patchInfo.newVersion;</div><div class="line"></div><div class="line">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OLD_VERSION, oldVersion);</div><div class="line">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_NEW_VERSION, newVersion);</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> mainProcess = ShareTinkerInternals.isInMainProcess(app);</div><div class="line">        <span class="keyword">boolean</span> versionChanged = !(oldVersion.equals(newVersion));</div><div class="line"></div><div class="line">        String version = oldVersion;</div><div class="line">        <span class="keyword">if</span> (versionChanged &amp;&amp; mainProcess) &#123;</div><div class="line">            version = newVersion;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//patch-641e634c</span></div><div class="line">        String patchName = SharePatchFileUtil.getPatchVersionDirectory(version);</div><div class="line"></div><div class="line">        <span class="comment">//tinker/patch.info/patch-641e634c</span></div><div class="line">        String patchVersionDirectory = patchDirectoryPath + <span class="string">"/"</span> + patchName;</div><div class="line">        File patchVersionDirectoryFile = <span class="keyword">new</span> File(patchVersionDirectory);</div><div class="line"></div><div class="line">        <span class="comment">//tinker/patch.info/patch-641e634c/patch-641e634c.apk</span></div><div class="line">        File patchVersionFile = <span class="keyword">new</span> File(patchVersionDirectoryFile.getAbsolutePath(), SharePatchFileUtil.getPatchVersionFile(version));</div><div class="line"></div><div class="line">        ShareSecurityCheck securityCheck = <span class="keyword">new</span> ShareSecurityCheck(app);</div><div class="line"></div><div class="line"><span class="comment">//校验签名和tinkerId</span></div><div class="line">        <span class="keyword">int</span> returnCode = ShareTinkerInternals.checkSignatureAndTinkerID(app, patchVersionFile, securityCheck);</div><div class="line"></div><div class="line">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_CONFIG, securityCheck.getPackagePropertiesIfPresent());</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForDex = ShareTinkerInternals.isTinkerEnabledForDex(tinkerFlag);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (isEnabledForDex) &#123;</div><div class="line">            <span class="comment">//tinker/patch.info/patch-641e634c/dex</span></div><div class="line">            <span class="keyword">boolean</span> dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);</div><div class="line">            <span class="keyword">if</span> (!dexCheck) &#123;</div><div class="line">                <span class="comment">//file not found, do not load patch</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForNativeLib = ShareTinkerInternals.isTinkerEnabledForNativeLib(tinkerFlag);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (isEnabledForNativeLib) &#123;</div><div class="line">            <span class="comment">//tinker/patch.info/patch-641e634c/lib</span></div><div class="line">            <span class="keyword">boolean</span> libCheck = TinkerSoLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);</div><div class="line">            <span class="keyword">if</span> (!libCheck) &#123;</div><div class="line">                <span class="comment">//file not found, do not load patch</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//check resource</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForResource = ShareTinkerInternals.isTinkerEnabledForResource(tinkerFlag);</div><div class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:isEnabledForResource:"</span> + isEnabledForResource);</div><div class="line">        <span class="keyword">if</span> (isEnabledForResource) &#123;</div><div class="line">            <span class="keyword">boolean</span> resourceCheck = TinkerResourceLoader.checkComplete(app, patchVersionDirectory, securityCheck, resultIntent);</div><div class="line">            <span class="keyword">if</span> (!resourceCheck) &#123;</div><div class="line">                <span class="comment">//file not found, do not load patch</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//we should first try rewrite patch info file, if there is a error, we can't load jar</span></div><div class="line">        <span class="keyword">if</span> (mainProcess &amp;&amp; versionChanged) &#123;</div><div class="line">            patchInfo.oldVersion = version;</div><div class="line">            <span class="comment">//update old version to new</span></div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//是否已经进入安全模式</span></div><div class="line">        <span class="keyword">if</span> (!checkSafeModeCount(app)) &#123;</div><div class="line">            ...</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//now we can load patch jar</span></div><div class="line">        <span class="keyword">if</span> (isEnabledForDex) &#123;</div><div class="line">            <span class="keyword">boolean</span> loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//now we can load patch resource</span></div><div class="line">        <span class="keyword">if</span> (isEnabledForResource) &#123;</div><div class="line">            <span class="keyword">boolean</span> loadTinkerResources = TinkerResourceLoader.loadTinkerResources(tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//all is ok!</span></div><div class="line">        ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_OK);</div><div class="line">        Log.i(TAG, <span class="string">"tryLoadPatchFiles: load end, ok!"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>贴的代码省略了好多判空操作，会判断补丁是否存在，检查补丁信息中的数据是否有效，校验补丁签名以及tinkerId与基准包是否一致。在校验签名时，为了加速校验速度，Tinker只校验 <code>*_meta.txt</code>文件，然后再根据meta文件中的md5校验其他文件。<br>其中，meta文件有以下几种：</p>
<ul>
<li>package_meta.txt 补丁包的基本信息</li>
<li>dex_meta.txt     补丁包中dex文件的信息</li>
<li>so_meta.txt      补丁包中so文件的信息</li>
<li>res_meta.txt     补丁包中资源文件的信息</li>
</ul>
<p>然后根据开发者配置的Tinker可补丁类型判断是否可以加载dex，res，so。然后分别分发给TinkerDexLoader、TinkerSoLoader、TinkerResourceLoader分别进行校验是否符合加载条件进而进行加载。</p>
<h2 id="加载补丁dex"><a href="#加载补丁dex" class="headerlink" title="加载补丁dex"></a>加载补丁dex</h2><p>在开始讲load dex之前，先说下Tinker的补丁方案，Tinker采用的是下发差分包，然后在手机端合成全量的dex文件进行加载。而在build.gradle配置中的tinkerPatch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dex.loader = [<span class="string">"com.tencent.tinker.loader.*"</span>,</div><div class="line"><span class="string">"tinker.sample.android.app.SampleApplication"</span>,</div><div class="line"><span class="string">"tinker.sample.android.app.BaseBuildInfo"</span></div><div class="line">]</div></pre></td></tr></table></figure>
<p>这个配置中的类不会出现在任何全量补丁dex里，也就是说在合成后，这些类还在老的dex文件中，比如在补丁前dex顺序是这样的：<code>oldDex1 -&gt; oldDex2 -&gt; oldDex3..</code>，那么假如修改了dex1中的文件，那么补丁顺序是这样的<code>newDex1 -&gt; oldDex1 -&gt; oldDex2...</code>其中合成后的newDex1中的类是oldDex1中除了dex.loader中标明的类之外的所有类，dex.loader中的类依然在oldDex1中。</p>
<p>由于Tinker的方案是基于Multidex实现的修改dexElements的顺序实现的，所以最终还是要修改classLoder中dexPathList中dexElements的顺序。Android中有两种ClassLoader用于加载dex文件，BootClassLoader、PathClassLoader和DexClassLoader都是继承自BaseDexClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span></span></div><div class="line">            String libraryPath, ClassLoader parent) &#123;</div><div class="line">        <span class="keyword">super</span>(parent);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.originalPath = dexPath;</div><div class="line">        <span class="keyword">this</span>.pathList =</div><div class="line">            <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">        Class clazz = pathList.findClass(name);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> clazz;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="comment">//DexPathList</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Element element : dexElements) &#123;</div><div class="line">            DexFile dex = element.dexFile;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</div><div class="line">                Class clazz = dex.loadClassBinaryName(name, definingContext);</div><div class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> clazz;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>最终在DexPathList的findClass中遍历dexElements，谁在前面用谁。而这个dexElements是在方法makeDexElements中生成的，我们的目的就是hook这个方法把dex插入到dexElements的前面。</p>
<p>继续加载流程，首先调用TinkerDexLoader的checkComplete校验dex_meta.xml文件中记载的dex补丁文件和经过opt优化过的文件是否存在，然后调用loadTinkerJars加载补丁dex。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/**</span></div><div class="line">     * Load tinker JARs and add them to</div><div class="line">     * the Application ClassLoader.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> application The application.</div><div class="line">     */</div><div class="line">    <span class="meta">@TargetApi</span>(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">loadTinkerJars</span><span class="params">(Application application, <span class="keyword">boolean</span> tinkerLoadVerifyFlag, String directory, Intent intentResult)</span> </span>&#123;</div><div class="line"></div><div class="line">        PathClassLoader classLoader = (PathClassLoader) TinkerDexLoader.class.getClassLoader();</div><div class="line"></div><div class="line">        String dexPath = directory + <span class="string">"/"</span> + DEX_PATH + <span class="string">"/"</span>;</div><div class="line">        File optimizeDir = <span class="keyword">new</span> File(directory + <span class="string">"/"</span> + DEX_OPTIMIZE_PATH);</div><div class="line"></div><div class="line">        ArrayList&lt;File&gt; legalFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isArtPlatForm = ShareTinkerInternals.isVmArt();</div><div class="line">        <span class="keyword">for</span> (ShareDexDiffPatchInfo info : dexList) &#123;</div><div class="line">            <span class="comment">//for dalvik, ignore art support dex</span></div><div class="line">            <span class="keyword">if</span> (isJustArtSupportDex(info)) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            String path = dexPath + info.realName;</div><div class="line">            File file = <span class="keyword">new</span> File(path);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (tinkerLoadVerifyFlag) &#123;</div><div class="line">                <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">                String checkMd5 = isArtPlatForm ? info.destMd5InArt : info.destMd5InDvm;</div><div class="line">                <span class="keyword">if</span> (!SharePatchFileUtil.verifyDexFileMd5(file, checkMd5)) &#123;</div><div class="line">                    <span class="comment">//it is good to delete the mismatch file</span></div><div class="line">                    ...</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            legalFiles.add(file);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            SystemClassLoaderAdder.installDexes(application, classLoader, optimizeDir, legalFiles);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            Log.e(TAG, <span class="string">"install dexes failed"</span>);</div><div class="line"><span class="comment">//            e.printStackTrace();</span></div><div class="line">            intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, e);</div><div class="line">            ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        Log.i(TAG, <span class="string">"after loaded classloader: "</span> + application.getClassLoader().toString());</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>根据传过来的tinkerLoadVerifyFlag选项控制是否每次加载都要验证dex的md5值，一般来说不需要，默认也是false，会节省加载时间。然后调用SystemClassLoaderAdder去加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SystemClassLoaderAdder</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installDexes</span><span class="params">(Application application, PathClassLoader loader, File dexOptDir, List&lt;File&gt; files)</span></span></div><div class="line">        <span class="keyword">throws</span> Throwable &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!files.isEmpty()) &#123;</div><div class="line">            ClassLoader classLoader = loader;</div><div class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span>) &#123;</div><div class="line">                classLoader = AndroidNClassLoader.inject(loader, application);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//because in dalvik, if inner class is not the same classloader with it wrapper class.</span></div><div class="line">            <span class="comment">//it won't fail at dex2opt</span></div><div class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</div><div class="line">                V23.install(classLoader, files, dexOptDir);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</div><div class="line">                V19.install(classLoader, files, dexOptDir);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</div><div class="line">                V14.install(classLoader, files, dexOptDir);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                V4.install(classLoader, files, dexOptDir);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!checkDexInstall()) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(ShareConstants.CHECK_DEX_INSTALL_FAIL);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>看到这里，如果你之前看过Multidex.install()方法的实现，就会感觉很相似。只不过热修复是把dex插到dexElements的前面，Multidex是把其余的dex插到后面。相同的就是都是分版本加载，我们分别来看，由于v14以下(Android4.0以前)太过古老，我们就不看了，从v14开始。</p>
<h3 id="v14"><a href="#v14" class="headerlink" title="v14"></a>v14</h3><p>14 &lt;= SDK &lt; 19<br>Android 4.0 &lt;= Android系统 &lt; Android 4.4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Installer for platform versions 14, 15, 16, 17 and 18.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V14</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span></span></div><div class="line">                                File optimizedDirectory)</div><div class="line">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</div><div class="line">        NoSuchFieldException, InvocationTargetException, NoSuchMethodException &#123;</div><div class="line">        Field pathListField = ShareReflectUtil.findField(loader, <span class="string">"pathList"</span>);</div><div class="line">        Object dexPathList = pathListField.get(loader);</div><div class="line">        ShareReflectUtil.expandFieldArray(dexPathList, <span class="string">"dexElements"</span>, makeDexElements(dexPathList,</div><div class="line">            <span class="keyword">new</span> ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object[] makeDexElements(</div><div class="line">        Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory)</div><div class="line">        <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException,</div><div class="line">        NoSuchMethodException &#123;</div><div class="line">        Method makeDexElements =</div><div class="line">            ShareReflectUtil.findMethod(dexPathList, <span class="string">"makeDexElements"</span>, ArrayList.class, File.class);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>反射找到classLoder中的pathList，然后反射调用pathList中的makeDexElements方法，穿进去的参数分别是补丁dexList和优化过的opt目录，在Tinker中是dex补丁目录的同级目录<code>odex/</code>。</p>
<p>其中有个ShareReflectUtil.expandFieldArray我们看下实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expandFieldArray</span><span class="params">(Object instance, String fieldName, Object[] extraElements)</span></span></div><div class="line">    <span class="keyword">throws</span> NoSuchFieldException, IllegalArgumentException, IllegalAccessException &#123;</div><div class="line">    Field jlrField = findField(instance, fieldName);</div><div class="line"></div><div class="line">    Object[] original = (Object[]) jlrField.get(instance);</div><div class="line">    Object[] combined = (Object[]) Array.newInstance(original.getClass().getComponentType(), original.length + extraElements.length);</div><div class="line"></div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> changed to copy extraElements first, for patch load first</span></div><div class="line"></div><div class="line">    System.arraycopy(extraElements, <span class="number">0</span>, combined, <span class="number">0</span>, extraElements.length);</div><div class="line">    System.arraycopy(original, <span class="number">0</span>, combined, extraElements.length, original.length);</div><div class="line"></div><div class="line">    jlrField.set(instance, combined);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意传进来的值分别是pathList,”dexElements”和新生成的dexElements数组，找到pathList的原始oldDexElements，然后生成一个新的数组combined，长度是oldDexElements.length + newDexElements.length。然后将newDexElements拷贝到combined的前面，将oldDexElements拷贝的combined的剩余位置，我们称之为dex前置。</p>
<p>刚才我们说Tinker是将dex前置，Multidex是将dex后置，我们顺便看下Multidex.install()中expandFieldArray的实现吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Multidex.java</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expandFieldArray</span><span class="params">(Object instance, String fieldName,</span></span></div><div class="line">            Object[] extraElements) <span class="keyword">throws</span> NoSuchFieldException, IllegalArgumentException,</div><div class="line">            IllegalAccessException &#123;</div><div class="line">        Field jlrField = findField(instance, fieldName);</div><div class="line">        Object[] original = (Object[]) jlrField.get(instance);</div><div class="line">        Object[] combined = (Object[]) Array.newInstance(</div><div class="line">                original.getClass().getComponentType(), original.length + extraElements.length);</div><div class="line">        System.arraycopy(original, <span class="number">0</span>, combined, <span class="number">0</span>, original.length);</div><div class="line">        System.arraycopy(extraElements, <span class="number">0</span>, combined, original.length, extraElements.length);</div><div class="line">        jlrField.set(instance, combined);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>它是先把oldDexElements拷贝到了前面，在把newDexElements拷贝到了后面，我们称之为dex后置。</p>
<p>实际上，对于Multidex的项目，不论Tinker是否加载了补丁，都应该在ApplicationLike的onBaseContextAttached方法中执行<code>MultiDex.install(base);</code>。</p>
<h3 id="v19"><a href="#v19" class="headerlink" title="v19"></a>v19</h3><p>19 &lt;= SDK &lt; 23<br>Android 4.4 &lt;= Android系统 &lt; Android 6.0</p>
<p>跟v14的区别不大，只是在makeDexElements方法中多加了一个参数suppressedExceptions异常数组，另外在makeDexElements的catch异常中多加了一次重试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">                Log.e(TAG, <span class="string">"NoSuchMethodException: makeDexElements(ArrayList,File,ArrayList) failure"</span>);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    makeDexElements = ShareReflectUtil.findMethod(dexPathList, <span class="string">"makeDexElements"</span>, List.class, File.class, List.class);</div><div class="line">                &#125; <span class="keyword">catch</span> (NoSuchMethodException e1) &#123;</div><div class="line">                    Log.e(TAG, <span class="string">"NoSuchMethodException: makeDexElements(List,File,List) failure"</span>);</div><div class="line">                    <span class="keyword">throw</span> e1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>是因为Tinker发现线上有的Rom将改方法参数类型给改了，本来是<code>makeDexElements(ArrayList,File,ArrayList)</code>，给改成了<code>makeDexElements(List,File,List)</code>，做了个兼容处理。</p>
<h3 id="v23"><a href="#v23" class="headerlink" title="v23"></a>v23</h3><p>23 &lt;= SDK &lt; 24<br>Android 6.0 &lt;= Android系统 &lt; Android 7.0</p>
<p>Android6.0以后把makeDexElements给改了，改成了<code>makePathElements(List,File,List)</code>，如果找不到的话再找一下<code>makeDexElements(List,File,List)</code>。其余没啥区别。</p>
<h3 id="v24"><a href="#v24" class="headerlink" title="v24"></a>v24</h3><p>SDK &gt;=24<br>Android 系统 &gt;= Android7.0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span>) &#123;</div><div class="line">    classLoader = AndroidNClassLoader.inject(loader, application);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>哎，这个好像跟上面不太一样啊，这是为啥呢。<br><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286341&amp;idx=1&amp;sn=054d595af6e824cbe4edd79427fc2706&amp;scene=0" target="_blank" rel="external">Android N混合编译与对热补丁影响解析</a>中详细解释了混合编译对热不定的影响。我做下简单的总结。</p>
<p>我们知道，在Dalvik虚拟机中，总是在运行时通过JIT（Just-In—Time）把字节码文件编译成机器码文件再执行，这样跑起来程序就很慢，所在ART上，改为AOT（Ahead-Of—Time）提前编译，即在安装应用或OTA系统升级时提前把字节码编译成机器码，这样就可以直接执行了，提高了运行效率。但是AOT有个缺点就是每次执行的时间都太长了，并且占用的ROM空间又很大，所以在Android N上Google做了混合编译同时支持JIT和AOT。混合编译的作用简单来说，在应用运行时分析运行过的代码以及“热代码”，并将配置存储下来。在设备空闲与充电时，ART仅仅编译这份配置中的“热代码”。</p>
<p>简单来说，就是在应用安装和首次运行不做AOT编译，先让用户愉快的玩耍起来，然后把在运行中JIT解释执行的那部分代码收集起来，在手机空闲的时候通过dex2aot编译生成一份名为app image的base.art文件，然后在下次启动的时候一次性把app image加载进来到缓存，预先加载代替用时查找以提升应用的性能。</p>
<p>这种方式对热补丁的影响就是，app image中已经存在的类会被插入到ClassLoader的ClassTable，再次加载类时，直接从ClassTable中取而不会走DefineClass。假设base.art文件在补丁前已经存在，这里存在三种情况：</p>
<ol>
<li>补丁修改的类都不appimage中；这种情况是最理想的，此时补丁机制依然有效；</li>
<li>补丁修改的类部分在appimage中；这种情况我们只能更新一部分的类，此时是最危险的。一部分类是新的，一部分类是旧的，app可能会出现地址错乱而出现crash。</li>
<li>补丁修改的类全部在appimage中；这种情况只是造成补丁不生效，app并不会因此造成crash。</li>
</ol>
<p>Tinker的解决方案是，完全废弃掉PathClassloader，而采用一个新建Classloader来加载后续的所有类，即可达到将cache无用化的效果。基本原理我们清楚了，让我们来看下代码吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//AndroidNClassLoader.java</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AndroidNClassLoader <span class="title">inject</span><span class="params">(PathClassLoader originClassLoader, Application application)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        AndroidNClassLoader classLoader = createAndroidNClassLoader(originClassLoader);</div><div class="line">        reflectPackageInfoClassloader(application, classLoader);</div><div class="line">        <span class="keyword">return</span> classLoader;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AndroidNClassLoader <span class="title">createAndroidNClassLoader</span><span class="params">(PathClassLoader original)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//let all element ""</span></div><div class="line">        AndroidNClassLoader androidNClassLoader = <span class="keyword">new</span> AndroidNClassLoader(<span class="string">""</span>,  original);</div><div class="line">        Field originPathList = findField(original, <span class="string">"pathList"</span>);</div><div class="line">        Object originPathListObject = originPathList.get(original);</div><div class="line">        <span class="comment">//should reflect definingContext also</span></div><div class="line">        Field originClassloader = findField(originPathListObject, <span class="string">"definingContext"</span>);</div><div class="line">        originClassloader.set(originPathListObject, androidNClassLoader);</div><div class="line">        <span class="comment">//copy pathList</span></div><div class="line">        Field pathListField = findField(androidNClassLoader, <span class="string">"pathList"</span>);</div><div class="line">        <span class="comment">//just use PathClassloader's pathList</span></div><div class="line">        pathListField.set(androidNClassLoader, originPathListObject);</div><div class="line">        <span class="keyword">return</span> androidNClassLoader;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们按步骤进行：</p>
<ol>
<li>新建一个AndroidNClassLoader 它的parent是originPathClassLoader。注意，PathClassLoader的optimizedDirectory只能是null，这个后面还有用。</li>
<li>找到originPathClassLoader中的pathList 和 pathList中的类型为ClassLoader的definingContext。</li>
<li>替换definingContext为AndroidNClassLoader</li>
<li>将AndroidNClassLoader中的pathList替换为originPathClassLoader的pathList。</li>
</ol>
<p>有的同学可能会问，Android 的ClassLoader采用双亲委托模型，只有parent找不到的情况下才会去找AndroidNClassLoader，那我新建这个AndroidNClassLoader有什么用，最终还是会去originPathClassLoader中取找。其实不是这样的，我们已经将originPathClassLoader中pathList中的definingContext(是个ClassLoader)替换为了AndroidNClassLoader了。这个definingContext会在生成DexFile的时候传递进去，而ClassLoader的findClass()方法会调用pathList的findClass方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//DexPathList.java</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Element element : dexElements) &#123;</div><div class="line">            DexFile dex = element.dexFile;</div><div class="line">            <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</div><div class="line">                Class clazz = dex.loadClassBinaryName(name, definingContext);</div><div class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> clazz;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>最终还是调用的dexFile.loadClassBinaryName()方法，其中的第二个参数其实就已经是AndroidNClassLoader了。</p>
<p>还记得刚才说的AndroidNClassLder的optimizedDirectory是null吗</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//DexPathList.java</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files,</div><div class="line">            File optimizedDirectory) &#123;</div><div class="line">            ...</div><div class="line">            dex = loadDexFile(file, optimizedDirectory);</div><div class="line">            ....</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title">loadDexFile</span><span class="params">(File file, File optimizedDirectory)</span></span></div><div class="line">            <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DexFile(file);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            String optimizedPath = optimizedPathFor(file, optimizedDirectory);</div><div class="line">            <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>看到这里我们明白了，optimizedDirectory是用来缓存我们需要加载的dex文件的，并创建一个DexFile对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile对象。意思也就是说我不需要用缓存，不需要用app image加载。</p>
<p>接续往下走</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reflectPackageInfoClassloader</span><span class="params">(Application application, ClassLoader reflectClassLoader)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    String defBase = <span class="string">"mBase"</span>;</div><div class="line">    String defPackageInfo = <span class="string">"mPackageInfo"</span>;</div><div class="line">    String defClassLoader = <span class="string">"mClassLoader"</span>;</div><div class="line"></div><div class="line">    Context baseContext = (Context) findField(application, defBase).get(application);</div><div class="line">    Object basePackageInfo = findField(baseContext, defPackageInfo).get(baseContext);</div><div class="line">    Field classLoaderField = findField(basePackageInfo, defClassLoader);</div><div class="line">    Thread.currentThread().setContextClassLoader(reflectClassLoader);</div><div class="line">    classLoaderField.set(basePackageInfo, reflectClassLoader);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>作用是替换掉了mPackageInfo中的ClassLoader，mPackageInfo是LoadedApk的对象，代表了APK文件在内存中的表示，诸如Apk文件的代码和资源，甚至代码里面的Activity，Service等组件的信息我们都可以通过此对象获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ActivityThread.java</span></div><div class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</div><div class="line">activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</div><div class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());</div><div class="line">r.intent.setExtrasClassLoader(cl);</div></pre></td></tr></table></figure>
<p>到这里就完成了AndroidNClassLoader的创建与替换，接下来的加载过程使用了v23的加载流程，就不细说了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，整个dex加载流程就分析完了。我们看到Tinker在兼容性上做了充足的工作，整个加载流程虽然跟其他基于Multidex的热补丁框架差不多，但是在兼容性上做了更完备的处理。</p>
<h2 id="加载补丁资源"><a href="#加载补丁资源" class="headerlink" title="加载补丁资源"></a>加载补丁资源</h2><p>Tinker的资源更新采用的InstantRun的资源补丁方式，全量替换资源。由于App加载资源是依赖Context.getResources()方法返回的Resources对象，Resources 内部包装了 AssetManager，最终由 AssetManager 从 apk 文件中加载资源。我们要做的就是新建一个AssetManager()，hook掉其中的addAssetPath()方法，将我们的资源补丁目录传递进去，然后循环替换Resources对象中的AssetManager对象，达到资源替换的目的。看下代码实现。</p>
<p>首先依然先根据res_meta.xml文件中记载的信息检查文件(res/resources.apk)是否存在，实现在TinkerResourceLoader.checkComplete()方法，然后调用<code>TinkerResourcePatcher.isResourceCanPatch(context);</code>判断是否支持反射更新资源，看下具体的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">isResourceCanPatch</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="comment">// Create a new AssetManager instance and point it to the resources installed under /sdcard</span></div><div class="line">    AssetManager assets = context.getAssets();</div><div class="line">    <span class="comment">// Baidu os</span></div><div class="line">    <span class="keyword">if</span> (assets.getClass().getName().equals(<span class="string">"android.content.res.BaiduAssetManager"</span>)) &#123;</div><div class="line">        Class baiduAssetManager = Class.forName(<span class="string">"android.content.res.BaiduAssetManager"</span>);</div><div class="line">        newAssetManager = (AssetManager) baiduAssetManager.getConstructor().newInstance();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        newAssetManager = AssetManager.class.getConstructor().newInstance();</div><div class="line">    &#125;</div><div class="line">    addAssetPathMethod = AssetManager.class.getDeclaredMethod(<span class="string">"addAssetPath"</span>, String.class);</div><div class="line">    addAssetPathMethod.setAccessible(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Kitkat needs this method call, Lollipop doesn't. However, it doesn't seem to cause any harm</span></div><div class="line">    <span class="comment">// in L, so we do it unconditionally.</span></div><div class="line">    ensureStringBlocksMethod = AssetManager.class.getDeclaredMethod(<span class="string">"ensureStringBlocks"</span>);</div><div class="line">    ensureStringBlocksMethod.setAccessible(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Iterate over all known Resources objects</span></div><div class="line">    <span class="keyword">if</span> (SDK_INT &gt;= KITKAT) &#123;</div><div class="line">        <span class="comment">//pre-N</span></div><div class="line">        <span class="comment">// Find the singleton instance of ResourcesManager</span></div><div class="line">        Class&lt;?&gt; resourcesManagerClass = Class.forName(<span class="string">"android.app.ResourcesManager"</span>);</div><div class="line">        Method mGetInstance = resourcesManagerClass.getDeclaredMethod(<span class="string">"getInstance"</span>);</div><div class="line">        mGetInstance.setAccessible(<span class="keyword">true</span>);</div><div class="line">        Object resourcesManager = mGetInstance.invoke(<span class="keyword">null</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Field fMActiveResources = resourcesManagerClass.getDeclaredField(<span class="string">"mActiveResources"</span>);</div><div class="line">            fMActiveResources.setAccessible(<span class="keyword">true</span>);</div><div class="line">            ArrayMap&lt;?, WeakReference&lt;Resources&gt;&gt; arrayMap =</div><div class="line">                (ArrayMap&lt;?, WeakReference&lt;Resources&gt;&gt;) fMActiveResources.get(resourcesManager);</div><div class="line">            references = arrayMap.values();</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException ignore) &#123;</div><div class="line">            <span class="comment">// N moved the resources to mResourceReferences</span></div><div class="line">            Field mResourceReferences = resourcesManagerClass.getDeclaredField(<span class="string">"mResourceReferences"</span>);</div><div class="line">            mResourceReferences.setAccessible(<span class="keyword">true</span>);</div><div class="line">            <span class="comment">//noinspection unchecked</span></div><div class="line">            references = (Collection&lt;WeakReference&lt;Resources&gt;&gt;) mResourceReferences.get(resourcesManager);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Class&lt;?&gt; activityThread = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</div><div class="line">        Field fMActiveResources = activityThread.getDeclaredField(<span class="string">"mActiveResources"</span>);</div><div class="line">        fMActiveResources.setAccessible(<span class="keyword">true</span>);</div><div class="line">        Object thread = getActivityThread(context, activityThread);</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        HashMap&lt;?, WeakReference&lt;Resources&gt;&gt; map =</div><div class="line">            (HashMap&lt;?, WeakReference&lt;Resources&gt;&gt;) fMActiveResources.get(thread);</div><div class="line">        references = map.values();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// check resource</span></div><div class="line">    <span class="keyword">if</span> (references == <span class="keyword">null</span> || references.isEmpty()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"resource references is null or empty"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        assetsFiled = Resources.class.getDeclaredField(<span class="string">"mAssets"</span>);</div><div class="line">        assetsFiled.setAccessible(<span class="keyword">true</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</div><div class="line">        <span class="comment">// N moved the mAssets inside an mResourcesImpl field</span></div><div class="line">        resourcesImplFiled = Resources.class.getDeclaredField(<span class="string">"mResourcesImpl"</span>);</div><div class="line">        resourcesImplFiled.setAccessible(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>按照步骤来吧，首先新建一个AssetManager对象，其中对BaiduROM做了兼容(BaiduAssetManager)，拿到其中的addAssetPath方法的反射addAssetPathMethod，然后拿到ensureStringBlocks的反射，然后区分版本拿到Resources的集合。</p>
<ul>
<li>SDK &gt;= 19，从ResourcesManager中拿到mActiveResources变量，是个持有Resources的ArrayMap，赋值给references，Android N中该变量叫做mResourceReferences</li>
<li>SDK &lt; 19，从ActivityThread中获取mActiveResources，是个HashMap持有Resources，赋值给references</li>
</ul>
<p>如果references为空，说明该系统不支持资源补丁，throw 一个IllegalStateException被上层调用catch。</p>
<p>然后调用monkeyPatchExistingResources方法(这个方法的名字跟InstantRun的资源补丁方法名是一样的)，将补丁资源路径(res/resources.apk)传递进去，代码就不贴了，简单描述为反射调用新建的AssetManager的addAssetPath将路径穿进去，然后主动调用ensureStringBlocks方法确保资源的字符串索引创建出来；然后循环遍历持有Resources对象的references集合，依次替换其中的AssetManager为新建的AssetManager，最后调用Resources.updateConfiguration将Resources对象的配置信息更新到最新状态，完成整个资源替换的过程。</p>
<p>目前来看InstantRun的资源更新方式最简便而且兼容性也最好，市面上大多数的热补丁框架都采用这套方案。Tinker的这套方案虽然也采用全量的替换，但是在下发patch中依然采用差量资源的方式获取差分包，下发到手机后再合成全量的资源文件，有效的控制了补丁文件的大小。</p>
<h2 id="加载补丁so"><a href="#加载补丁so" class="headerlink" title="加载补丁so"></a>加载补丁so</h2><p>依然根据so_meta.txt中的补丁信息校验so文件是否都存在。然后将so补丁列表存放在结果中libs的字段。</p>
<p>so的更新方式跟dex和资源都不太一样，因为系统提供给了开发者自定义so目录的选项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(String pathName)</span> </span>&#123;</div><div class="line">        Runtime.getRuntime().load(pathName, VMStack.getCallingClassLoader());</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Tinker加载SO补丁提供了两个入口，分别是TinkerInstaller和TinkerApplicationHelper。他们两个的区别是TinkerInstaller只有在Tinker.install过之后才能使用,否则会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//TinkerInstaller</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">loadLibraryFromTinker</span><span class="params">(Context context, String relativePath, String libname)</span> <span class="keyword">throws</span> UnsatisfiedLinkError </span>&#123;</div><div class="line">        <span class="keyword">final</span> Tinker tinker = Tinker.with(context);</div><div class="line"></div><div class="line">        libname = libname.startsWith(<span class="string">"lib"</span>) ? libname : <span class="string">"lib"</span> + libname;</div><div class="line">        libname = libname.endsWith(<span class="string">".so"</span>) ? libname : libname + <span class="string">".so"</span>;</div><div class="line">        String relativeLibPath = relativePath + <span class="string">"/"</span> + libname;</div><div class="line"></div><div class="line">        <span class="comment">//TODO we should add cpu abi, and the real path later</span></div><div class="line">        <span class="keyword">if</span> (tinker.isEnabledForNativeLib() &amp;&amp; tinker.isTinkerLoaded()) &#123;</div><div class="line">            TinkerLoadResult loadResult = tinker.getTinkerLoadResultIfPresent();</div><div class="line">            <span class="keyword">if</span> (loadResult.libs != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">for</span> (String name : loadResult.libs.keySet()) &#123;</div><div class="line">                    <span class="keyword">if</span> (name.equals(relativeLibPath)) &#123;</div><div class="line">                        String patchLibraryPath = loadResult.libraryDirectory + <span class="string">"/"</span> + name;</div><div class="line">                        File library = <span class="keyword">new</span> File(patchLibraryPath);</div><div class="line">                        <span class="keyword">if</span> (library.exists()) &#123;</div><div class="line">                            <span class="comment">//whether we check md5 when load</span></div><div class="line">                            <span class="keyword">boolean</span> verifyMd5 = tinker.isTinkerLoadVerify();</div><div class="line">                            <span class="keyword">if</span> (verifyMd5 &amp;&amp; !SharePatchFileUtil.verifyFileMd5(library, loadResult.libs.get(name))) &#123;</div><div class="line">                                tinker.getLoadReporter().onLoadFileMd5Mismatch(library, ShareConstants.TYPE_LIBRARY);</div><div class="line">                            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                System.load(patchLibraryPath);</div><div class="line">                                TinkerLog.i(TAG, <span class="string">"loadLibraryFromTinker success:"</span> + patchLibraryPath);</div><div class="line">                                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>简单来说就是遍历检查的结果列表libs，找到要加载的类，调用System.load方法进行加载。</p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>在集成Tinker的过程中，遇到了一个问题(环境是Dalvik，ART没问题)，在前面我们提到了dex.loader的配置，我把项目中用于下载补丁文件的工具类A加到了其中，然后下发补丁报错，出现Class ref in pre-verified class resolved to unexpected  implementation的crash。Qzone的那套热补丁为了消除这个错误采用插庄的方式来规避，Tinker采用全量dex的方式来规避该问题，那为什么还会出现呢。</p>
<p>根据log找到了报错点是在工具类A中的一个直接引用类B的方法中报错。错误原因在加载补丁dex一节其实已经提到一些，我们引用过来，这个配置(dex.loader)中的类不会出现在任何全量补丁dex里，也就是说在合成后，这些类还在老的dex文件中，比如在补丁前dex顺序是这样的：<code>oldDex1 -&gt; oldDex2 -&gt; oldDex3..</code>，那么假如修改了dex1中的文件，那么补丁顺序是这样的<code>newDex1 -&gt; oldDex1 -&gt; oldDex2...</code>其中合成后的newDex1中的类是oldDex1中除了dex.loader中标明的类之外的所有类，dex.loader中的类依然在oldDex1中。<br>也就是说A类是在dex.loader配置中的，补丁后，A依然在oldDex1中，而A的直接引用类B却出现在了newDex1中，并且在之前A类已经被打上了preverify标志，所在A再去newDex1中加载B的话就会报该错误。</p>
<p>那有的同学可能会问了，TinkerApplication也在oldDex1中的，而我们的ApplicationLike在补丁后也出现在了newDex1中，TinkerApplication反射调用ApplicationLike的生命周期方法为什么没有出现crash呢？还记得文章前面的有一个反射么，我们说了要注意后面会讲到，就是在这里用到的。</p>
<p>校验preverify的方法，正常的类加载会走到这里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ClassObject* dvmResolveClass(<span class="keyword">const</span> ClassObject* referrer, u4 classIdx,</div><div class="line">    bool fromUnverifiedConstant)</div><div class="line">&#123;</div><div class="line">....</div><div class="line">       <span class="keyword">if</span> (!fromUnverifiedConstant &amp;&amp;</div><div class="line">            IS_CLASS_FLAG_SET(referrer, CLASS_ISPREVERIFIED))</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而反射走了完全不同的路径，不会走到dvmResolveClass方法，也就不会报错了。关于这个方法，我们下篇文章会详细讲解。反射最直接的目的也是为了隔离开这两个类，也就是隔离开了Tinker组件和app。如图</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/ref.png" alt=""></p>
<p>通过反射，将Tinker组建和App隔离开，并且先后顺序是先Tinker后App，这样可以防止App中的代码提前加载，确保App中所有的代码都可以具有被热修复的能力包括ApplicationLike。</p>
<p>然后又有同学问了，为啥Dalvik有问题，ART没问题呢？那是因为在ART虚拟机原生支持从APK文件加载多个dex文件。在应用安装时执行dex2oat扫描 classes(..N).dex文件，并将它们编译成单个oat文件，供 Android设备执，也就不存在MultiDex的问题了。</p>
<p>这个问题的<a href="https://github.com/Tencent/tinker/issues/124" target="_blank" rel="external">issue</a></p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>到这里，Tinker的基本补丁加载流程就分析完了，本文只对补丁加载流程加以分析，对dexDiff差分以及补丁加载没有做说明，如果你对这部分感兴趣可以参考这篇文章<a href="https://www.zybuluo.com/dodola/note/554061" target="_blank" rel="external">Tinker Dexdiff算法解析</a>。另外ART下的内联影响和OTA升级没有做过多说明，Tinker官方已经有相关文章。</p>
<p>我们简单对Tinker做下总结。<br>优点：</p>
<ul>
<li>支持类、资源、so修复</li>
<li>兼容性处理的很好，全平台支持</li>
<li>由于不用插庄，所以性能损耗很小</li>
<li>完善的开发文档和官方技术支持</li>
<li>gradle支持，再自己定义下可以一键打补丁包</li>
<li>dexDiff算法使得补丁文件较小</li>
<li>扩展性良好，代码中处处为开发者留出开放接口，简直业界良心</li>
<li>支持多次补丁</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持及时生效，下发补丁需要重启生效，MultiDex方案决定的</li>
<li>占用ROM空间较大，这点空间在如今的手机大ROM下也不算个事</li>
<li>对加固支持不太好</li>
</ul>
<p>总结下来Tinker是一种基于单ClassLoader加载多dex方案的热补丁框架，兼容性做的比较好，功能强大。如果你正在考虑接入热补丁，那么强烈推荐你使用Tinker，地精修补匠，带你无限刷新！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286384&amp;idx=1&amp;sn=f1aff31d6a567674759be476bcd12549&amp;scene=4#wechat_redirect" target="_blank" rel="external">微信Tinker的一切都在这里，包括源码(一)</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286341&amp;idx=1&amp;sn=054d595af6e824cbe4edd79427fc2706&amp;scene=0" target="_blank" rel="external">Android N混合编译与对热补丁影响解析</a><br><a href="https://www.zybuluo.com/dodola/note/554061" target="_blank" rel="external">Tinker Dexdiff算法解析</a><br><a href="http://w4lle.github.io/2016/05/02/%E4%BB%8EInstant%20run%E8%B0%88Android%E6%9B%BF%E6%8D%A2Application%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">从Instant run谈Android替换Application和动态加载机制</a><br><a href="https://segmentfault.com/a/1190000004062880" target="_blank" rel="external">Android动态加载基础 ClassLoader工作机制</a><br><a href="http://blog.csdn.net/luoshengyang/article/details/8791064" target="_blank" rel="external">Android应用程序资源管理器（Asset Manager）的创建过程分析</a></p>
<p>本文链接： <a href="http://w4lle.com/2016/12/16/tinker/">http://w4lle.com/2016/12/16/tinker/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tinker系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://w4lle.github.io/2016/12/16/tinker/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android热补丁之Tinker原理解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://w4lle.github.io/2017/01/05/one-key-for-tinker/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一键接入Tinker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://w4lle.github.io/2017/01/22/gradle-modules/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gradle模块化配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文是第一篇。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文分析版本  &lt;a href=&quot;https://github.com/Tencent/tinker/tree/93ecc9351367badc02a91fac25764bee50e6e6a6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;93ecc9351367badc02a91fac25764bee50e6e6a6&lt;/a&gt;&lt;br&gt;项目地址： &lt;a href=&quot;https://github.com/Tencent/tinker/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Tinker&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在今年的MDCC大会上，微信开发团队宣布正式开源Tinker，在这之前微信团队已经发出过一些Tinker的相关文章，说实话在开源之前我们还是相当期待Tinker开源的，一方面是因为之前使用的热补丁一直存在一些兼容性问题，另一方面也好奇Tinker的实现方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
      <category term="热补丁" scheme="http://w4lle.com/tags/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>AndroidStudio 常用快捷键</title>
    <link href="http://w4lle.com/2016/12/14/AndroidStudio-shotcurts-md/"/>
    <id>http://w4lle.com/2016/12/14/AndroidStudio-shotcurts-md/</id>
    <published>2016-12-14T10:47:01.000Z</published>
    <updated>2017-01-06T01:51:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>整理了下常用的快捷键<br>因为我用AndroidStudio的vim插件，所以在编辑这块没有整理太多。<br>需要的同学可以自己学些下。</p>
<p>熟记这些快捷键 + vim = 基本不用鼠标 = 提升效率50%</p>
<a id="more"></a>
<h1 id="AS-常用快捷键"><a href="#AS-常用快捷键" class="headerlink" title="AS 常用快捷键"></a>AS 常用快捷键</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul>
<li>cmd + o                  打开class文件</li>
<li>cmd + shift + o          打开任意文件</li>
<li>cmd + alt + o            打开变量所在文件</li>
<li>shift + shift            打开任意位置文件</li>
<li>cmd + e                  最近使用文件</li>
<li>cmd + shift + e          最近修改文件</li>
<li>cmd + u                  打开父类</li>
</ul>
<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><ul>
<li>cmd + number             打开工具面板</li>
<li>shift + esc              关闭当前工具面板</li>
<li>cmd + shift + F12        关闭所有面板</li>
<li>esc                      焦点切换回编辑器</li>
<li>F12                      重新打开上次所在工具面板</li>
<li>alt + F12                打开terminal</li>
<li>ctrl + tab               在最近打开tab间切换</li>
<li>ctrl + h                 继承结构</li>
<li>ctrl + alt + h           方法调用路径</li>
</ul>
<h3 id="导航（二）"><a href="#导航（二）" class="headerlink" title="导航（二）"></a>导航（二）</h3><ul>
<li>cmd + shift + h          方法结构            </li>
<li>alt + F1                 在Finder中打开</li>
<li>cmd + []                 光标历史跳转</li>
<li>cmd + ,                  打开设置</li>
<li>cmd + down               打开项目设置</li>
<li>cmd + l                  跳转到指定行</li>
<li>F2                       跳转到下一个报错的位置</li>
</ul>
<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><ul>
<li>cmd + shift + enter      语句补全</li>
<li>alt + enter              智能纠错</li>
<li>tab/enter                代码补全</li>
<li>!                        取反补全</li>
<li>cmd + j                  模板方法</li>
<li>.                        后缀补全</li>
<li>cmd + p                  查看方法参数</li>
<li>cmd + shift + up/down    上下移动代码</li>
<li>cmd + /                  注释一行</li>
<li>cmd + alt + /            注释多行</li>
</ul>
<h3 id="编辑（二）"><a href="#编辑（二）" class="headerlink" title="编辑（二）"></a>编辑（二）</h3><ul>
<li>cmd + alt + t            Surround with</li>
<li>shift + j                合并下一行代码为一行</li>
<li>cmd + alt + l            格式化代码</li>
<li>cmd + n                  生成代码</li>
<li>ctrl + space             唤出自动补全</li>
<li>cmd + F12                当前类内容结构</li>
<li>hold alt                 块操作</li>
<li>cmd + y                  方法预览</li>
<li>ctrl + shift + q         上下文信息</li>
</ul>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><ul>
<li>ctrl + o                 重写方法</li>
<li>ctrl + i                 实现方法</li>
<li>cmd + alt + m            抽取方法</li>
</ul>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul>
<li>shift + F10                 run</li>
<li>cmd + F9                    make</li>
</ul>
<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><ul>
<li>F8                          下一步</li>
<li>F7                          进入</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul>
<li>cmd + f                       </li>
<li>cmd + shift + f               全局搜索</li>
<li>cmd + alt + F7                预览方法调用</li>
<li>alt + F7                      方法调用</li>
</ul>
<h2 id="万能键"><a href="#万能键" class="headerlink" title="万能键"></a>万能键</h2><ul>
<li>cmd + shift + a </li>
</ul>
<p>ppt:</p>
<p><a href="http://w4lle.github.io/sliders/androidstudio-shortcurts/index.html" target="_blank" rel="external">http://w4lle.github.io/sliders/androidstudio-shortcurts/index.html</a></p>
<p>本文链接： <a href="http://w4lle.com/2016/12/14/AndroidStudio-shotcurts-md/">http://w4lle.com/2016/12/14/AndroidStudio-shotcurts-md/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;快捷键&quot;&gt;&lt;a href=&quot;#快捷键&quot; class=&quot;headerlink&quot; title=&quot;快捷键&quot;&gt;&lt;/a&gt;快捷键&lt;/h1&gt;&lt;p&gt;整理了下常用的快捷键&lt;br&gt;因为我用AndroidStudio的vim插件，所以在编辑这块没有整理太多。&lt;br&gt;需要的同学可以自己学些下。&lt;/p&gt;
&lt;p&gt;熟记这些快捷键 + vim = 基本不用鼠标 = 提升效率50%&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp3 源码浅析</title>
    <link href="http://w4lle.com/2016/12/06/OkHttp/"/>
    <id>http://w4lle.com/2016/12/06/OkHttp/</id>
    <published>2016-12-06T08:20:52.000Z</published>
    <updated>2017-01-06T01:53:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前的底层网络库基本就是Apache HttpClient和HttpURLConnection。由于HttClient比较难用，官方在Android2.3以后就不建议用了，并且在Android5.0以后废弃了HttpClient，在Android6.0更是删除了HttpClient。</p>
<p>HttpURLConnection是一种多用途、轻量极的HTTP客户端，使用它来进行HTTP操作可以适用于大多数的应用程序，但是在Android 2.2版本之前存在一些bug，所以官方建议在Android2.3以后替代HttpClient，Volley就是按版本分区使用这两个网络库。</p>
<p>然而随着开源届扛把子Square的崛起，OkHttp的开源，这两个网络库只能被淹没在历史洪流中。Android4.4以后HttpURLConnection的底层已经替换成OkHttp实现。OkHttp配合同样是Square开源的Retrofit，网络请求变得更简便，功能更强大。</p>
<h1 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h1><p>OkHttp是一个现代，快速，高效的网络库，OkHttp 库的设计和实现的首要目标是高效。</p>
<ul>
<li>支持 HTTP/2和SPDY，这使得对同一个主机发出的所有请求都可以共享相同的套接字连接；</li>
<li>如果 HTTP/2和SPDY不可用，OkHttp会使用连接池来复用连接以提高效率。</li>
<li>支持Gzip降低传输内容的大小</li>
<li>支持Http缓存</li>
<li>会从很多常用的连接问题中自动恢复。如果服务器配置了多个IP地址，OkHttp 会自动重试一个主机的多个 IP 地址。</li>
<li>使用Okio来大大简化数据的访问与存储，提高性能</li>
</ul>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>简单的异步请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line">    Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">            .url(url)</div><div class="line">            .build();</div><div class="line"></div><div class="line">    client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Request request, IOException e)</span>  </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            System.out.println(response.body().string());</div><div class="line">        &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>使用非常的简答，发送请求，拿到异步结果。</p>
<h2 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a>OkHttpClient</h2><p>跟下源码，OkHttpClient.newCall实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Call</span>.<span class="title">Factory</span></span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    Dispatcher dispatcher;</div><div class="line">    Proxy proxy;</div><div class="line">    List&lt;Protocol&gt; protocols;</div><div class="line">    List&lt;ConnectionSpec&gt; connectionSpecs;</div><div class="line">    <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">final</span> List&lt;Interceptor&gt; networkInterceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    ProxySelector proxySelector;</div><div class="line">    CookieJar cookieJar;</div><div class="line">    Cache cache;</div><div class="line">    InternalCache internalCache;</div><div class="line">    SocketFactory socketFactory;</div><div class="line">    SSLSocketFactory sslSocketFactory;</div><div class="line">    CertificateChainCleaner certificateChainCleaner;</div><div class="line">    HostnameVerifier hostnameVerifier;</div><div class="line">    CertificatePinner certificatePinner;</div><div class="line">    Authenticator proxyAuthenticator;</div><div class="line">    Authenticator authenticator;</div><div class="line">    ConnectionPool connectionPool;</div><div class="line">    Dns dns;</div><div class="line">    <span class="keyword">boolean</span> followSslRedirects;</div><div class="line">    <span class="keyword">boolean</span> followRedirects;</div><div class="line">    <span class="keyword">boolean</span> retryOnConnectionFailure;</div><div class="line">    <span class="keyword">int</span> connectTimeout;</div><div class="line">    <span class="keyword">int</span> readTimeout;</div><div class="line">    <span class="keyword">int</span> writeTimeout;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    ...</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RealCall(<span class="keyword">this</span>, request);</div><div class="line">    ...</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OkHttpClient通过Builder实例化，实现了Call.Factory接口创建了一个RealCall的实例，而RealCall是Call接口的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Call</span> </span>&#123;</div><div class="line">  <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</div><div class="line">  <span class="function">Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isExecuted</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span></span>;</div><div class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</div><div class="line">    <span class="function">Call <span class="title">newCall</span><span class="params">(Request request)</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="RealCall"><a href="#RealCall" class="headerlink" title="RealCall"></a>RealCall</h2><p>RealCall中封装了OKHttpClient和Request</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">RealCall</span><span class="params">(OkHttpClient client, Request originalRequest)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.client = client;</div><div class="line">    <span class="keyword">this</span>.originalRequest = originalRequest;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</div><div class="line">    enqueue(responseCallback, <span class="keyword">false</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</div><div class="line">      executed = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback, forWebSocket));</div><div class="line">  &#125;</div><div class="line">  </div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callback responseCallback;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> forWebSocket;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AsyncCall</span><span class="params">(Callback responseCallback, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>(<span class="string">"OkHttp %s"</span>, redactedUrl().toString());</div><div class="line">      <span class="keyword">this</span>.responseCallback = responseCallback;</div><div class="line">      <span class="keyword">this</span>.forWebSocket = forWebSocket;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        Response response = getResponseWithInterceptorChain(forWebSocket);</div><div class="line">        <span class="keyword">if</span> (canceled) &#123;</div><div class="line">          signalledCallback = <span class="keyword">true</span>;</div><div class="line">          responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          signalledCallback = <span class="keyword">true</span>;</div><div class="line">          responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        <span class="keyword">if</span> (signalledCallback) &#123;</div><div class="line">          <span class="comment">// Do not signal the callback twice!</span></div><div class="line">          Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">//注意这一句代码</span></div><div class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>调用enqueue封装成AsyncCall交给OKHttpClient的dispatcher线程池执行。</p>
<h2 id="Dispatcher线程池"><a href="#Dispatcher线程池" class="headerlink" title="Dispatcher线程池"></a>Dispatcher线程池</h2><p>OkHttp的dispatcher参数是直接new出来的。先看下enqueue方法，将AsyncCall当做参数传递进来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</div><div class="line">  <span class="comment">/** 最大并发请求数为64 */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequests = <span class="number">64</span>;</div><div class="line">  <span class="comment">/** 每个主机最大请求数为5 */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequestsPerHost = <span class="number">5</span>;</div><div class="line"></div><div class="line">  <span class="comment">/** 线程池 */</span></div><div class="line">  <span class="keyword">private</span> ExecutorService executorService;</div><div class="line"></div><div class="line">  <span class="comment">/** 准备执行的请求 */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line"></div><div class="line">  <span class="comment">/** 正在执行的异步请求，包含已经取消但未执行完的请求 */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line"></div><div class="line">  <span class="comment">/** 正在执行的同步请求，包含已经取消单未执行完的请求 */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">      runningAsyncCalls.add(call);</div><div class="line">      executorService().execute(call);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      readyAsyncCalls.add(call);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</div><div class="line">      executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</div><div class="line">          <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> executorService;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造一个线程池ExecutorService：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">executorService = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">    <span class="number">0</span>, <span class="comment">//corePoolSize 最小并发线程数,如果是0的话，空闲一段时间后所有线程将全部被销毁。</span></div><div class="line">    Integer.MAX_VALUE, <span class="comment">//maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理</span></div><div class="line">    <span class="number">60</span>, <span class="comment">//keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间</span></div><div class="line">    TimeUnit.SECONDS,<span class="comment">//单位秒</span></div><div class="line">    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),<span class="comment">//工作队列,先进先出        Util.threadFactory("OkHttp Dispatcher", false));//单个线程的工厂</span></div></pre></td></tr></table></figure>
<p>构建了一个最大线程数为Integer.MAX_VALUE的线程池，也就是说，是个不设最大上限的线程池（其实有限制64个），有多少任务添加进来就新建多少线程，以保证I/O任务中高阻塞低占用的过程中，不会长时间卡在阻塞上。当工作完成后，线程池会在60s内相继关闭所有线程。</p>
<p>还记得刚才在AsyncCall.execute() finally中的内容吗</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">finally &#123;</div><div class="line">    client.dispatcher().finished(this);</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">  </div><div class="line">  /** Used by &#123;@code AsyncCall#run&#125; to signal completion. */</div><div class="line">  synchronized void finished(AsyncCall call) &#123;</div><div class="line">    if (!runningAsyncCalls.remove(call)) throw new AssertionError(&quot;AsyncCall wasn&apos;t running!&quot;);</div><div class="line">    promoteCalls();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line"></div><div class="line">  //Dispatcher.java</div><div class="line">  private void promoteCalls() &#123;</div><div class="line">  //超过阈值 返回</div><div class="line">    if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.</div><div class="line">    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.</div><div class="line"></div><div class="line">    for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</div><div class="line">      AsyncCall call = i.next();</div><div class="line"></div><div class="line">      if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">        i.remove();</div><div class="line">        runningAsyncCalls.add(call);</div><div class="line">        executorService().execute(call);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>当AsyncCall执行完成后，调用Disptcher的finish()方法，调用promoteCalls()方法，如果超过阈值，继续等待，否则取出缓存区的任务执行，顺序是先进先出。</p>
<p>Dispatcher线程池总结</p>
<ul>
<li>调度线程池Disptcher实现了高并发，低阻塞的实现</li>
<li>采用Deque作为缓存，先进先出的顺序执行</li>
<li>任务在try/finally中调用了finished函数，控制任务队列的执行顺序，而不是采用锁，减少了编码复杂性提高性能</li>
</ul>
<h2 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h2><p>调度基本整明白了，AsyncCall 中的execute具体内容还没有分析，主要就一行代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    ...</div><div class="line">    Response response = getResponseWithInterceptorChain(forWebSocket);</div><div class="line">    ...</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Response <span class="title">getResponseWithInterceptorChain</span><span class="params">(<span class="keyword">boolean</span>     forWebSocket)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">Interceptor.Chain chain = <span class="keyword">new</span>         ApplicationInterceptorChain(<span class="number">0</span>, originalRequest, forWebSocket);</div><div class="line"><span class="keyword">return</span> chain.proceed(originalRequest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从方法名字基本可以猜到是干嘛的，调用<code>chain.proceed(originalRequest);</code>将request传递进来，从拦截器链里拿到返回结果。那么拦截器Interceptor是干嘛的，Chain是干嘛的呢？继续往下看ApplicationInterceptorChain</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationInterceptorChain</span> <span class="keyword">implements</span> <span class="title">Interceptor</span>.<span class="title">Chain</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Request request;</div><div class="line"></div><div class="line">    ApplicationInterceptorChain(<span class="keyword">int</span> index, Request request, <span class="keyword">boolean</span> forWebSocket) &#123;</div><div class="line">      <span class="keyword">this</span>.index = index;</div><div class="line">      <span class="keyword">this</span>.request = request;</div><div class="line">      <span class="keyword">this</span>.forWebSocket = forWebSocket;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Connection <span class="title">connection</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Request <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> request;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">      <span class="comment">// If there's another interceptor in the chain, call that.</span></div><div class="line">      <span class="keyword">if</span> (index &lt; client.interceptors().size()) &#123;</div><div class="line">        Interceptor.Chain chain = <span class="keyword">new</span> ApplicationInterceptorChain(index + <span class="number">1</span>, request, forWebSocket);</div><div class="line">        Interceptor interceptor = client.interceptors().get(index);</div><div class="line">        Response interceptedResponse = interceptor.intercept(chain);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (interceptedResponse == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"application interceptor "</span> + interceptor</div><div class="line">              + <span class="string">" returned null"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> interceptedResponse;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// No more interceptors. Do HTTP.</span></div><div class="line">      <span class="keyword">return</span> getResponse(request, forWebSocket);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>ApplicationInterceptorChain实现了Interceptor.Chain接口，持有Request的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">  <span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Chain</span> </span>&#123;</div><div class="line">    <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">    <span class="function">Connection <span class="title">connection</span><span class="params">()</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>proceed方法中判断index（此时为0）是否小于client.interceptors(List<interceptor> )的大小，如果小于也就是说client.interceptors还有Interceptor，那么就再封装一个ApplicationInterceptorChain，只不过index + 1，然后取出第index个Interceptor将chain传递进去。传递进去干嘛呢？我们看一个用法，以实际项目为例</interceptor></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">HttpLoggingInterceptor interceptor = <span class="keyword">new</span> HttpLoggingInterceptor(<span class="keyword">new</span> RetrofitLogger());</div><div class="line">        interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);</div><div class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</div><div class="line">        .addInterceptor(interceptor)</div><div class="line">        .retryOnConnectionFailure(<span class="keyword">true</span>)</div><div class="line">        .connectTimeout(<span class="number">15</span>, TimeUnit.SECONDS)</div><div class="line">        .addInterceptor(getCommonParameterInterceptor())</div><div class="line">        .addNetworkInterceptor(getTokenInterceptor())</div><div class="line">        .build();</div><div class="line">        </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Interceptor <span class="title">getCommonParameterInterceptor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interceptor() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            Request originalRequest = chain.request();</div><div class="line">            Request request = originalRequest;</div><div class="line">            <span class="keyword">if</span> (!originalRequest.method().equalsIgnoreCase(<span class="string">"POST"</span>)) &#123;</div><div class="line">                HttpUrl modifiedUrl = originalRequest.url().newBuilder()</div><div class="line">                        .addQueryParameter(<span class="string">"version_code"</span>, String.valueOf(AppUtils.getVersionCode()))</div><div class="line">                        .addQueryParameter(<span class="string">"app_key"</span>, <span class="string">"nicepro"</span>)</div><div class="line">                        .addQueryParameter(<span class="string">"app_device"</span>, <span class="string">"Android"</span>)</div><div class="line">                        .addQueryParameter(<span class="string">"app_version"</span>, AppUtils.getVersionName())</div><div class="line">                        .addQueryParameter(<span class="string">"token"</span>, AccountUtils.getToken())</div><div class="line">                        .build();</div><div class="line">                request = originalRequest.newBuilder().url(modifiedUrl).build();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> chain.proceed(request);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Interceptor <span class="title">getTokenInterceptor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interceptor() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            Request originalRequest = chain.request();</div><div class="line">            Request authorised = originalRequest.newBuilder()</div><div class="line">                    .header(<span class="string">"app-key"</span>, <span class="string">"nicepro"</span>)</div><div class="line">                    .header(<span class="string">"app-device"</span>, <span class="string">"Android"</span>)</div><div class="line">                    .header(<span class="string">"app-version"</span>, AppUtils.getVersionName())</div><div class="line">                    .header(<span class="string">"os"</span>, AppUtils.getOs())</div><div class="line">                    .header(<span class="string">"os-version"</span>, AppUtils.getAndroidVersion() + <span class="string">""</span>)</div><div class="line">                    .header(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>)</div><div class="line">                    .header(<span class="string">"User-Agent"</span>, <span class="string">"Android/retrofit"</span>)</div><div class="line">                    .header(<span class="string">"token"</span>, AccountUtils.getToken())</div><div class="line">                    .build();</div><div class="line">            <span class="keyword">return</span> chain.proceed(authorised);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到每个Interceptor的intercept方法中做了一些操作后，最后都会调用<code>chain.proceed(request)</code>方法，而这个chain就是每次prceed方法中生成的ApplicationInterceptorChain，用index+1的方式递归调用OkHttClient中的Interceptors，进行拦截操作，比如可以用来监控log，修改请求，修改结果，供开发者自定义参数添加等等，然后最终调用的还是最初的index=0的那个chain的proceed方法中的<code>getResponse(request, forWebSocket);</code>。</p>
<p>可以说OkHttp是用chain串联起拦截器，而每个拦截器都有能力返回Response，返回Response即终止整个调用链，这种设计模式称为<a href="https://zh.wikipedia.org/wiki/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">责任链模式</a>。这种模式为OkHttp提供了强大的装配能力，极大的提高了OkHttp的扩展性和可维护性。</p>
<p>在Android系统中最典型的责任链模式就是View的Touch传递机制，一层一层传递直到被消费。</p>
<p>官方的一张图就能很好的解释Interceptor<br><img src="https://raw.githubusercontent.com/wiki/square/okhttp/interceptors@2x.png" alt=""><br>整个流程很清晰。这种设计真是太棒了，值得学习！</p>
<h2 id="连接池复用"><a href="#连接池复用" class="headerlink" title="连接池复用"></a>连接池复用</h2><p>我们知道进行一次tcp网络请求，一般要三次握手连接，四次握手断开连接。一次完整的http请求过程见下图。</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/http.jpg" alt=""></p>
<p>如果请求重复的地址，那么重复的连接和断开连接就成了延长整个时间的的重要因素，特别是在复杂的网络环境下，每次请求传输数据的大小将不再是请求速度的决定性因素。</p>
<p>http有一种<code>keepalive connections</code>的机制，可以在传输后仍然保持连接，当客户端需要再次获取数据时，直接使用刚刚空闲下来的连接而不需要再次握手。</p>
<p>Okhttp支持5个并发KeepAlive，默认链路生命为5分钟(链路空闲后，保持存活的时间)，关于OkHttp连接池复用详细请看这篇文章 <a href="http://www.jianshu.com/p/92a61357164b" target="_blank" rel="external">OkHttp3源码分析[复用连接池]</a>。</p>
<h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><p>对比上一张图的一次完整的Http请求，在复杂的天朝网络环境下，相信大多数开发者都碰到过很奇怪的网络问题，比如运营商动态插入辣鸡html代码嵌入广告，比如运营商缓存请求数据导致用户请求到的数据不是最新的问题，比如某些运营商只支持<code>put\post</code>请求，而不支持<code>delete</code>请求，比如运营商。。。这些问题大部分都跟DNS相关。</p>
<p>为了解决DNS劫持的问题，我们在薄荷app上做了很多优化工作，比如使用HTTP DNS（我们使用的DNSPod）代替系统自带的libc库去查询运营商的DNS服务器，直接拿到IP地址进行IP直连，其中又做了一些缓存和选择最优IP的一些操作。解决掉了很大一部分用户反馈的网络问题。</p>
<p>而在OkHttp中，可以直接配置DNS，默认是系统自带的<code>Dns.SYSTEM</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Try each address for best behavior in mixed IPv4/IPv6 environments.</span></div><div class="line">List&lt;InetAddress&gt; addresses = address.dns().lookup(socketHost);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = addresses.size(); i &lt; size; i++) &#123;</div><div class="line">  InetAddress inetAddress = addresses.get(i);</div><div class="line">  inetSocketAddresses.add(<span class="keyword">new</span> InetSocketAddress(inetAddress, socketPort));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意结果是数组，即一个域名可能会有多个IP，如果一个IP不通，会自动重连下一个IP。</p>
<p>开发者就可以新建一个Dns类复写<code>lookup</code>方法通过HTTP DNS请求IP地址，其中新建一个<code>HttpDNSClient</code>来请求DNS，插入拦截器来配置缓存时间，容错处理等等，然后在构建OkHttpClient时加入<code>dns</code>方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">client = <span class="keyword">new</span> OkHttpClient.Builder().addNetworkInterceptor(getLogger())</div><div class="line">        .dispatcher(getDispatcher())</div><div class="line">        <span class="comment">//配置DNS查询实现</span></div><div class="line">        .dns(HTTP_DNS)</div><div class="line">        .build();</div></pre></td></tr></table></figure>
<p>这样的全局HTTP DNS解析真是足够简单高效，并且完全是无侵入性的，丝毫不影响正常的网络请求。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文基本讲了下OkHttp3的大概流程，Interceptor的基本原理，DNS的可选配置等。涉及到socket和Okio流相关的都没有讲到，有兴趣的读者可以在参考文章自行搜索。总结来说，OkHttp基本可以满足日常开发的需求，并且性能足够强大，配合Retrofit + Rxjava更是效率翻倍。如果你在开发新的项目，强烈建议你扔掉Volley，拥抱Retrofit。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.jianshu.com/p/aad5aacd79bf" target="_blank" rel="external">OkHttp3源码分析[综述]</a></li>
<li><a href="http://www.jianshu.com/p/9803a6efb672" target="_blank" rel="external">OkHttp3应用[HTTP DNS的实现]</a></li>
<li><a href="https://gold.xitu.io/post/581311cabf22ec0068826aff" target="_blank" rel="external">从OKHttp框架看代码设计</a></li>
<li><a href="http://blog.piasy.com/2016/07/11/Understand-OkHttp/" target="_blank" rel="external">拆轮子系列：拆 OkHttp</a></li>
<li><a href="http://blog.csdn.net/liudong8510/article/details/7908093" target="_blank" rel="external">一次完整的Http请求过程</a></li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2016/12/06/OkHttp/">http://w4lle.com/2016/12/06/OkHttp/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;之前的底层网络库基本就是Apache HttpClient和HttpURLConnection。由于HttClient比较难用，官方在And
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
  </entry>
  
</feed>
