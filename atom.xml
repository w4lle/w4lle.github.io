<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>w4lle&#39;s Notes</title>
  <subtitle>Eeeee... va?</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://w4lle.com/"/>
  <updated>2018-11-16T03:36:21.000Z</updated>
  <id>http://w4lle.com/</id>
  
  <author>
    <name>w4lle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>51信用卡 Android 架构演进实践</title>
    <link href="http://w4lle.com/2018/11/16/51credit-android-architecture/"/>
    <id>http://w4lle.com/2018/11/16/51credit-android-architecture/</id>
    <published>2018-11-16T03:24:10.000Z</published>
    <updated>2018-11-16T03:36:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着业务的快速扩张，原本小作坊式的单个工程的开发模式越来与不能满足实际需求。早在两年多以前，51信用卡管家就向下沉淀出了单独的公用基础库，一些通用的功能组件和个别独立的业务被拆分成 SDK，形成了一套中型项目、多人并行的开发模式，也为未来组件化拆分做准备。</p>
<a id="more"></a>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwi9479hnhj31g00uk49x.jpg" alt="image-20181023162224348"></p>
<p>这套框架运行了一段时间之后，伴随着单应用内业务需求的增加、开发人员数量的增多、基础库数量的膨胀，导致了一些问题：</p>
<ul>
<li>主工程代码耦合严重，牵一发而动全身</li>
<li>需求测试影响面大，不能聚焦单一业务模块</li>
<li>主工程代码越来越多，编译耗时</li>
<li>依赖倒置，业务代码依赖App工程</li>
<li>SDK 界限模糊，基础库和业务库界限不明确</li>
<li>业务模块间可以任意依赖调用，依赖规则不明确</li>
<li>类库越来越多，不好管理</li>
</ul>
<p>除了以上问题，动态化需求也越来越强烈，依赖 Hybrid + H5 打开页面慢的问题也凸显出来。</p>
<p>这些问题推动我们更进一步的升级开发构架。</p>
<h1 id="组件化-or-插件化"><a href="#组件化-or-插件化" class="headerlink" title="组件化 or 插件化"></a>组件化 or 插件化</h1><h2 id="动态化"><a href="#动态化" class="headerlink" title="动态化"></a>动态化</h2><p>最近两年，插件化框架层出不穷，各大厂都放出了自家开源的插件化框架。作为 Native 动态化与性能兼顾的插件化方案，很多公司选择插件化作为动态化技术方案。动态性通常有两部分的作用：一是动态热修复；二是动态下发业务插件。对于第一点，我们有热修复框架可以完成这部分工作；对于第二点，我们使用了 Hybrid 加载H5的方式实现，虽然性能上有所欠缺，但完全切到 Native 来做有点推倒重来的意思，并且跟业界同学交流后，对于动态下发业务插件用到的情况也不多，业务更新主要还是依靠 App 升级来实现。技术方案没有最优解，选择适合自己的才是最好的。</p>
<p>由于插件化也存在一些弊端，比如不可避免的 hook framework、修改 aapt、包装 Gradle Plugin、代理组件等等非常规操作，日常维护也是一笔不小的开销，稳定性、兼容性、新版本适配等等问题都需要考虑进去。对于 Android 端是否使用插件化，公司内部做过一些讨论，结论是不急着上，边走边看，先把业务组件拆分出来再说。</p>
<p>如今回过头看，自从 Android P发布以来，限制 hook framework 后，插件化逐渐开始式微，后面走向大概率是维护成本越来越高，成本收益比逐渐降低，最终弃坑不用。</p>
<p>除了插件化外，动态化方案近两年比较火的就是以 ReactNative、Weex 为代表的大前端方向，结合51信用卡的实际情况，最终选择拥抱大前端， Weex 作为动态化方案，以 Native 为主， Hybrid 离线化方案为辅，Weex 逐步迭代的架构开发模式。</p>
<p>Weex 的基础建设和前端同学合作，历经大半年时间，目前已经稳定应用在51信用卡各个 App 上，Weex 作为动态化页面的首选方案，已经完成了线上数百个页面的开发需求。配合离线化方案，各项性能指标也都达到要求。</p>
<h2 id="组件分离"><a href="#组件分离" class="headerlink" title="组件分离"></a>组件分离</h2><p>代码解耦与代码隔离，最有效的方案是工程隔离。审视我们最初的方案，每个 SDK 对应单独的仓库，通过 maven 依赖，通过工程分离隔离代码，这种方案没有问题，只不过需要往前更近一步，各个业务模块也需要独立主工程，拆分成独立的业务组件。</p>
<p>同时，划分清楚代码边界，控制依赖关系，梳理清楚层次结构，最终形成如下图所示的架构。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwrpnjc8xdj31hc0u0gt5.jpg" alt="组件化层次.001"></p>
<p>整体架构上提供三种容器：</p>
<ul>
<li>Native 容器，采用组件化架构，用于原生业务开发</li>
<li>Hybrid 容器，webview 加载 H5，配合离线化方案</li>
<li>Weex 容器，用于编写常规的页面，js 动态转化成 Native 控件，天然具有动态化特性，配合离线化方案，达到页面秒开的效果，同时共用 Hybrid 沉淀出的比较完善的 PG 方法</li>
</ul>
<p>同时，Hybrid 和 Weex 依赖于原生提供的方法，通过 JsBridge 进行通信，目前共有 200 多个 PG 方法供 js 调用。长远来看，这三种容器并不会互相取代，相反地，它们应该是相互依存、取长补短、长期共存的状态。</p>
<h1 id="组件化实践"><a href="#组件化实践" class="headerlink" title="组件化实践"></a>组件化实践</h1><p>Native 容器对应上图中各个层级的定义：</p>
<ul>
<li>工程 App，各个应用工程，目前已有十多个应用并行开发，51信用卡管家作为平台应用，其余应用为独立的业务工程应用</li>
<li>业务组件，独立的业务组件，一般为复合业务组件，api 与实现分离，相互之间依赖隔离</li>
<li>基础业务 SDK，独立的小的单功能模块，提供基础功能，目前这一层级中还包含遗留未改造的部分业务组件</li>
<li>基础 Lib，业务无关的基础组件</li>
</ul>
<p>组件化拆分的核心诉求是解耦合，提高组件内聚，所以应该从诉求出发，在沿用当下开发模式，并且不强依赖组件化框架的情况下，逐渐的进行组件化拆分。</p>
<p>通过工程隔离进而进行组件化拆分后，基本可以解决上面提到的问题：</p>
<ul>
<li>高内聚，低耦合，代码边界清晰，代码变动影响面可以准确评估</li>
<li>提高开发效率，每个组件可以独立打包，单独调试，最多几十秒就可以完成打包过程</li>
<li>每个组件负责组件内的事情，理论上只要保证组件内部稳定，接入工程 App 后也不会产生新的问题</li>
<li>降低 App 工程编译时间，最理想的情况是，App 工程仅仅是一个空壳，用于加载各个组件</li>
</ul>
<p>解耦，一般需要避免直接依赖，转为间接依赖，简单来说就是依赖隔离。对于组件化而言，每个组件都是单独的实现，单个组件对外提供的服务尽可能单一，依赖尽可能少；同时，依赖其它组件功能或页面的情况下，尽可能避免直接依赖，最好依赖中间层进行集中式管理，然后再进行逻辑分发。所以我们一般采用分总分的结构：组件内部分别注册，编译时生成汇总代码、运行时集中式管理，调用时处理逻辑分发。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwrpngbj7qj30yy0i4di0.jpg" alt="image-20181026181156315"></p>
<p>组件化需要解耦处理的几个基础模块：</p>
<ul>
<li>页面路由</li>
<li>模块间调用</li>
<li>消息总线</li>
<li>数据总线</li>
</ul>
<p>下面依次介绍。</p>
<h2 id="页面路由"><a href="#页面路由" class="headerlink" title="页面路由"></a>页面路由</h2><p>路由分发本质上是把直接依赖引用转化为中心化管理分发的一个过程，由于组件化拆分后，各个业务组件间不存在直接的依赖关系，所以必然要有一个统一收集页面跳转规则进而再分发的过程。</p>
<p>51信用卡在 2017 年就在进行路由化实践，以应对后面进行的组件化拆分需求，并沉淀出一套自研的路由框架 U51OkDeepLink，它也采用分总分结构，主要原理是组件内注册路由，编译时在组件内生成独立的路由表，并用 AOP 在编译时做好所有组件内路由表汇总的工作，调用初始化方法时进行路由表汇总，页面跳转时再进行管理分发，其用法很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//组件内注册路由</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleService</span> </span>&#123;</div><div class="line">    <span class="meta">@Path</span>(<span class="string">"/main"</span>)</div><div class="line">    <span class="meta">@Activity</span>(MainActivity.class)</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startMainActivity</span><span class="params">(@Query(<span class="string">"key"</span>)</span> String key)</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//其余组件唤起页面</span></div><div class="line"><span class="keyword">new</span> DeepLinkClient(context).buildRequest(<span class="string">"old://app/main?key=value"</span>).addQuery(<span class="string">"key2"</span>, <span class="string">"2"</span>).start();</div></pre></td></tr></table></figure>
<p>并且支持强大的异步特性，支持跳转过程中的中间逻辑处理。</p>
<p>其原理图如下</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwrpnhjehsj31ju0uewka.jpg" alt="router"></p>
<p>感兴趣的读者可以阅读 <a href="https://www.jianshu.com/p/8a3eeeaf01e8" target="_blank" rel="external">Android 组件化 —— 路由设计最佳实践</a> 获取更多技术细节。</p>
<h2 id="模块间调用"><a href="#模块间调用" class="headerlink" title="模块间调用"></a>模块间调用</h2><p>组件间层次和边界模糊问题的产生，根本原因是各个业务组件间的相互依赖关系混乱，为了进行业务组件间的隔离，首先要做好组件之间的服务调用解耦。</p>
<p>这里采用的是 ServiceLoader 的模式，组件工程目录一般如下所示</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwrpnfmr75j30bs052glm.jpg" alt="image-20181024204942179"></p>
<p>每个组件内一般声明三个 module：</p>
<ul>
<li>api module，声明对外暴露的服务接口和对外暴露的实体类及 Event 事件</li>
<li>imp module，依赖 api module，是 api module 的具体实现，不对外暴露细节，不允许其他组件对 imp module 进行直接依赖</li>
<li>app module，是工程的壳，可以直接运行调试，通过 SDKTemplate 创建生成，包含各种运行时所需环境</li>
</ul>
<p>业务组件之间依赖 api 库的服务接口，imp 库作为实现动态查找。版本发布时，同时发布 api 和 imp 两个库，并且保证 api 和 imp 具有相同版本号，这个在组件发版时统一管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//组件内 api module 接口声明</span></div><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestService</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//组件内 imp module 接口实现</span></div><div class="line"><span class="meta">@ServiceImpl</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//跨组件调用</span></div><div class="line">compile <span class="string">'com.u51.android:test-lib-api:$version'</span></div><div class="line"></div><div class="line">CommentService service = ServicesLoader.getInstance().getService(TestService.class);</div><div class="line">service.sayHello();</div></pre></td></tr></table></figure>
<p>它的实现原理与路由类似，也是采用分总分结构，在编译时通过 APT 生成汇总代码，调用时动态查找注入 Service 及其实现类的绑定关系。</p>
<p>与路由初始化汇总路由表不同的是，ServiceLoader 在调用时查找，省去了初始化的逻辑，Service 不会像路由这么多，查找起来不会存在遍历太慢的问题。</p>
<h2 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h2><p>消息总线是基于 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 实现的跨三端（Native、Hybrid、Weex）事件管理分发组件 U51EventBus。跨三端是指在任意一端注册监听后，在事件触发时都可以得到响应。</p>
<p>对于原生开发来说，EventBus 本身可以满足需求，虽然有点事件满天飞的缺点，但是还在可接受范围之内。对于业务组件来说，其 Event 类需要放在 api module 中进行暴露。</p>
<p>对于 Hybrid 和 Weex 来说，一般的 bridge 都是 callback 形式得到异步响应，对于全局事件通知支持不太友好。通过 bridge 通道连接 U51EventBus 消息总线，打通跨三端全局的事件监听及分发，得以实现任意事件可以在 Native、H5、Weex 之间相互发送和监听。比如，类似登陆、登出操作在 Native 发出后，全局已打开的 H5 或 Weex 页面可以立即得到感知。</p>
<p>其实现原理也是采用分总分结构，在编译时对 EventBus 进行了定制封装，事件分发还是使用的原有的 EventBus 分发逻辑。</p>
<h2 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h2><p>数据存储采用基于 <a href="https://developer.android.com/topic/libraries/architecture/room" target="_blank" rel="external">Room</a> 实现的统一 KV 存储框架，底层数据库依然是 sqlite，性能这块没有做特别强调，强制其在子线程中进行操作，用于支持日常开发中配置和业务数据的存取操作。</p>
<p>另外，数据总线支持按模块进行存取，每个业务组件都可以定义自有 tag，避免字段冲突问题。</p>
<h1 id="跨平台混合开发实践"><a href="#跨平台混合开发实践" class="headerlink" title="跨平台混合开发实践"></a>跨平台混合开发实践</h1><p>无论从早期的 PhoneGap、Cordova，还是近年来比较火的 ReactNative、Weex，到最近两年崛起的 Flutter，跨平台混合开发一直深受众多开发青睐。究其原因，还是其跨平台和动态化是原生开发所不具备的特性。</p>
<h2 id="Hybrid-容器实践"><a href="#Hybrid-容器实践" class="headerlink" title="Hybrid 容器实践"></a>Hybrid 容器实践</h2><p>Native 和 H5 混合开发一般是比较常见的混合开发模式，H5 开发效率高、迭代快速、不依赖 App 发版，51信用卡众多 App 产品中，有很多页面都是用 H5 来开发，嵌入原生 App 中使用 webview 进行加载显示。</p>
<p>早期 H5 容器在各个 App 中分别独立实现，没有统一的架构和规范，导致对 H5 的支持效率较低，PG 方法（来源于 PhoneGap）的开发、测试和维护都相当的混乱，重复性工作太多。</p>
<p>Native 层提供一套通用性强、功能丰富、稳定性高的 H5 容器对业务的高速发展至关重要。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwxgmjrohtj31kw0zkwth.jpg" alt="image-20181105173903973"></p>
<h3 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h3><p>由于 H5 不具备直接调用原生方法，所以原生壳要提供一套通用的通信方式，一般为 JsBridge，在 Android 端，实现 JsBridge 通信的通道一般有以下几种：</p>
<ul>
<li>shouldOverrideUrlLoading</li>
<li>addJavascriptInterface</li>
<li>onJsPrompt/onJsAlert</li>
</ul>
<p>而通道不是关键，怎样管理和维护 PG 方法调用才是核心。为此，我们把每个方法定义为一个 Plugin，用插件的形式管理 PG 方法，这样可以做到每个插件独立运行，互不干扰。插件管理也是采用分总分结构，在各个业务组件中分别注册，编译是通过 APT 生成汇总代码，运行时进行插件汇总，最后调用通过 PluginManager 查找分发逻辑。</p>
<p>插件注册代码如下，其中 <code>onExecute()</code> 方法在 js 调用该方法时触发，执行结果通过 <code>evaluateJavaScript()</code> 方法异步返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@JsPlugin</span>(name = TestPlugin.PLUGIN_NAME, loadOnInit = <span class="keyword">false</span>, version = <span class="number">1</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPlugin</span> <span class="keyword">extends</span> <span class="title">EnNiuJsPlugin</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PLUGIN_NAME = <span class="string">"TestPlugin"</span>;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPluginName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> PLUGIN_NAME;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onExecute</span><span class="params">(String args)</span> </span>&#123;</div><div class="line">        doSomething();                    </div><div class="line">        callbackContext.callback(...);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，H5 容器和插件都具有 Activity 生命周期感知能力，插件的生命周期：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwxgmhf6r9j31kw16eas1.jpg" alt="image-20181105191433330"></p>
<h3 id="配套设施"><a href="#配套设施" class="headerlink" title="配套设施"></a>配套设施</h3><p>插件统一通过插件管理平台进行维护管理，目前已有200+插件。PG 插件作为基础通用功能，采取集中式管理机制，任何人在新增、修改插件都需要进行相关负责人审核，以避免出现 Android、iOS 两端实现不统一，版本间实现不统一等问题。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwxgmi1nm7j31kw0ebdl6.jpg" alt="image-20181105191949792"></p>
<p>插件调试通过调试平台进行操作，浏览器中打开调试地址，App 端通过调试工具扫码建立连接，即可进行插件调试。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwxgmiq9l1j31kw110thw.jpg" alt="image-20181105192429943"></p>
<h3 id="离线加载"><a href="#离线加载" class="headerlink" title="离线加载"></a>离线加载</h3><p>Hybrid 混合开发的一大劣势就是性能比较差，打开页面较慢，特别是在弱网情况下。由于51信用卡业务大部分都是静态资源请求，参考业界做法，我们实现了动态下发离线包的方式来提升H5页面打开速度。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwxgmkmdnlj31ca12wn45.jpg" alt="lixianbao"></p>
<p>这里细节问题不具体展开。</p>
<p>除了以上提到的实践外，我们还做了很多工作，比如 UI 统一、Back 键拦截、公共参数处理、PG 白名单机制、H5监控、PG 方法监控等等，限于文章篇幅，这里不再一一列出，敬请关注后续相关文章。</p>
<h2 id="Weex-容器实践"><a href="#Weex-容器实践" class="headerlink" title="Weex 容器实践"></a>Weex 容器实践</h2><p>在 Hybrid 已有配套基础上，51信用卡选择了 Weex 作为跨平台方案，经过一年的踩坑填坑过程，目前已经有 20+ 个项目、数百个 Weex 页面在线上稳定运行，并且，目前 Weex 方案趋于成熟，已经作为51信用卡端内首选业务方案。</p>
<h3 id="共享插件"><a href="#共享插件" class="headerlink" title="共享插件"></a>共享插件</h3><p>由于 Hybrid 良好的面向接口编程特性，在进行 Weex 基础建设过程中，很方便的就把已有的插件集成进来，并且共享已沉淀的配套设施。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ENBridgeModule</span> <span class="keyword">extends</span> <span class="title">WXModule</span> </span>&#123;</div><div class="line">    <span class="meta">@JSMethod</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String method, String args, JSCallback jsCallback)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        weexWebView = weexEngine.getWeexVirtualWebView();</div><div class="line">        EnNiuJsBridge enNiuJsBridge = weexWebView.getEnNiuJsBridge();</div><div class="line">        enNiuJsBridge.notify(pg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注册 Weex 的 Module，并且每个 Weex Engine 中会新建出一个虚拟 webview，用于桥接 JsBridge 进而调用 PluginManager 进行插件逻辑分发。</p>
<p>Weex 容器实践在之前的文章中已经提到过一部分，具体请看 <a href="https://mp.weixin.qq.com/s/PSquf5ILDykC9jYFu911qg" target="_blank" rel="external">Weex避坑指南-理论篇 </a>，后续还将有 Weex 实践相关的文章放出，这里不做过多篇幅的介绍，敬请关注后续相关文章。</p>
<h1 id="工程化实践"><a href="#工程化实践" class="headerlink" title="工程化实践"></a>工程化实践</h1><p>工程化本质上是为了提高研发效率。51信用卡客户端团队自研的大风车管理平台，用于 App 管理、持续集成、类库管理、发版管理等，围绕客户端研发上下游流程，建立统一的管理入口。</p>
<p>目前，51信用卡 iOS 和 Android 共 30 多个应用 App、 200 多个类库依托大风车平台进行管理。下面主要介绍下类库管理相关内容。</p>
<h2 id="类库管理"><a href="#类库管理" class="headerlink" title="类库管理"></a>类库管理</h2><p>51信用卡目前有 100 多个 Android 类库，每个类库对应一个独立的 Gitlab 仓库。过多的独立组件及独立仓库，管理起来有些麻烦。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwrpnk3uc9j31kw0scaj6.jpg" alt="image-20181030193630574"></p>
<p>依托于大风车平台，所有类库的名称、最新版本及标签类型都会展示在列表页，标签类型对应组件化架构的层次结构，包括：基础组件、单业务功能组件、多业务功能组件。</p>
<p>在类库详情页，会有库的功能描述、groupId:artifactId 依赖信息、版本历史记录、分支信息、README、CHANGELOG、负责人等详情信息。</p>
<p>所有的类库管理工作都可以在大风车完成，包括新建类库、类库发版、查阅相关信息等等，这大大提高了基础组的研发效率，降低了团队间的沟通成本。</p>
<p>并且 App 工程中，该 App 所依赖的所有类库信息一目了然，在多人维护、多类库并行开发、类库频繁发版的情况下，依赖类库信息 check 更加便捷。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwrpng2bwcj31kw1540z0.jpg" alt="image-20181031160854953"></p>
<h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p>由于类库之间是仓库隔离，所以它们的依赖关系是 maven 依赖，所有类库的 aar 包都需要发布到内部 maven 服务器上，上传工作由 PublishMavenPlugin 完成。</p>
<h3 id="SNAPSHOT-预览版"><a href="#SNAPSHOT-预览版" class="headerlink" title="SNAPSHOT 预览版"></a>SNAPSHOT 预览版</h3><p>对于开发调试阶段，每个类库自带 DemoApp 工程，所以采用源码依赖；开发完成后，类库使用<code>SNAPSHOT</code>版本（比如 1.0.0-SNAPSHOT）发布到 maven 服务器，接入 App 工程后 push 代码触发大风车打包，进行集成测试。需要修改类库时，可以再重复发布相同版本的<code>SNAPSHOT</code>版本。</p>
<p><code>SNAPSHOT</code>版本可以在开发同学自己的机器上进行打包发布。</p>
<h3 id="正式版"><a href="#正式版" class="headerlink" title="正式版"></a>正式版</h3><p>对于发布阶段，类库必须使用正式版本发布，由于正式版本不可重复发布，这也就要求开发同学保证每个正式版本的版本质量，在正式发布前都应达到发布标准。</p>
<p>由于类库内部也存在相互依赖的情况，所以在类库正式发布时，不允许依赖包含<code>SNAPSHOT</code>版本的类库，<code>DependencyCheck</code>工作也会在  PublishMavenPlugin 完成。</p>
<p>同时，正式版本不允许开发同学在本机打包发布，PublishMavenPlugin 会检测是否在云端打包环境。功能分支经 CodeReview 后合并 master 分支，然后创建对应版本的 tag，触发大风车进行打包发布工作，发布成功后，会邮件通知 Android 组同学，并附带 CHANGELOG。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwxgz042voj312q0qa44m.jpg" alt="image-20181105204154472"></p>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><p>App 工程下采用 compile 依赖，compile 会解析类库 maven 包中的 pom 文件，进而间接依赖 pom 文件中声明的其他类库，也就是依赖传递。正常情况下，依赖传递会减少不必要的类库声明，当出现版本冲突时会自动处理 merge 操作。</p>
<p>但是，在多人协同工作、多类库并行开发情况下，事情变得有些复杂。考虑一种情况，应用 A 依赖类库 B，类库 B 依赖类库 C，正常情况下，A 中只需要声明依赖 B 即可，C 会被依赖传递过去。如果 C 中改变了方法签名，并且在应用 A 中显示声明依赖 C，编译时和运行时会分别出现什么情况？在编译时没有问题，正常编译通过；在运行时，当运行到类库 B 中使用的类库 C 中被改变签名的方法时，App crash。这是因为，maven 在处理类库版本 merge 时，会将 C 升级到最高版本，而此时 B 中已经编译好的 class 中使用的还是老版本 C 中的方法。</p>
<p>为了处理这个问题，我们使用 APICheckGradlePlugin 在编译时进行 check 操作，当发现被调用的方法找不到时，主动报错，将错误提前暴露在编译期，而非在运行时。同时内部强调 API 接口的向下兼容性，不用的方法标记为废弃，而非直接修改其方法签名或删除方法。</p>
<p>APICheckGradlePlugin 核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    c.getClassPool().get(callClassName)</div><div class="line">    isClassNotFound = <span class="keyword">false</span></div><div class="line">    m.getMethod()</div><div class="line">&#125; <span class="keyword">catch</span> (NotFoundException e) &#123;</div><div class="line">    <span class="keyword">if</span> (isClassNotFound) &#123;</div><div class="line">        dealException(String.format(<span class="string">"在%s类中的第%d行是用到的%s类不存在"</span>, className, line, callClassName))</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dealException(String.format(<span class="string">"在%s类中的第%d行是用到的%s类的%s方法不存在"</span>, className, line, callClassName, methodName))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="多module发布"><a href="#多module发布" class="headerlink" title="多module发布"></a>多module发布</h3><p>上文中提到，在多业务组件库工程中会有多个 module，一个 api module，一个 imp module，在使用 DemoApp 编译调试时采用源码依赖， imp module 依赖 api module，App 依赖 imp module，这样在打包上传 maven 时，会出现无法一起上传的问题；并且我们也要确保 api 和 imp 的版本号一致。为了解决这个问题，需要在上传时动态修改他们的 pom 文件，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">modifyPom &#123; pom -&gt;</div><div class="line">    pom.dependencies.findAll &#123; dep -&gt; dep.groupId == rootProject.name &#125;.collect &#123; dep -&gt;</div><div class="line">        dep.groupId = pom.groupId = rootProject.groupId</div><div class="line">        dep.version = pom.version = rootProject.sdkVersion</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="一键创建项目"><a href="#一键创建项目" class="headerlink" title="一键创建项目"></a>一键创建项目</h2><h3 id="模板工程"><a href="#模板工程" class="headerlink" title="模板工程"></a>模板工程</h3><p>由于每个新建组件类库的 App 工程需要运行时环境基本相同，包括网络环境、调试环境、gradle 配置、通用依赖配置等等，这些重复性的工作最好放在一起统一处理。为此，我们创建了组件库的模板工程，只需要 clone 下来模板仓库，然后修改一些代码即可开发需求代码。</p>
<h3 id="一键创建类库"><a href="#一键创建类库" class="headerlink" title="一键创建类库"></a>一键创建类库</h3><p>但是，这种方式依然有很多共性的工作，比如 clone 代码、修改类库名、修改 groupId:artifactId、创建新的类库仓库、push 代码、在大风车中新建类库关联仓库地址等等操作。这些共性操作仍然可以用机器来操作，所以我们在大风车新建类库这一步中，把前面所有要做的事情全部做完，只需要在新建类库时填入必要的参数，一键就可以创建出可用的类库项目。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwrpngxyd4j31g40mqdht.jpg" alt="image-20181031201425732"></p>
<h3 id="一键创建应用"><a href="#一键创建应用" class="headerlink" title="一键创建应用"></a>一键创建应用</h3><p>随着我司 App 越来越多，新建 App 的配置同样面临类库刚开始时的困扰，新建 App 与新建类库本质上是一样的，只不过所需参数更多一些，并且这些参数可能不固定，有些 App 需要有些 App 不需要。参考类库，我们提取共性操作，创建了 App 的模板工程，并且对接大风车，一键即可创建出 App 工程，那些可变的参数留在模板工程中按需手动配置。</p>
<h2 id="模块负责人"><a href="#模块负责人" class="headerlink" title="模块负责人"></a>模块负责人</h2><p>在组件化初步开始时，我们的每个模块都有固定的负责人，每个人手上都有固定的若干个模块，责任人对自己负责的模块负责。</p>
<p>但是随着组内的人员变动和业务变动，导致一些模块频繁易主，一些模块的文档长期处于不被维护状态，README 和 CHANGELOG 常年失修。</p>
<p>依赖大风车的类库管理，重新为每个模块指定负责人，并且梳理现存类库哪些缺失文档，进行补全。自从大风车自动抄送类库发版 CHANGELOG 后，CHANGELOG 不全的情况也大幅改善，基本每个新的版本都会附上该版本所做修改。</p>
<p>同时，我们也强调 CodeReview 机制，每个模块在提测前进行 CodeReview，强制merge request 必须有人点赞后才能合并 master 分支等等代码审查机制。未来，我们可能会进一步实践负责人 backup 方案，主副负责人相互 review，扩大大家技术视野的同时，可以进一步提高大家的主人翁意识。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好的架构不是设计出来的，而是演进出来的。本文简单阐述了51信用卡 Android 架构演进的一些实践经验，同时我们坚信技术方案没有最优解，重要的是要选择选择适合自己的。脱离所处环境和问题本身谈技术方案，都将不能得到适合自身的开发架构。同时，我们也应当吸取和借鉴业界优秀的架构和设计理念，并将其根据自身适用场景加以改造，在理论和实践中逐渐交替探索演进。</p>
<p>当然，我们目前所使用的架构依然存在一些问题，比如组件拆分不完全、主工程业务仍然很多、CodeReview 机制不健全、代码扫描不够严格、一些组件库没有严格按照 api 工程来改造、一些老的组件依然没有 api module等等问题。我们也应该看到，正是因为这些实际的问题在推动我们进行技术改造，架构升级。同时，我们也要审视行业内大的方向，紧跟技术趋势，主动拥抱变化，毕竟技术世界唯一不变的，便是变化。</p>
<p>本文链接： <a href="http://w4lle.com/2018/11/16/51credit-android-architecture/">http://w4lle.com/2018/11/16/51credit-android-architecture/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着业务的快速扩张，原本小作坊式的单个工程的开发模式越来与不能满足实际需求。早在两年多以前，51信用卡管家就向下沉淀出了单独的公用基础库，一些通用的功能组件和个别独立的业务被拆分成 SDK，形成了一套中型项目、多人并行的开发模式，也为未来组件化拆分做准备。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android热补丁之Robust（三）坑和解</title>
    <link href="http://w4lle.com/2018/06/20/robust-2/"/>
    <id>http://w4lle.com/2018/06/20/robust-2/</id>
    <published>2018-06-20T08:18:16.000Z</published>
    <updated>2018-06-20T13:12:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前两篇文章中，分析了 Android 热补丁框架 Robust 中，几个重要的流程包括：</p>
<ul>
<li>补丁加载过程</li>
<li>基础包插桩过程</li>
<li>补丁包自动化生成过程</li>
</ul>
<p>本篇文章主要分析下集成过程中遇到的坑以及分析问题的思路和最终的解决方案。包含：</p>
<ul>
<li>打补丁包出错？</li>
<li>Robust 定义的 API 不够用怎么办？</li>
<li>插件 Plugin Transform 的顺序问题？</li>
<li>与 Aspectj 冲突怎么办？</li>
<li>static 方法中包含 super 方法怎么办？</li>
</ul>
<a id="more"></a>
<p>系列文章:</p>
<ul>
<li><a href="http://w4lle.com/2017/03/31/robust-0/">Android热补丁之Robust原理解析(一)</a></li>
<li><a href="http://w4lle.com/2018/05/28/robust-1/">Android热补丁之Robust（二）自动化补丁原理解析</a></li>
<li><a href="http://w4lle.com/2018/05/29/robust-2/">Android热补丁之Robust（三）坑和解</a></li>
</ul>
<h1 id="打补丁包出错？"><a href="#打补丁包出错？" class="headerlink" title="打补丁包出错？"></a>打补丁包出错？</h1><p>在打补丁包过程中，碰到了一个错误 <code>execute command java -jar /Users/wanglinglong/Develop/u51/Credit51/CreditCardManager/robust/dx.jar --dex --output=classes.dex  meituan.jar error</code>，找了一大圈最后发现是jdk老版本在Mac上的一个bug，升级jdk就好了，参考 <a href="https://stackoverflow.com/questions/43003012/class-javalaunchhelper-is-implemented-in-two-places?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa" target="_blank" rel="external">Class JavaLaunchHelper is implemented in two places</a></p>
<h1 id="Robust-定义的-API-不够用怎么办？"><a href="#Robust-定义的-API-不够用怎么办？" class="headerlink" title="Robust 定义的 API 不够用怎么办？"></a>Robust 定义的 API 不够用怎么办？</h1><p>Robust 提供了一些 API 可供开发者扩展使用，比如：<br>添加类库依赖 <code>compile &#39;com.meituan.robust:robust:0.4.82&#39;</code>，其中 <code>PatchManipulateImp</code> 类的一些可扩展方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> List&lt;Patch&gt; <span class="title">fetchPatchList</span><span class="params">(Context context)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">verifyPatch</span><span class="params">(Context context, Patch patch)</span></span>;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">ensurePatchExist</span><span class="params">(Patch patch)</span></span>;</div></pre></td></tr></table></figure>
<p>但是在一些情况下，这些可扩展方法并不能满足我们的需求。</p>
<p>为了满足定制化需求，可以弃用 <code>com.meituan.robust:robust</code>，自己实现一套补丁加载逻辑，这个实现起来难度并不太大，主要补丁加载流程都可以参考 Robust 官方实现，具体加载逻辑可参考本系列第一篇文章，这里不再深入。</p>
<h1 id="插件-Plugin-Transform-的顺序问题？"><a href="#插件-Plugin-Transform-的顺序问题？" class="headerlink" title="插件 Plugin Transform 的顺序问题？"></a>插件 Plugin Transform 的顺序问题？</h1><p>首先，要找到 Gradle Plugin 编译过程中对于自定义 Transform 的处理，具体流程读者可以自行搜索查看，这里只给出关键代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">TaskManager.java</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Creates the post-compilation tasks for the given Variant.</div><div class="line"> *</div><div class="line"> * These tasks create the dex file from the .class files, plus optional intermediary steps like</div><div class="line"> * proguard and jacoco</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPostCompilationTasks</span><span class="params">(</span></span></div><div class="line">        @NonNull <span class="keyword">final</span> VariantScope variantScope) &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// ---- Code Coverage first -----</span></div><div class="line">    ...</div><div class="line">    <span class="comment">// Merge Java Resources.</span></div><div class="line">    createMergeJavaResTransform(variantScope);</div><div class="line">    <span class="comment">// ----- External Transforms -----</span></div><div class="line">    <span class="comment">// apply all the external transforms.</span></div><div class="line">    List&lt;Transform&gt; customTransforms = extension.getTransforms();</div><div class="line">    List&lt;List&lt;Object&gt;&gt; customTransformsDependencies = extension.getTransformsDependencies();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = customTransforms.size(); i &lt; count; i++) &#123;</div><div class="line">        Transform transform = customTransforms.get(i);</div><div class="line">        List&lt;Object&gt; deps = customTransformsDependencies.get(i);</div><div class="line">        transformManager</div><div class="line">                .addTransform(taskFactory, variantScope, transform)</div><div class="line">                .ifPresent(</div><div class="line">                        t -&gt; &#123;</div><div class="line">                            <span class="keyword">if</span> (!deps.isEmpty()) &#123;</div><div class="line">                                t.dependsOn(deps);</div><div class="line">                            &#125;</div><div class="line">                            <span class="comment">// if the task is a no-op then we make assemble task depend on it.</span></div><div class="line">                            <span class="keyword">if</span> (transform.getScopes().isEmpty()) &#123;</div><div class="line">                                variantScope.getAssembleTask().dependsOn(t);</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在生成 Dex 任务之前，会处理所有的自定义 Transform 任务，逻辑是按照顺序遍历然后处理任务依赖关系，那么从dzhe’l这里我们可以知道，Transform 的执行顺序是按照插件的声明顺序来执行的，也就是说，哪个 plugin 的声明在前，其对应的 Transform 就在前执行，举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apply plugin: <span class="string">'pluginA'</span></div><div class="line">apply plugin: <span class="string">'pluginB'</span></div></pre></td></tr></table></figure>
<p>那么对应的 TransformA 任务就会先于 TransfromB 任务执行。</p>
<p>好了，知道了 Transform 的执行顺序问题，再来看下 Robust 插件的顺序问题。首先来看下基线包的处理插件 <code>apply plugin: &#39;robust&#39;</code>，其逻辑是在每个方法中前置插入补丁加载逻辑代码，用于拦截基线包中的原有逻辑，达到修复方法的目的。<br>如果 robust Plugin 是先于其他插件执行的，那么会出现 Robust 插入代码后，再执行其他插件的代码逻辑，这样会有问题吗？其实要具体问题具体分析，可能会有问题，也可能没有问题。举个例子，我们项目中使用了听云，而且是较老的版本(2.5.9)，其插件内部插入代码没有用到 Transform，而是用了另外一种技术，其会导致不管在哪里声明插件，其处理顺序都是最后执行，那么对于 Robust 基线包插件来说，当基线包插件插入完代码后，又会去执行听云插件的插入代码逻辑，所以可能会看到以下这种代码：</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/robust_tingyun.png" alt=""></p>
<p>实际上，我们最终想要的结果是这样的：</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/robust_tingyun_right.png" alt=""></p>
<p>然而，如果仔细观察这种错误的代码插入逻辑，实际上并没有对最终的热修复逻辑产生影响。是因为在生成补丁包过程中，他们的执行顺序也是这样的，即听云插件最后执行，这样的结果就是Robust 自动化补丁插件在生成插件后就强制停止了整个编译流程，听云插件根本就没有机会执行。所以最后补丁包中仅仅会包含剔除了Robust 基线包插件插入的代码以及听云插件插入的代码。可以理解为第一张图中把红框下面的代码通过热修复的方式移入了红框里面，然后return。</p>
<p>对于听云来说，2.8.x版本之后，插入代码的逻辑也由 Tranform 来执行，也就是说，对于听云来说，不管是怎么样的执行顺序，都不会与 Robust 发生兼容性问题。</p>
<p>所以还是要具体问题具体分析，这里仅仅提供一些排查问题的思路。</p>
<h1 id="与-Aspectj-冲突怎么办？"><a href="#与-Aspectj-冲突怎么办？" class="headerlink" title="与 Aspectj 冲突怎么办？"></a>与 Aspectj 冲突怎么办？</h1><p>我们项目中大量使用了 AOP 技术，涉及到的框架有 Aspectj、javassist、ASM。其中由于  javassist 和 ASM 完全是有自己控制的，所以不会有问题，而对于 Aspectj 来说就没这么简单了。</p>
<p>刚开始介入就碰到了这样一个问题 <code>Caused by: java.lang.ClassCastException: com.meituan.robust.patch.MainFragmentActivityPatch cannot be cast to com.zhangdan.app.activities.MainFragmentActivity</code>，是一个类型强转错误。</p>
<p>问题分析，由于 Aspectj 框架为开发者省略了很多逻辑，开发者只需要编写切面相关代码即可，所以需要梳理清楚 Aspectj 的原理：</p>
<p>首先贴下未混淆的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">MainFragmentActivity.class</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCreate_aroundBody2</span><span class="params">(MainFragmentActivity mainFragmentActivity, Bundle bundle, JoinPoint joinPoint)</span> </span>&#123;</div><div class="line">        onCreate_aroundBody1$advice(mainFragmentActivity, bundle, joinPoint, MainFragmentActivity$$Injector.aspectOf(), (ProceedingJoinPoint) joinPoint);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> onCreate_aroundBody1$advice(MainFragmentActivity mainFragmentActivity, Bundle bundle, JoinPoint joinPoint, MainFragmentActivity$$Injector mainFragmentActivity$$Injector, ProceedingJoinPoint proceedingJoinPoint) &#123;</div><div class="line">        <span class="keyword">if</span> (!PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;mainFragmentActivity, bundle, joinPoint, mainFragmentActivity$$Injector, proceedingJoinPoint&#125;, <span class="keyword">null</span>, changeQuickRedirect, <span class="keyword">true</span>, <span class="number">11888</span>, <span class="keyword">new</span> Class[]&#123;MainFragmentActivity.class, Bundle.class, JoinPoint.class, MainFragmentActivity$$Injector.class, ProceedingJoinPoint.class&#125;, Void.TYPE).isSupported) &#123;</div><div class="line">            MainFragmentActivity mainFragmentActivity2 = (MainFragmentActivity) proceedingJoinPoint.getTarget();</div><div class="line">            onCreate_aroundBody0(mainFragmentActivity, bundle, proceedingJoinPoint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;bundle&#125;, <span class="keyword">this</span>, changeQuickRedirect, <span class="keyword">false</span>, <span class="number">11849</span>, <span class="keyword">new</span> Class[]&#123;Bundle.class&#125;, Void.TYPE).isSupported) &#123;</div><div class="line">            JoinPoint makeJP = Factory.makeJP(ajc$tjp_0, <span class="keyword">this</span>, <span class="keyword">this</span>, bundle);</div><div class="line">            MainFragmentActivity$$Injector.aspectOf().onCreate(<span class="keyword">new</span> AjcClosure3(<span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>, bundle, makeJP&#125;).linkClosureAndJoinPoint(<span class="number">69648</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCreate_aroundBody0</span><span class="params">(MainFragmentActivity mainFragmentActivity, Bundle bundle, JoinPoint joinPoint)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;mainFragmentActivity, bundle, joinPoint&#125;, <span class="keyword">null</span>, changeQuickRedirect, <span class="keyword">true</span>, <span class="number">11887</span>, <span class="keyword">new</span> Class[]&#123;MainFragmentActivity.class, Bundle.class, JoinPoint.class&#125;, Void.TYPE).isSupported) &#123;</div><div class="line">            <span class="keyword">super</span>.onCreate(bundle);</div><div class="line">            JudgeEmulatorUtil.uploadEmulatorInfoIfNeed(mainFragmentActivity);</div><div class="line">            instance = mainFragmentActivity;</div><div class="line">            mainFragmentActivity.setContentView(R.layout.main_activity);</div><div class="line">            ButterKnife.bind((Activity) mainFragmentActivity);</div><div class="line">            mainFragmentActivity.initUserCenterManager();</div><div class="line">            mainFragmentActivity.mainPagerAdapter = <span class="keyword">new</span> MainPagerAdapter(mainFragmentActivity, mainFragmentActivity.getSupportFragmentManager());</div><div class="line">            mainFragmentActivity.userInfoPresenter = <span class="keyword">new</span> UserInfoPresenter();</div><div class="line">            mainFragmentActivity.refreshOldDataPresenter = <span class="keyword">new</span> RefreshOldDataPresenter();</div><div class="line">            mainFragmentActivity.tabRedPointPresenter = <span class="keyword">new</span> TabRedPointPresenter(mainFragmentActivity);</div><div class="line">            mainFragmentActivity.getMsgCenterRedPresenter = <span class="keyword">new</span> GetMsgCenterRedPresenter(mainFragmentActivity);</div><div class="line">            mainFragmentActivity.userInfoPresenter.setUserInfoView(mainFragmentActivity);</div><div class="line">            mainFragmentActivity.userInfoPresenter.startGetCurUserInfoDBUseCase();</div><div class="line">            INSTANCE_FLAG = <span class="number">1</span>;</div><div class="line">            BaiduLocation.getInstance(ZhangdanApplication.getInstance()).start();</div><div class="line">            mainFragmentActivity.initToolBar();</div><div class="line">            mainFragmentActivity.showImportBillDialog();</div><div class="line">            mainFragmentActivity.onLoginCreate(bundle);</div><div class="line">            mainFragmentActivity.getLoggerABConfig();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>对应的patch 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragmentActivityPatch</span> </span>&#123;</div><div class="line">    MainFragmentActivity originClass;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainFragmentActivityPatch</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.originClass = (MainFragmentActivity) obj;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        StaticPart staticPart = (StaticPart) EnhancedRobustUtils.getStaticFieldValue(<span class="string">"ajc$tjp_0"</span>, MainFragmentActivity.class);</div><div class="line">        Log.d(<span class="string">"robust"</span>, <span class="string">"get static  value is ajc$tjp_0     No:  1"</span>);</div><div class="line">        JoinPoint joinPoint = (JoinPoint) EnhancedRobustUtils.invokeReflectStaticMethod(<span class="string">"makeJP"</span>, Factory.class, getRealParameter(<span class="keyword">new</span> Object[]&#123;staticPart, <span class="keyword">this</span>, <span class="keyword">this</span>, savedInstanceState&#125;), <span class="keyword">new</span> Class[]&#123;StaticPart.class, Object.class, Object.class, Object.class&#125;);</div><div class="line">        Object obj = (Injector) EnhancedRobustUtils.invokeReflectStaticMethod(<span class="string">"aspectOf"</span>, Injector.class, getRealParameter(<span class="keyword">new</span> Object[<span class="number">0</span>]), <span class="keyword">null</span>);</div><div class="line">        Object[] objArr = <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>, savedInstanceState, joinPoint&#125;;</div><div class="line">        Log.d(<span class="string">"robust"</span>, <span class="string">"  inner Class new      No:  2"</span>);</div><div class="line">        Object obj2 = (AjcClosure3) EnhancedRobustUtils.invokeReflectConstruct(<span class="string">"com.zhangdan.app.activities.MainFragmentActivity$AjcClosure3"</span>, getRealParameter(<span class="keyword">new</span> Object[]&#123;objArr&#125;), <span class="keyword">new</span> Class[]&#123;Object[].class&#125;);</div><div class="line">        <span class="keyword">if</span> (obj2 == <span class="keyword">this</span>) &#123;</div><div class="line">            obj2 = ((MainFragmentActivityPatch) obj2).originClass;</div><div class="line">        &#125;</div><div class="line">        ProceedingJoinPoint proceedingJoinPoint = (ProceedingJoinPoint) EnhancedRobustUtils.invokeReflectMethod(<span class="string">"linkClosureAndJoinPoint"</span>, obj2, getRealParameter(<span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> Integer(<span class="number">69648</span>)&#125;), <span class="keyword">new</span> Class[]&#123;Integer.TYPE&#125;, AroundClosure.class);</div><div class="line">        Log.d(<span class="string">"robust"</span>, <span class="string">"invoke  method is       No:  3 linkClosureAndJoinPoint"</span>);</div><div class="line">        <span class="keyword">if</span> (obj == <span class="keyword">this</span>) &#123;</div><div class="line">            obj = ((MainFragmentActivityPatch) obj).originClass;</div><div class="line">        &#125;</div><div class="line">        EnhancedRobustUtils.invokeReflectMethod(<span class="string">"onCreate"</span>, obj, getRealParameter(<span class="keyword">new</span> Object[]&#123;proceedingJoinPoint&#125;), <span class="keyword">new</span> Class[]&#123;ProceedingJoinPoint.class&#125;, Injector.class);</div><div class="line">        Log.d(<span class="string">"robust"</span>, <span class="string">"invoke  method is       No:  4 onCreate"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们往下跟下 Aspectj 的调用流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">AjcClosure 类</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AroundClosure</span> </span>&#123;</div><div class="line">   ...</div><div class="line">    <span class="keyword">protected</span> Object[] state;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AroundClosure</span><span class="params">(Object[] state)</span> </span>&#123;</div><div class="line">    	<span class="keyword">this</span>.state = state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Object[] getState() &#123;</div><div class="line">      <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * This takes in the same arguments as are passed to the proceed</div><div class="line">	 * call in the around advice (with primitives coerced to Object types)</div><div class="line">	 */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">run</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ProceedingJoinPoint <span class="title">linkClosureAndJoinPoint</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">        <span class="comment">//TODO is this cast safe ?</span></div><div class="line">        ProceedingJoinPoint jp = (ProceedingJoinPoint)state[state.length-<span class="number">1</span>];</div><div class="line">        jp.set$AroundClosure(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">this</span>.bitflags = flags;</div><div class="line">        <span class="keyword">return</span> jp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AjcClosure 接收一个 Object 的对象数组，在基础包中，它的实现是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>, bundle, makeJP&#125;</div></pre></td></tr></table></figure>
<p>注意这个 <code>this</code>，代表的是MainFragmentActivity 对象。<br>相对应的看下patch包中的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object[] objArr = <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>, savedInstanceState, joinPoint&#125;;</div></pre></td></tr></table></figure>
<p>这里调用了下 <code>getRealParameter(new Object[]{objArr})</code> 进行了 this 转换，所以这里的this 也是MainFragmentActivity对象，这里是没问题的。<br>然后调用 <code>linkClosureAndJoinPoint</code> 方法得到 ProceedingJoinPoint 对象，当做参数传递给 MainFragmentActivity$$Injector.onCreate(ProceedingJoinPoint joinPoint)  方法，看下这个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">MainFragmentActivity$$Injector.class</div><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragmentActivity</span>$$<span class="title">Injector</span> </span>&#123;</div><div class="line">  <span class="meta">@Around</span>(<span class="string">"execution(* com.zhangdan.app.activities.MainFragmentActivity.onCreate(..))"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    MainFragmentActivity target = (MainFragmentActivity)joinPoint.getTarget();</div><div class="line">    ...</div><div class="line">    joinPoint.proceed();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>调用了 ProceedingJoinPoint.proceed 抽象方法，实现在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   JoinPointImpl.<span class="function">java</span></div><div class="line"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</div><div class="line">	<span class="comment">// when called from a before advice, but be a no-op</span></div><div class="line">		<span class="keyword">return</span> arc.run(arc.getState());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 <code>arc</code> 是 AroundClosure，<code>arc.getState()</code> 返回的是构造 AroundClosure 时传递过来的对象数组。<br>最后调用了抽象方法 <code>run(Object[] args)</code>，实现在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragmentActivity</span>$<span class="title">AjcClosure3</span> <span class="keyword">extends</span> <span class="title">AroundClosure</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ChangeQuickRedirect changeQuickRedirect;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> MainFragmentActivity$AjcClosure3(Object[] objArr) &#123;</div><div class="line">        <span class="keyword">super</span>(objArr);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">(Object[] objArr)</span> </span>&#123;</div><div class="line">        PatchProxyResult proxy = PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;objArr&#125;, <span class="keyword">this</span>, changeQuickRedirect, <span class="keyword">false</span>, <span class="number">11911</span>, <span class="keyword">new</span> Class[]&#123;Object[].class&#125;, Object.class);</div><div class="line">        <span class="keyword">if</span> (proxy.isSupported) &#123;</div><div class="line">            <span class="keyword">return</span> proxy.result;</div><div class="line">        &#125;</div><div class="line">        Object[] objArr2 = <span class="keyword">this</span>.state;</div><div class="line">        MainFragmentActivity.onCreate_aroundBody2((MainFragmentActivity) objArr2[<span class="number">0</span>], (Bundle) objArr2[<span class="number">1</span>], (JoinPoint) objArr2[<span class="number">2</span>]);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后调用 <code>MainFragmentActivity.onCreate_aroundBody2((MainFragmentActivity) objArr2[0], (Bundle) objArr2[1], (JoinPoint) objArr2[2]);</code>，整个 AOP 的流程就走通了。</p>
<p>最后总结下 Aspectj 的调用流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MainFragmentActivity.onCreate -&gt; </div><div class="line">MainFragmentActivity$$Injector.onCreate(ProceedingJoinPoint joinPoint) -&gt; </div><div class="line">ProceedingJoinPoint.proceed() -&gt; </div><div class="line">AroundClosure.run(Object[] args) -&gt;  </div><div class="line">MainFragmentActivity$AjcClosure3.run(Object[] objArr) -&gt; </div><div class="line">MainFragmentActivity.onCreate_aroundBody2((MainFragmentActivity) objArr2[<span class="number">0</span>], (Bundle) objArr2[<span class="number">1</span>], (JoinPoint) objArr2[<span class="number">2</span>]); -&gt; </div><div class="line">MainFragmentActivity.onCreate_aroundBody1$advice -&gt; </div><div class="line">MainFragmentActivity.onCreate_aroundBody0();</div></pre></td></tr></table></figure>
<p>最后的 <code>MainFragmentActivity.onCreate_aroundBody0();</code>方法实际上就是onCreate()的原始方法逻辑。</p>
<p>另外，对于修改后的代码，没有被打入补丁，也是可以解释的。<br>对于 auto-path-plugin，Transform 的顺序是 Aspectj -&gt; auto-patch.<br>那么，对于标记修改的 onCreate 方法来说，Aspectj 处理完后，onCreate 方法被替换成了代理，真正的方法实现被新生成的方法隐藏起来了。<br>而我们仅仅标记了旧的 onCreate 方法，其结果就是，Aspectj 的代理 onCreate 方法被 patch 了，而实际的方法虽然方法体内有我们的修复，但是由于没有标记 <code>@modify</code> 而被忽略。</p>
<p>因为是强转 crash，所以在 $$Injector 代码中插入一些 Log</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">MainFragmentActivity$$Injector.class</div><div class="line">    <span class="meta">@Around</span>(<span class="string">"execution(* com.zhangdan.app.activities.MainFragmentActivity.onCreate(..))"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;proceedingJoinPoint&#125;, <span class="keyword">this</span>, changeQuickRedirect, <span class="keyword">false</span>, <span class="number">11892</span>, <span class="keyword">new</span> Class[]&#123;ProceedingJoinPoint.class&#125;, Void.TYPE).isSupported) &#123;</div><div class="line">            MainFragmentActivity target = (MainFragmentActivity) proceedingJoinPoint.getTarget();</div><div class="line">            ...</div><div class="line">            Log.d(<span class="string">"robust-wll"</span>, <span class="string">"test for aspectj start "</span>);</div><div class="line">            ...</div><div class="line">            Log.d(<span class="string">"robust-wll"</span>, <span class="string">"getTarget : "</span> + proceedingJoinPoint.getTarget().getClass().getSimpleName());</div><div class="line">            Log.d(<span class="string">"robust-wll"</span>, <span class="string">"getThis : "</span> + proceedingJoinPoint.getThis().getClass().getSimpleName());</div><div class="line">            Log.d(<span class="string">"robust-wll"</span>, <span class="string">"getArgs[0] : "</span> + (proceedingJoinPoint.getArgs()[<span class="number">0</span>] != <span class="keyword">null</span> ? proceedingJoinPoint.getArgs()[<span class="number">0</span>].getClass().getSimpleName() : <span class="keyword">null</span>));</div><div class="line">            Field arcField = proceedingJoinPoint.getClass().getDeclaredField(<span class="string">"arc"</span>);</div><div class="line">            arcField.setAccessible(<span class="keyword">true</span>);</div><div class="line">            AroundClosure arc = (AroundClosure) arcField.get(proceedingJoinPoint);</div><div class="line">            <span class="keyword">if</span> (!(arc == <span class="keyword">null</span> || arc.getState() == <span class="keyword">null</span> || arc.getState().length &lt; <span class="number">3</span>)) &#123;</div><div class="line">                Object[] states = arc.getState();</div><div class="line">                Log.d(<span class="string">"robust-wll"</span>, <span class="string">"states[0] : "</span> + (states[<span class="number">0</span>] != <span class="keyword">null</span> ? states[<span class="number">0</span>].getClass().getSimpleName() : <span class="keyword">null</span>));</div><div class="line">                Log.d(<span class="string">"robust-wll"</span>, <span class="string">"states[1] : "</span> + (states[<span class="number">1</span>] != <span class="keyword">null</span> ? states[<span class="number">1</span>].getClass().getSimpleName() : <span class="keyword">null</span>));</div><div class="line">                Log.d(<span class="string">"robust-wll"</span>, <span class="string">"states[2] : "</span> + (states[<span class="number">2</span>] != <span class="keyword">null</span> ? states[<span class="number">2</span>].getClass().getSimpleName() : <span class="keyword">null</span>));</div><div class="line">            &#125;</div><div class="line">            Log.d(<span class="string">"robust-wll"</span>, <span class="string">"test for aspectj end "</span>);</div><div class="line">            proceedingJoinPoint.proceed();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在不加载补丁情况下的 log 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.184</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: test <span class="keyword">for</span> aspectj start </div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.184</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: getTarget : MainFragmentActivity</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.185</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: getThis : MainFragmentActivity</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.185</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: getArgs[<span class="number">0</span>] : <span class="keyword">null</span></div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.185</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: states[<span class="number">0</span>] : MainFragmentActivity</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.185</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: states[<span class="number">1</span>] : <span class="keyword">null</span></div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.186</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: states[<span class="number">2</span>] : JoinPointImpl</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.186</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: test <span class="keyword">for</span> aspectj end</div></pre></td></tr></table></figure>
<p>加载补丁后，log 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.885</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: test <span class="keyword">for</span> aspectj start </div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.885</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: getTarget : MainFragmentActivity</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.886</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: getThis : MainFragmentActivity</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.886</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: getArgs[<span class="number">0</span>] : <span class="keyword">null</span></div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.886</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: states[<span class="number">0</span>] : MainFragmentActivityPatch</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.886</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: states[<span class="number">1</span>] : <span class="keyword">null</span></div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.886</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: states[<span class="number">2</span>] : JoinPointImpl</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.886</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: test <span class="keyword">for</span> aspectj end</div></pre></td></tr></table></figure>
<p><strong>states[0] : MainFragmentActivityPatch</strong> 这个明显是不对的，所以我们知道了原因，是因为在构造 <code>AroundClosure</code> 时候传进来的参数不对。<br>报错地方对应于上面的分析，也就是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object[] objArr = <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>, savedInstanceState, joinPoint&#125;;</div><div class="line">Object obj2 = (AjcClosure3) EnhancedRobustUtils.invokeReflectConstruct(<span class="string">"com.zhangdan.app.activities.MainFragmentActivity$AjcClosure3"</span>, getRealParameter(<span class="keyword">new</span> Object[]&#123;objArr&#125;), <span class="keyword">new</span> Class[]&#123;Object[].class&#125;);</div></pre></td></tr></table></figure></p>
<p>结果就是，把一个含有3个对象的一维数据，编程了含有一个对象的二维数组，然后去 getRealParameter。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Object[] getRealParameter(Object[] objArr) &#123;</div><div class="line">    <span class="keyword">if</span> (objArr == <span class="keyword">null</span> || objArr.length &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> objArr;</div><div class="line">    &#125;</div><div class="line">    Object[] objArr2 = <span class="keyword">new</span> Object[objArr.length];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objArr.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (objArr[i] == <span class="keyword">this</span>) &#123;</div><div class="line">            objArr2[i] = <span class="keyword">this</span>.originClass;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            objArr2[i] = objArr[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> objArr2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而这个方法只判断了一维数组的情况，没有判断二维或多维数组的情况。终于找到原因了 😃<br>对应的修改方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Object[] getRealParameter(Object[] objArr) &#123;</div><div class="line">    <span class="keyword">if</span> (objArr == <span class="keyword">null</span> || objArr.length &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> objArr;</div><div class="line">    &#125;</div><div class="line">    Object[] objArr2 = <span class="keyword">new</span> Object[objArr.length];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objArr.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (objArr[i] <span class="keyword">instanceof</span> Object[]) &#123;</div><div class="line">            objArr2[i] = getRealParameter(((Object[]) objArr[i]));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (objArr[i] == <span class="keyword">this</span>) &#123;</div><div class="line">                objArr2[i] = <span class="keyword">this</span>.originClass;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                objArr2[i] = objArr[i];</div><div class="line">            &#125;</div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> objArr2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>castException 终于是搞定了。具体解决方法见 <a href="https://github.com/Meituan-Dianping/Robust/pull/259" target="_blank" rel="external">merge request #259</a>。</p>
<h1 id="static-方法中包含-super-方法怎么办？"><a href="#static-方法中包含-super-方法怎么办？" class="headerlink" title="static 方法中包含 super 方法怎么办？"></a>static 方法中包含 super 方法怎么办？</h1><p>看到这个标题可能会一脸懵逼，static 方法中怎么可能包含 super 调用？别急慢慢往下看。</p>
<p>书接上节，至于被 Aspectj  处理过的方法无法被打入 patch 的问题，理论上来说跟泛型的桥方法是类似的，解决方案也是 <code>@Modify -&gt; RobustModify.modify();</code>，修改后经验证，会报错。log如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">Caused by: javassist.CannotCompileException: [source error] not-available: <span class="keyword">this</span></div><div class="line">        at javassist.expr.MethodCall.replace(MethodCall.java:<span class="number">241</span>)</div><div class="line">        at javassist.expr.MethodCall$replace$<span class="number">2</span>.call(Unknown Source)</div><div class="line">        at com.meituan.robust.autopatch.PatchesFactory$<span class="number">1</span>.edit(PatchesFactory.groovy:<span class="number">144</span>)</div><div class="line">        at javassist.expr.ExprEditor.loopBody(ExprEditor.java:<span class="number">224</span>)</div><div class="line">        at javassist.expr.ExprEditor.doit(ExprEditor.java:<span class="number">91</span>)</div><div class="line">        at javassist.CtBehavior.instrument(CtBehavior.java:<span class="number">712</span>)</div><div class="line">        at javassist.CtBehavior$instrument$<span class="number">1</span>.call(Unknown Source)</div><div class="line">        at com.meituan.robust.autopatch.PatchesFactory.createPatchClass(PatchesFactory.groovy:<span class="number">76</span>)</div><div class="line">        at com.meituan.robust.autopatch.PatchesFactory.createPatch(PatchesFactory.groovy:<span class="number">310</span>)</div><div class="line">        at com.meituan.robust.autopatch.PatchesFactory$createPatch.call(Unknown Source)</div><div class="line">        at robust.gradle.plugin.AutoPatchTransform.generatPatch(AutoPatchTransform.groovy:<span class="number">190</span>)</div><div class="line">        at robust.gradle.plugin.AutoPatchTransform$generatPatch$<span class="number">0</span>.callCurrent(Unknown Source)</div><div class="line">        at robust.gradle.plugin.AutoPatchTransform.autoPatch(AutoPatchTransform.groovy:<span class="number">138</span>)</div><div class="line">        at robust.gradle.plugin.AutoPatchTransform$autoPatch.callCurrent(Unknown Source)</div><div class="line">        at robust.gradle.plugin.AutoPatchTransform.transform(AutoPatchTransform.groovy:<span class="number">97</span>)</div><div class="line">        at com.android.build.api.transform.Transform.transform(Transform.java:<span class="number">290</span>)</div><div class="line">        at com.android.build.gradle.internal.pipeline.TransformTask$<span class="number">2</span>.call(TransformTask.java:<span class="number">185</span>)</div><div class="line">        at com.android.build.gradle.internal.pipeline.TransformTask$<span class="number">2</span>.call(TransformTask.java:<span class="number">181</span>)</div><div class="line">        at com.android.builder.profile.ThreadRecorder.record(ThreadRecorder.java:<span class="number">102</span>)</div><div class="line">        ... <span class="number">27</span> more</div><div class="line">Caused by: compile error: not-available: <span class="keyword">this</span></div><div class="line">        at javassist.compiler.CodeGen.atKeyword(CodeGen.java:<span class="number">1908</span>)</div><div class="line">        at javassist.compiler.ast.Keyword.accept(Keyword.java:<span class="number">35</span>)</div><div class="line">        at javassist.compiler.JvstCodeGen.atMethodArgs(JvstCodeGen.java:<span class="number">358</span>)</div><div class="line">        at javassist.compiler.MemberCodeGen.atMethodCallCore(MemberCodeGen.java:<span class="number">569</span>)</div><div class="line">        at javassist.compiler.MemberCodeGen.atCallExpr(MemberCodeGen.java:<span class="number">537</span>)</div><div class="line">        at javassist.compiler.JvstCodeGen.atCallExpr(JvstCodeGen.java:<span class="number">244</span>)</div><div class="line">        at javassist.compiler.ast.CallExpr.accept(CallExpr.java:<span class="number">46</span>)</div><div class="line">        at javassist.compiler.CodeGen.atStmnt(CodeGen.java:<span class="number">338</span>)</div><div class="line">        at javassist.compiler.ast.Stmnt.accept(Stmnt.java:<span class="number">50</span>)</div><div class="line">        at javassist.compiler.CodeGen.atStmnt(CodeGen.java:<span class="number">351</span>)</div><div class="line">        at javassist.compiler.ast.Stmnt.accept(Stmnt.java:<span class="number">50</span>)</div><div class="line">        at javassist.compiler.Javac.compileStmnt(Javac.java:<span class="number">569</span>)</div><div class="line">        at javassist.expr.MethodCall.replace(MethodCall.java:<span class="number">235</span>)</div><div class="line">        ... <span class="number">45</span> more</div></pre></td></tr></table></figure></p>
<p>问题分析，根据堆栈显示，这里是在做替换 super 方法的逻辑，跟了下 plugin 的 debug，生成需要 replace 的 javassist 代码为 <code>{staticRobustonCreate(this,originClass,$$);}</code>，然后在 replace 后，javac 编译这条语句的时候跪了。<br>分析下需要替换的 super 的方法，这个方法实际上是 Aspectj 处理后的方法，根据上面分析的 Aspectj 的调用流程得知，该方法实际上是 onCreate 方法原始的逻辑，反编译出来如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCreate_aroundBody0</span><span class="params">(MainFragmentActivity mainFragmentActivity, Bundle bundle, JoinPoint joinPoint)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;mainFragmentActivity, bundle, joinPoint&#125;, <span class="keyword">null</span>, changeQuickRedirect, <span class="keyword">true</span>, <span class="number">11887</span>, <span class="keyword">new</span> Class[]&#123;MainFragmentActivity.class, Bundle.class, JoinPoint.class&#125;, Void.TYPE).isSupported) &#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(bundle);<span class="comment">//这里是需要替换的地方</span></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而 auto-patch 做的工作是将<code>super.onCreate</code>方法包装成 static 方法，正常生成的patch代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivityPatch</span> </span>&#123;</div><div class="line">    SecondActivity originClass;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecondActivityPatch</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.originClass = (SecondActivity) obj;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</div><div class="line">        staticRobustonCreate(<span class="keyword">this</span>,originClass,bundle);</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticRobustonCreate</span><span class="params">(SecondActivityPatch secondActivityPatch, SecondActivity secondActivity, Bundle bundle)</span> </span>&#123;</div><div class="line">        SecondActivityPatchRobustAssist.staticRobustonCreate(secondActivityPatch, secondActivity, bundle);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivityPatchRobustAssist</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticRobustonCreate</span><span class="params">(SecondActivityPatch secondActivityPatch, SecondActivity secondActivity, Bundle bundle)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(bundle);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而对于已经被 Aspectj 处理过的方法，是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCreate_aroundBody0</span><span class="params">(MainFragmentActivity mainFragmentActivity, Bundle bundle, JoinPoint joinPoint)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;mainFragmentActivity, bundle, joinPoint&#125;, <span class="keyword">null</span>, changeQuickRedirect, <span class="keyword">true</span>, <span class="number">11887</span>, <span class="keyword">new</span> Class[]&#123;MainFragmentActivity.class, Bundle.class, JoinPoint.class&#125;, Void.TYPE).isSupported) &#123;</div><div class="line">        <span class="comment">//super.onCreate(bundle);//这里是需要替换的地方</span></div><div class="line">        staticRobustonCreate(<span class="keyword">this</span>,originClass,bundle);</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在static 方法中使用了 <code>this</code>关键字，当然编译出错啦。同理这个 <code>originClass</code> 也不可以出现，因为它是非 static 变量。<br>由于 xxPatchRobustAssist.staticRobustonCreate() 方法并没有用到前两个变量(patch, activity)，直接传 null 行不行呢？经验证是不行的，原因如下。<br>看了下生成xxxPatchRobustAssist类的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PatchesAssistFactory</span> </span>&#123;</div><div class="line">    <span class="function">def</span></div><div class="line">    <span class="keyword">static</span> <span class="title">createAssistClass</span><span class="params">(CtClass modifiedClass, String patchClassName, CtMethod removeMethod)</span> &#123;</div><div class="line">       ....</div><div class="line">        StringBuilder staticMethodBuidler = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">if</span> (removeMethod.parameterTypes.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            staticMethodBuidler.append(<span class="string">"public static  "</span> + removeMethod.returnType.name + <span class="string">"   "</span> + ReflectUtils.getStaticSuperMethodName(removeMethod.getName())</div><div class="line">                    + <span class="string">"("</span> + patchClassName + <span class="string">" patchInstance,"</span> + modifiedClass.getName() + <span class="string">" modifiedInstance,"</span> + JavaUtils.getParameterSignure(removeMethod) + <span class="string">")&#123;"</span>);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            staticMethodBuidler.append(<span class="string">"public static  "</span> + removeMethod.returnType.name + <span class="string">"   "</span> + ReflectUtils.getStaticSuperMethodName(removeMethod.getName())</div><div class="line">                    + <span class="string">"("</span> + patchClassName + <span class="string">" patchInstance,"</span> + modifiedClass.getName() + <span class="string">" modifiedInstance)&#123;"</span>);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        staticMethodBuidler.append(<span class="string">" return patchInstance."</span> + removeMethod.getName() + <span class="string">"("</span> + JavaUtils.getParameterValue(removeMethod.getParameterTypes().length) + <span class="string">");"</span>);</div><div class="line">        staticMethodBuidler.append(<span class="string">"&#125;"</span>);</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> assistClass;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上，最终生成的调用是 <code>xxPatch.superMethod($$);</code> ，$$代表全部参数。对于与上面的 onCreate 方法就是 <code>xxPatch.onCreate(bundle);</code>。<br>所以，patch 应该不能传 null 了，否则运行时会报空指针，那第二个参数 activity  能不能传 null 呢？继续往下看。<br>首先，根据常识，static 方法中肯定是不能调用 super方法的。从最终生成的代码也能看出，这并不是最终反编译出的的 <code>super.onCreate(bundle)</code>方法调用。所以处理的地方肯定在javassist修改编译之后，对应处理的地方在smali 层，代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">SmaliTool.<span class="function">java</span></div><div class="line">    <span class="keyword">private</span> String <span class="title">invokeSuperMethodInSmali</span><span class="params">(<span class="keyword">final</span> String line, String fullClassName)</span> &#123;</div><div class="line">                    ...</div><div class="line">                    result = line.replace(Constants.SMALI_INVOKE_VIRTUAL_COMMAND, Constants.SMALI_INVOKE_SUPER_COMMAND);</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (!ctMethod.getReturnType().isPrimitive()) &#123;</div><div class="line">                            returnType = <span class="string">"L"</span> + ctMethod.getReturnType().getName().replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>);</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            returnType = String.valueOf(((CtPrimitiveType) ctMethod.getReturnType()).getDescriptor());</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (NameManger.getInstance().getPatchNameMap().get(fullClassName).equals(fullClassName)) &#123;</div><div class="line">                            result = result.replace(<span class="string">"p0"</span>, <span class="string">"p1"</span>);</div><div class="line">                        &#125;</div><div class="line">                       ...</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">                    &#125;</div><div class="line">                ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>实际上就是把方法调用从 <code>invoke-invoke-virtual {p0, p2}, Lcom/meituan/robust/patch/SecondActivityPatch;-&gt;onCreate(Landroid/os/Bundle;)</code>V 转换成 <code>invoke-super {p1, p2}, Landroid/support/v7/app/AppCompatActivity;-&gt;onCreate(Landroid/os/Bundle;)V</code>，这步处理完才会真正的调用父类的super方法。<br>也就是说，在 smali 处理完后，参数从 p0 -&gt; p1，也就是参数从 xxpatch 换成了 Activity，第二个参数会在运行时用到，所以也不能传null。<br>分析完了总结下，第二个参数 originClass 肯定不能传 null，否则会空指针；第一个参数  xxPatch，由于在 smali 被替换成了第二个参数，所以有可能是可以传 null 的。</p>
<p>解决方案：</p>
<ol>
<li>修改 originClass 为static，并新增一个 static patch 变量</li>
<li>由于目前已经是在 static 方法中存在 super 方法，对应的 smali 代码：</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.<span class="function">method <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="title">onCreate_aroundBody0</span><span class="params">(Lcom/zhangdan/app/activities/MainFragmentActivity;Landroid/os/Bundle;Lorg/aspectj/lang/JoinPoint;)</span>V</span></div><div class="line"> ...</div><div class="line">invoke-<span class="keyword">super</span> &#123;p0, p1&#125;, Lcom/zhangdan/app/activities/WrapperAppCompatFragmentActivity;-&gt;onCreate(Landroid/os/Bundle;)V</div></pre></td></tr></table></figure>
</li>
</ol>
<p>所以只要不处理就好了，需要做的就是在 auto-plugin 中增加条件判断，符合 static 方法中带有 super 的不处理，一共有三处，一处是生成 xxPatchRobustAssist 辅助类，第二处在 javassit 替换 super 方法，第三处在 smali 处理补丁中的 super 方法。</p>
<p>对于方案1，问题：<br>如果 patch 和 originClass 都是 static，那么就会有内存泄露的风险。<br>并且如果被 patch 方法是 static 方法，那么在初始化 patch 时，originClass 会传 null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">accessDispatch</span><span class="params">(String methodName, Object[] paramArrayOfObject)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Log.d(<span class="string">"robust"</span>, <span class="keyword">new</span> StringBuffer().append(<span class="string">"arrivied in AccessDispatch "</span>).append(methodName).append(<span class="string">" paramArrayOfObject  "</span>).append(paramArrayOfObject).toString());</div><div class="line">        MainFragmentActivityPatch mainFragmentActivityPatch;</div><div class="line">        <span class="keyword">if</span> (!methodName.split(<span class="string">":"</span>)[<span class="number">2</span>].equals(<span class="string">"false"</span>)) &#123;</div><div class="line">            Log.d(<span class="string">"robust"</span>, <span class="string">"static method forward "</span>);</div><div class="line">            mainFragmentActivityPatch = <span class="keyword">new</span> MainFragmentActivityPatch(<span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<p>同样应该也是为了避免内存泄露，每修复一个方法就会生成一个 patch 对象并持有 static 的 originClass 引用。<br>对于方案2 ，问题：<br>首先，Aspectj 在 static 方法中插了个 super 方法（猜测也是在 smali 层做的修改），直接写的话 javac 编译时会报错，smali 处理吧还没到这一步。所以被修复后，这个 static 方法是在 xxPatch 类中的，auto-patch 即使不处理，运行时也不能正常运行，因为 xxPatch 不是 originClass 父类的子类，不能直接其调用 super 方法。</p>
<p>观察 Aspectj 生成的方法，所有 的static 方法，第一个参数都是当前类的引用，比如 <code>private static final void onCreate_aroundBody0(MainFragmentActivity mainFragmentActivity, Bundle bundle, JoinPoint joinPoint) {</code>。<br>所以比如根据上面的分析，得出一个可行的方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">def <span class="keyword">static</span> String <span class="title">invokeSuperString</span><span class="params">(MethodCall m, String originClass)</span> </span>&#123;</div><div class="line">       ...</div><div class="line">       stringBuilder.append(getStaticSuperMethodName(m.methodName) + <span class="string">"("</span> + <span class="keyword">null</span> + <span class="string">","</span> + originClass + <span class="string">",\$\$);"</span>);</div><div class="line">       ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是 static 方法中含有 super 方法，就如下处理。<br>第一个 xxPatch 对象传空，最后在 smali 处理的时候会被替换掉。<br>第二个参数是从类似<code>onCreate_aroundBody0()</code>中传过来的，后面的是其他参数。<br>最终结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticRobustonCreate</span><span class="params">(MainFragmentActivityPatch mainFragmentActivityPatch, MainFragmentActivity mainFragmentActivity, Bundle bundle)</span> </span>&#123;</div><div class="line">    MainFragmentActivityPatchRobustAssist.staticRobustonCreate(mainFragmentActivityPatch, mainFragmentActivity, bundle);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCreate_aroundBody0</span><span class="params">(MainFragmentActivity ajc$<span class="keyword">this</span>, Bundle savedInstanceState, JoinPoint joinPoint)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    staticRobustonCreate(<span class="keyword">null</span>, ajc$<span class="keyword">this</span>, savedInstanceState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里这个问题就分析完了，详细解决方发见 <a href="https://github.com/Meituan-Dianping/Robust/pull/265" target="_blank" rel="external">merge request #265</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个系列到这里基本就结束了。这篇文章主要介绍了在接入 Robust 过程中碰到的一些坑以及解决思路，其实根本还是熟读源码，碰到问题学习从源码中找答案。要坚信，坑踩的多了，也就不怕坑了。最后福利一张。</p>
<p><img src="http://wx3.sinaimg.cn/large/0078WU5Lgy1fsgrhhx37tj30o31040zf.jpg" alt=""></p>
<p>本文链接： <a href="http://w4lle.com/2018/06/20/robust-2/">http://w4lle.com/2018/06/20/robust-2/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前两篇文章中，分析了 Android 热补丁框架 Robust 中，几个重要的流程包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;补丁加载过程&lt;/li&gt;
&lt;li&gt;基础包插桩过程&lt;/li&gt;
&lt;li&gt;补丁包自动化生成过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇文章主要分析下集成过程中遇到的坑以及分析问题的思路和最终的解决方案。包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打补丁包出错？&lt;/li&gt;
&lt;li&gt;Robust 定义的 API 不够用怎么办？&lt;/li&gt;
&lt;li&gt;插件 Plugin Transform 的顺序问题？&lt;/li&gt;
&lt;li&gt;与 Aspectj 冲突怎么办？&lt;/li&gt;
&lt;li&gt;static 方法中包含 super 方法怎么办？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
      <category term="热补丁" scheme="http://w4lle.com/tags/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>Android热补丁之Robust（二）自动化补丁原理解析</title>
    <link href="http://w4lle.com/2018/05/28/robust-1/"/>
    <id>http://w4lle.com/2018/05/28/robust-1/</id>
    <published>2018-05-28T11:47:06.000Z</published>
    <updated>2018-05-29T08:40:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android 热补丁框架 Robust 中，几个重要的流程包括：</p>
<ul>
<li>补丁加载过程</li>
<li>基础包插桩过程</li>
<li>补丁包生成过程</li>
</ul>
<p>在上一篇文章<a href="http://w4lle.com/2017/03/31/robust-0/">Android热补丁之Robust原理解析(一)</a>中，我们分析了前两个，补丁加载过程和基础包插桩过程，分析的版本为 <code>0.3.2</code>。<br>该篇文章为该系列的第二篇文章，主要分析补丁自动化生成的过程，分析的版本为<code>0.4.82</code>。<br><a id="more"></a><br>时间跨度有点大…</p>
<p>系列文章:</p>
<ul>
<li><a href="http://w4lle.com/2017/03/31/robust-0/">Android热补丁之Robust原理解析(一)</a></li>
<li><a href="http://w4lle.com/2018/05/28/robust-1/">Android热补丁之Robust（二）自动化补丁原理解析</a></li>
<li><a href="http://w4lle.com/2018/05/29/robust-2/">Android热补丁之Robust（三）坑和解</a></li>
</ul>
<h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p>首先在 Gradle 插件中注册了一个名为 AutoPatchTranform 的 Tranform </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPatchTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project target)</span> </span>&#123;</div><div class="line">    initConfig();</div><div class="line">    project.android.registerTransform(<span class="keyword">this</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">def <span class="title">initConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">    NameManger.init();</div><div class="line">    InlineClassFactory.init();</div><div class="line">    ReadMapping.init();</div><div class="line">    Config.init();</div><div class="line">    ...</div><div class="line">    ReadXML.readXMl(project.projectDir.path);</div><div class="line">    Config.methodMap = JavaUtils.getMapFromZippedFile(project.projectDir.path + Constants.METHOD_MAP_PATH)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该类为插件的入口，实现了 GradlePlugin 并继承自 Transform，在入口处初始化配置并注册 Transform。配置主要是读取 Robust xml 配置、混淆优化后的 mapping 文件、插庄过程中生成的 methodsMap.robust 文件、初始化内联工厂类等等。<br>然后最主要的是<code>transform</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(Context context, Collection&lt;TransformInput&gt; inputs, Collection&lt;TransformInput&gt; referencedInputs, TransformOutputProvider outputProvider, <span class="keyword">boolean</span> isIncremental)</span> <span class="keyword">throws</span> IOException, TransformException, InterruptedException </span>&#123;</div><div class="line">    project.android.bootClasspath.each &#123;</div><div class="line">        Config.classPool.appendClassPath((String) it.absolutePath)</div><div class="line">    &#125;</div><div class="line">    def box = ReflectUtils.toCtClasses(inputs, Config.classPool)</div><div class="line">    ...</div><div class="line">    autoPatch(box)</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">def <span class="title">autoPatch</span><span class="params">(List&lt;CtClass&gt; box)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    ReadAnnotation.readAnnotation(box, logger);</div><div class="line">    <span class="keyword">if</span>(Config.supportProGuard) &#123;</div><div class="line">        ReadMapping.getInstance().initMappingInfo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    generatPatch(box,patchPath);</div><div class="line"></div><div class="line">    zipPatchClassesFile()</div><div class="line">    executeCommand(jar2DexCommand)</div><div class="line">    executeCommand(dex2SmaliCommand)</div><div class="line">    SmaliTool.getInstance().dealObscureInSmali();</div><div class="line">    executeCommand(smali2DexCommand)</div><div class="line">    <span class="comment">//package patch.dex to patch.jar</span></div><div class="line">    packagePatchDex2Jar()</div><div class="line">    deleteTmpFiles()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>transform</code> 方法中，使用 javassist API 把所有需要处理的类加载到待扫描队列中，然后调用<code>autoPatch</code>方法自动生成补丁。<br>在 <code>autoPatch</code>方法中，主要做了这么几件事情：</p>
<ol>
<li>读取被 @Add、@Modify、RobustModify.modify() 标注的方法或类并记录</li>
<li>解析 mapping 文件并记录每个类和类中方法混淆前后对应的信息，其中方法存储的信息有：返回值，方法名，参数列表，混淆后的名字；字段存储的信息有：字段名，混淆后的名字</li>
<li>根据得到的信息，<code>generatPatch</code> 方法实际生成补丁</li>
<li>将生成的补丁class打包成jar包</li>
<li>jar -&gt; dex</li>
<li>dex -&gt; smali</li>
<li>处理 smali，主要是处理 super 方法和处理混淆关系</li>
<li>smali -&gt; dex</li>
<li>dex -&gt; jar</li>
</ol>
<p>1、2 比较好懂就不逐步分析了，主要看3；后面的5、6、7、8、9 都是为了 7 中处理 smali，所以只要搞懂smali处理就好了。下面我们分步来看。</p>
<h1 id="生成补丁"><a href="#生成补丁" class="headerlink" title="生成补丁"></a>生成补丁</h1><p>主要逻辑在 <code>generatPatch</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function">def  <span class="title">generatPatch</span><span class="params">(List&lt;CtClass&gt; box,String patchPath)</span></span>&#123;</div><div class="line">...</div><div class="line">    InlineClassFactory.dealInLineClass(patchPath, Config.newlyAddedClassNameList)</div><div class="line">    initSuperMethodInClass(Config.modifiedClassNameList);</div><div class="line">    <span class="comment">//auto generate all class</span></div><div class="line">    <span class="keyword">for</span> (String fullClassName : Config.modifiedClassNameList) &#123;</div><div class="line">        CtClass ctClass = Config.classPool.get(fullClassName)</div><div class="line">        CtClass patchClass = PatchesFactory.createPatch(patchPath, ctClass, <span class="keyword">false</span>, NameManger.getInstance().getPatchName(ctClass.name), Config.patchMethodSignatureSet)</div><div class="line">        patchClass.writeFile(patchPath)</div><div class="line">        patchClass.defrost();</div><div class="line">        createControlClass(patchPath, ctClass)</div><div class="line">    &#125;</div><div class="line">    createPatchesInfoClass(patchPath);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分为两个部分</p>
<h2 id="逐步翻译"><a href="#逐步翻译" class="headerlink" title="逐步翻译"></a>逐步翻译</h2><p>首先调用<code>InlineClassFactory.dealInLineClass(patchPath, Config.newlyAddedClassNameList)</code>识别被优化过的方法，这里的优化是泛指，包括被优化、内联、新增过的类和方法，具体的逻辑为扫描修改后的所有类和类中的方法，如果这些类和方法不在 mapping 文件中存在，那么可以定义为被优化过，其中包括<code>@Add</code>新增的类或方法。<br>然后调用<code>initSuperMethodInClass</code>方法识别修改后的所有类和类中的方法中，分析是否如包含 <code>super</code> 方法，如果有那么缓存下来。<br>然后调用 <code>PatchesFactory.createPatch</code> 反射翻译修改的类和方法，具体的实现在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> CtClass <span class="title">createPatchClass</span><span class="params">(CtClass modifiedClass, <span class="keyword">boolean</span> isInline, String patchName, Set patchMethodSignureSet, String patchPath)</span> <span class="keyword">throws</span> CannotCompileException, IOException, NotFoundException </span>&#123;</div><div class="line">    <span class="comment">//清洗需要处理的方法，略..</span></div><div class="line"></div><div class="line">    CtClass temPatchClass = cloneClass(modifiedClass, patchName, methodNoNeedPatchList);</div><div class="line">    </div><div class="line">    JavaUtils.addPatchConstruct(temPatchClass, modifiedClass);</div><div class="line">    CtMethod reaLParameterMethod = CtMethod.make(JavaUtils.getRealParamtersBody(), temPatchClass);</div><div class="line">    temPatchClass.addMethod(reaLParameterMethod);</div><div class="line"></div><div class="line">    dealWithSuperMethod(temPatchClass, modifiedClass, patchPath);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (CtMethod method : temPatchClass.getDeclaredMethods()) &#123;</div><div class="line">        <span class="comment">//  shit !!too many situations need take into  consideration</span></div><div class="line">        <span class="comment">//   methods has methodid   and in  patchMethodSignatureSet</span></div><div class="line">        <span class="keyword">if</span> (!Config.addedSuperMethodList.contains(method) &amp;&amp; reaLParameterMethod != method &amp;&amp; !method.getName().startsWith(Constants.ROBUST_PUBLIC_SUFFIX)) &#123;</div><div class="line">            method.instrument(</div><div class="line">                    <span class="keyword">new</span> ExprEditor() &#123;</div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">edit</span><span class="params">(FieldAccess f)</span> <span class="keyword">throws</span> CannotCompileException </span>&#123;</div><div class="line">                            ...</div><div class="line">                                <span class="keyword">if</span> (f.isReader()) &#123; f.replace(ReflectUtils.getFieldString(f.getField(), memberMappingInfo, temPatchClass.getName(), modifiedClass.getName()));</div><div class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.isWriter()) &#123;</div><div class="line">                                    f.replace(ReflectUtils.setFieldString(f.getField(), memberMappingInfo, temPatchClass.getName(), modifiedClass.getName()));</div><div class="line">                                &#125;</div><div class="line">                            ...</div><div class="line">                        &#125;</div><div class="line"></div><div class="line"></div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(NewExpr e)</span> <span class="keyword">throws</span> CannotCompileException </span>&#123;</div><div class="line">                            <span class="comment">//inner class in the patched class ,not all inner class</span></div><div class="line">                            ...</div><div class="line">                                <span class="keyword">if</span> (!ReflectUtils.isStatic(Config.classPool.get(e.getClassName()).getModifiers()) &amp;&amp; JavaUtils.isInnerClassInModifiedClass(e.getClassName(), modifiedClass)) &#123;</div><div class="line">                                    e.replace(ReflectUtils.getNewInnerClassString(e.getSignature(), temPatchClass.getName(), ReflectUtils.isStatic(Config.classPool.get(e.getClassName()).getModifiers()), getClassValue(e.getClassName())));</div><div class="line">                                    <span class="keyword">return</span>;</div><div class="line">                                &#125;</div><div class="line">                            ...</div><div class="line"></div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(Cast c)</span> <span class="keyword">throws</span> CannotCompileException </span>&#123;</div><div class="line">                            MethodInfo thisMethod = ReflectUtils.readField(c, <span class="string">"thisMethod"</span>);</div><div class="line">                            CtClass thisClass = ReflectUtils.readField(c, <span class="string">"thisClass"</span>);</div><div class="line"></div><div class="line">                            def isStatic = ReflectUtils.isStatic(thisMethod.getAccessFlags());</div><div class="line">                            <span class="keyword">if</span> (!isStatic) &#123;</div><div class="line">                                <span class="comment">//inner class in the patched class ,not all inner class</span></div><div class="line">                                <span class="keyword">if</span> (Config.newlyAddedClassNameList.contains(thisClass.getName()) || Config.noNeedReflectClassSet.contains(thisClass.getName())) &#123;</div><div class="line">                                    <span class="keyword">return</span>;</div><div class="line">                                &#125;</div><div class="line">                                <span class="comment">// static函数是没有this指令的，直接会报错。</span></div><div class="line">                                c.replace(ReflectUtils.getCastString(c, temPatchClass))</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(MethodCall m)</span> <span class="keyword">throws</span> CannotCompileException </span>&#123;</div><div class="line">                            ...</div><div class="line">                                <span class="keyword">if</span> (!repalceInlineMethod(m, method, <span class="keyword">false</span>)) &#123;</div><div class="line">                                    Map memberMappingInfo = getClassMappingInfo(m.getMethod().getDeclaringClass().getName());</div><div class="line">                                    <span class="keyword">if</span> (invokeSuperMethodList.contains(m.getMethod())) &#123;</div><div class="line">                                        <span class="keyword">int</span> index = invokeSuperMethodList.indexOf(m.getMethod());</div><div class="line">                                        CtMethod superMethod = invokeSuperMethodList.get(index);</div><div class="line">                                        <span class="keyword">if</span> (superMethod.getLongName() != <span class="keyword">null</span> &amp;&amp; superMethod.getLongName() == m.getMethod().getLongName()) &#123;</div><div class="line">                                            String firstVariable = <span class="string">""</span>;</div><div class="line">                                            <span class="keyword">if</span> (ReflectUtils.isStatic(method.getModifiers())) &#123;</div><div class="line">                                                <span class="comment">//修复static 方法中含有super的问题，比如Aspectj处理后的方法</span></div><div class="line">                                                MethodInfo methodInfo = method.getMethodInfo();</div><div class="line">                                                LocalVariableAttribute table = methodInfo.getCodeAttribute().getAttribute(LocalVariableAttribute.tag);</div><div class="line">                                                <span class="keyword">int</span> numberOfLocalVariables = table.tableLength();</div><div class="line">                                                <span class="keyword">if</span> (numberOfLocalVariables &gt; <span class="number">0</span>) &#123;</div><div class="line">                                                    <span class="keyword">int</span> frameWithNameAtConstantPool = table.nameIndex(<span class="number">0</span>);</div><div class="line">                                                    firstVariable = methodInfo.getConstPool().getUtf8Info(frameWithNameAtConstantPool)</div><div class="line">                                                &#125;</div><div class="line">                                            &#125;</div><div class="line">                                            m.replace(ReflectUtils.invokeSuperString(m, firstVariable));</div><div class="line">                                            <span class="keyword">return</span>;</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;</div><div class="line">                                    m.replace(ReflectUtils.getMethodCallString(m, memberMappingInfo, temPatchClass, ReflectUtils.isStatic(method.getModifiers()), isInline));</div><div class="line">                                &#125;</div><div class="line">                            ...</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//remove static code block,pay attention to the  class created by cloneClassWithoutFields which construct's</span></div><div class="line">    CtClass patchClass = cloneClassWithoutFields(temPatchClass, patchName, <span class="keyword">null</span>);</div><div class="line">    patchClass = JavaUtils.addPatchConstruct(patchClass, modifiedClass);</div><div class="line">    <span class="keyword">return</span> patchClass;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码其实是这个插件的核心部分，总体来说就是将修改后的代码全部翻译成反射调用生成 xxxPatch 类。<br>我们先只关注<code>method.instrument()</code>这个方法，这个Javassist的API，作用是遍历方法中的代码逻辑，包括：</p>
<ul>
<li>FieldAccess，字段访问操作。分为字段读和写两种，分别调用<code>ReflectUtils.getFieldString</code>方法，将代码逻辑使用Javassist翻译成反射调用，然后替换。</li>
<li>NewExpr，new 对象操作。也分为两种<ul>
<li>非静态内部类，调用<code>ReflectUtils.getNewInnerClassString</code>翻译成反射，然后替换</li>
<li>外部类，调用<code>ReflectUtils.getCreateClassString</code>翻译成反射，然后替换</li>
</ul>
</li>
<li>Cast，强转操作。调用<code>ReflectUtils.getCastString</code>翻译成反射，然后替换</li>
<li>MethodCall，方法调用操作。情况比较复杂，以下几种情形<ul>
<li>lamda表达式，调用<code>ReflectUtils.getNewInnerClassString</code>生成内部类的方法并翻译成反射，然后替换</li>
<li>修改的方法是内联方法，调用<code>ReflectUtils.getInLineMemberString</code>方法生成占位内联类<code>xxInLinePatch</code>，并在改类中把修改的方法翻译成反射，然后替换调用，这方法中又有一些其他情况判断，感兴趣的读者可以自行阅读</li>
<li>如果是super方法，这个情况后面单独拎出来说</li>
<li>正常方法，调用<code>ReflectUtils.getMethodCallString</code>方法翻译成反射，然后替换</li>
</ul>
</li>
<li>生成补丁类并增加构造方法</li>
</ul>
<p>请注意，以上所有方法和需要处理的方法都需要特别注意方法签名！</p>
<h2 id="控制补丁行为"><a href="#控制补丁行为" class="headerlink" title="控制补丁行为"></a>控制补丁行为</h2><p>最后调用 <code>createControlClass(patchPath, ctClass)</code>、<code>createPatchesInfoClass(patchPath);</code>生成 PatchesInfoImpl、xxxPatchControl 写入补丁信息和控制补丁行为。</p>
<p>其中，<code>PatchesInfoImpl</code>中包含所有补丁类的一一对应关系，比如 <code>MainActivity -&gt; MainActivityPatch</code>，不清楚的可以参考该系列的上一篇文章。生成的<code>xxxPatchControl</code>类用于生成<code>xxPatch</code>类，并判断补丁中的方法是否和methods.robust中的方法id匹配，如果匹配才会去调用补丁中方法。</p>
<p>至此整体流程基本梳理完成。后面会针对具体的复杂情况加以解析。</p>
<h1 id="this-如何处理"><a href="#this-如何处理" class="headerlink" title="this 如何处理"></a>this 如何处理</h1><p>首先，在补丁类中 xxPatch 中，<code>this</code>指代的是xxPatch类的对象，而我们是想要的对象是被补丁的类的对象。</p>
<p>在<code>PatchesFactory.createPatchClass()</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">CtMethod reaLParameterMethod = CtMethod.make(JavaUtils.getRealParamtersBody(), temPatchClass);</div><div class="line">temPatchClass.addMethod(reaLParameterMethod);</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getRealParamtersBody</span><span class="params">()</span> </span>&#123;</div><div class="line">    StringBuilder realParameterBuilder = <span class="keyword">new</span> StringBuilder();</div><div class="line">    realParameterBuilder.append(<span class="string">"public  Object[] "</span> + Constants.GET_REAL_PARAMETER + <span class="string">" (Object[] args)&#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"if (args == null || args.length &lt; 1) &#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" return args;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"&#125;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" Object[] realParameter = new Object[args.length];"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"for (int i = 0; i &lt; args.length; i++) &#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"if (args[i] instanceof Object[]) &#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"realParameter[i] ="</span> + Constants.GET_REAL_PARAMETER + <span class="string">"((Object[]) args[i]);"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"&#125; else &#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"if (args[i] ==this) &#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" realParameter[i] =this."</span> + ORIGINCLASS + <span class="string">";"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"&#125; else &#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" realParameter[i] = args[i];"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" &#125;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" &#125;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" &#125;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"  return realParameter;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" &#125;"</span>);</div><div class="line">    <span class="keyword">return</span> realParameterBuilder.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段的作用是，在每个xxPatch补丁类中都插入一个<code>getRealParameter()</code>方法，反编译出来最终的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Object[] getRealParameter(Object[] objArr) &#123;</div><div class="line">    <span class="keyword">if</span> (objArr == <span class="keyword">null</span> || objArr.length &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> objArr;</div><div class="line">    &#125;</div><div class="line">    Object[] objArr2 = <span class="keyword">new</span> Object[objArr.length];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objArr.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (objArr[i] <span class="keyword">instanceof</span> Object[]) &#123;</div><div class="line">            objArr2[i] = getRealParameter((Object[]) objArr[i]);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objArr[i] == <span class="keyword">this</span>) &#123;</div><div class="line">            objArr2[i] = <span class="keyword">this</span>.originClass;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            objArr2[i] = objArr[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> objArr2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的作用是，在每个xxPatch中使用的<code>this</code>，都转换成xx被补丁类的对象。其中的<code>originClass</code>就是补丁类的对象。</p>
<h1 id="super-如何处理"><a href="#super-如何处理" class="headerlink" title="super 如何处理"></a>super 如何处理</h1><p>同<code>this</code>类似，xxPatch中调用 <code>super</code> 方法同样需要转为调用被补丁类中相关方法的<code>super</code>调用。</p>
<p>还是在<code>PatchesFactory.createPatchClass()</code>方法中有<code>dealWithSuperMethod(temPatchClass, modifiedClass, patchPath);</code>调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dealWithSuperMethod</span><span class="params">(CtClass patchClass, CtClass modifiedClass, String patchPath)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException, IOException </span>&#123;</div><div class="line">    ...</div><div class="line">    methodBuilder.append(<span class="string">"public  static "</span> + invokeSuperMethodList.get(index).getReturnType().getName() + <span class="string">"  "</span> + ReflectUtils.getStaticSuperMethodName(invokeSuperMethodList.get(index).getName()) + <span class="string">"("</span> + patchClass.getName() + <span class="string">" patchInstance,"</span> + modifiedClass.getName() + <span class="string">" modifiedInstance,"</span> + JavaUtils.getParameterSignure(invokeSuperMethodList.get(index)) + <span class="string">")&#123;"</span>);</div><div class="line">    ...</div><div class="line">    CtClass assistClass = PatchesAssistFactory.createAssistClass(modifiedClass, patchClass.getName(), invokeSuperMethodList.get(index));</div><div class="line">    ...</div><div class="line">    methodBuilder.append(NameManger.getInstance().getAssistClassName(patchClass.getName()) + <span class="string">"."</span> + ReflectUtils.getStaticSuperMethodName(invokeSuperMethodList.get(index).getName())  + <span class="string">"(patchInstance,modifiedInstance"</span>);</div><div class="line">    ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>保留主要代码，根据方法签名生成了一个新的方法，以<code>staticRobust+methodName</code>命名，方法中调用以<code>RobustAssist</code>结尾的类中的同名方法，并调用 <code>PatchesAssistFactory.createAssistClass</code> 方法生成该类，这个类的父类是被补丁类的父类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">PatchesAssistFactory.createAssistClass:</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">createAssistClass</span><span class="params">(CtClass modifiedClass, String patchClassName, CtMethod removeMethod)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    staticMethodBuidler.append(<span class="string">"public static  "</span> + removeMethod.returnType.name + <span class="string">"   "</span> + ReflectUtils.getStaticSuperMethodName(removeMethod.getName())</div><div class="line">            + <span class="string">"("</span> + patchClassName + <span class="string">" patchInstance,"</span> + modifiedClass.getName() + <span class="string">" modifiedInstance)&#123;"</span>);</div><div class="line">                </div><div class="line">    staticMethodBuidler.append(<span class="string">" return patchInstance."</span> + removeMethod.getName() + <span class="string">"("</span> + JavaUtils.getParameterValue(removeMethod.getParameterTypes().length) + <span class="string">");"</span>);</div><div class="line">    staticMethodBuidler.append(<span class="string">"&#125;"</span>);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在遍历<code>MethodCall</code>过程中，处理方法调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">m.replace(ReflectUtils.invokeSuperString(m, firstVariable));</div><div class="line">...</div><div class="line"><span class="function">def <span class="keyword">static</span> String <span class="title">invokeSuperString</span><span class="params">(MethodCall m, String originClass)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    stringBuilder.append(getStaticSuperMethodName(m.methodName) + <span class="string">"(this,"</span> + Constants.ORIGINCLASS + <span class="string">",\$\$);"</span>);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>传递的参数，patch、originClass（被补丁类对象）、方法实际参数列表。</p>
<p>反编译出的结果实际是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">MainFragmentActivity:</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(bundle);</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">MainFragmentActivityPatch:</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticRobustonCreate</span><span class="params">(MainFragmentActivityPatch mainFragmentActivityPatch, MainFragmentActivity mainFragmentActivity, Bundle bundle)</span> </span>&#123;</div><div class="line">    MainFragmentActivityPatchRobustAssist.staticRobustonCreate(mainFragmentActivityPatch, mainFragmentActivity, bundle);</div><div class="line">&#125;</div><div class="line"></div><div class="line">MainFragmentActivityPatchRobustAssist:</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragmentActivityPatchRobustAssist</span> <span class="keyword">extends</span> <span class="title">WrapperAppCompatFragmentActivity</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticRobustonCreate</span><span class="params">(MainFragmentActivityPatch mainFragmentActivityPatch, MainFragmentActivity mainFragmentActivity, Bundle bundle)</span> </span>&#123;</div><div class="line">        mainFragmentActivityPatch.onCreate(bundler);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数是按照实际的方法参数传进去的，最后调用了xxPatch.superMethod方法。但是这样也并没有实现<code>super</code>方法的转义啊，再往下看。</p>
<p>在处理smali过程中，有这么一段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">invokeSuperMethodInSmali</span><span class="params">(<span class="keyword">final</span> String line, String fullClassName)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    result = line.replace(Constants.SMALI_INVOKE_VIRTUAL_COMMAND, Constants.SMALI_INVOKE_SUPER_COMMAND);</div><div class="line">    ...</div><div class="line">    result = result.replace(<span class="string">"p0"</span>, <span class="string">"p1"</span>);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在处理之前，smali是长这样的：<code>invoke-invoke-virtual {p0, p2}, Lcom/meituan/robust/patch/SecondActivityPatch;-&gt;onCreate(Landroid/os/Bundle;)V</code>,<br>处理之后是这样的：<code>invoke-super {p1, p2}, Landroid/support/v7/app/AppCompatActivity;-&gt;onCreate(Landroid/os/Bundle;)V</code>，意思就是本来是调用正常方法，现在转为调用super方法，并且把参数换了一下，把p0(补丁类对象)换成了p1（被补丁类对象），这样就完成了<code>super</code>的处理。反编译后最终结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragmentActivityPatchRobustAssist</span> <span class="keyword">extends</span> <span class="title">WrapperAppCompatFragmentActivity</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticRobustonCreate</span><span class="params">(MainFragmentActivityPatch mainFragmentActivityPatch, MainFragmentActivity mainFragmentActivity, Bundle bundle)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(bundle);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="内联怎么处理"><a href="#内联怎么处理" class="headerlink" title="内联怎么处理"></a>内联怎么处理</h1><p>内联是个广义的概念，包括了混淆过程中的优化(修改方法签名、删除方法等)、内联。在上面的分析中处理zi方法基本也提到了，缺啥补啥：就是把内联掉的方法再补回来。<br>对于内联的方法，不能用<code>@Modify</code>注解标注，只能使用<code>RobustModify.modify()</code>标注，因为在基础包中方法都没了，打了l补丁方法也没用。</p>
<p>主要逻辑在遍历<code>MethodCall</code> -&gt; <code>repalceInlineMethod()</code> -&gt; <code>ReflectUtils.getInLineMemberString()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">stringBuilder.append(<span class="string">" instance=new "</span> + NameManger.getInstance().getInlinePatchName(method.declaringClass.name) + <span class="string">"(\$0);"</span>)</div><div class="line">stringBuilder.append(<span class="string">"\$_=(\$r)instance."</span> + getInLineMethodName(method) + <span class="string">"("</span> + parameterBuilder.toString() + <span class="string">");"</span>)</div><div class="line">...</div></pre></td></tr></table></figure>
<p>作用就是把内联掉的方法调用替换为InLine类中的新增方法。</p>
<p>结果就是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String first=<span class="keyword">null</span>;</div><div class="line">    <span class="comment">//privateMethod被内联了</span></div><div class="line">    <span class="comment">// private void privateMethod(String fir)&#123;</span></div><div class="line">    <span class="comment">//    System.out.println(fir);</span></div><div class="line">    <span class="comment">//&#125;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(String fir)</span></span>&#123;</div><div class="line">        first=fir;</div><div class="line">        Parent children=<span class="keyword">new</span> Children();</div><div class="line">        <span class="comment">//children.privateMethod("Robust");</span></div><div class="line">        <span class="comment">//内联替换的逻辑</span></div><div class="line">        ParentInline inline= <span class="keyword">new</span> ParentInline(children);</div><div class="line">        inline.privateMethod(<span class="string">"Robust"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentInline</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Parent children ;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentInline</span><span class="params">(Parent p)</span></span>&#123;</div><div class="line">       children=p;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//混淆为c</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">(String fir)</span></span>&#123;</div><div class="line">        System.out.println(fir);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Robust 的核心其实就是自动化生成补丁这块，至于插庄、补丁加载这些都是很好实现的，因为没有很多的特殊情况需要处理。<br>这篇文章主要分析了自动化补丁插件的主要工作流程，和一些特殊情况的处理，文章有限，当然还有很多特殊情况没有分析，这里只是提供一些分析源码的思路，碰到特殊情况可以按照这个思路排查解决问题。</p>
<p>就像代码中有一行注释，我觉得特别能概括自动化生成补丁的团队的心里路程，在此也再次感谢美团团队对开源做出的贡献。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  shit !!too many situations need take into  consideration</span></div></pre></td></tr></table></figure></p>
<p>总体来说，Robust 坑是有的，但是它也是高可用性、高兼容性的热修复框架，尤其是在Android 系统开放性越来越收紧的趋势下，Robust  作为不 hook 系统 API 的热修复框架优势更加突出。虽然其中可能有一些坑，只要我们对原理熟悉掌握，才有信心能搞定这些问题。</p>
<p>下一篇文章，主要就讲下Robust与其他框架搭配使用出现的一些坑。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://tech.meituan.com/android_autopatch.html" target="_blank" rel="external">Android热更新方案Robust开源，新增自动化补丁工具</a></li>
<li><a href="https://www.jianshu.com/p/b9b3ff0e1bf8" target="_blank" rel="external">Javassist 使用指南（二）</a></li>
<li><a href="https://juejin.im/entry/579ef6e37db2a2005a6350d8" target="_blank" rel="external">[转] 深入理解 Dalvik 字节码指令及 Smali 文件</a></li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2018/05/28/robust-1/">http://w4lle.com/2018/05/28/robust-1/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Android 热补丁框架 Robust 中，几个重要的流程包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;补丁加载过程&lt;/li&gt;
&lt;li&gt;基础包插桩过程&lt;/li&gt;
&lt;li&gt;补丁包生成过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上一篇文章&lt;a href=&quot;http://w4lle.com/2017/03/31/robust-0/&quot;&gt;Android热补丁之Robust原理解析(一)&lt;/a&gt;中，我们分析了前两个，补丁加载过程和基础包插桩过程，分析的版本为 &lt;code&gt;0.3.2&lt;/code&gt;。&lt;br&gt;该篇文章为该系列的第二篇文章，主要分析补丁自动化生成的过程，分析的版本为&lt;code&gt;0.4.82&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
      <category term="热补丁" scheme="http://w4lle.com/tags/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>使用 Python 处理 pdf</title>
    <link href="http://w4lle.com/2018/02/02/python-pdf/"/>
    <id>http://w4lle.com/2018/02/02/python-pdf/</id>
    <published>2018-02-02T01:34:45.000Z</published>
    <updated>2018-02-05T01:33:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近老婆工作中碰到一些困难，总是跟我抱怨工作好烦，不开心。<br>主要是是因为要处理一些报告，这些 pdf 格式的样本报告比较多，基本都是人工操作比较容易出错，也比较琐碎，好心情都被磨没了。</p>
<p>然后我说要么写个小程序吧，帮你处理这些琐碎的工作，然后就大概梳理了一下主要需求：</p>
<a id="more"></a>
<p>内部报告：</p>
<ol>
<li>首先需要从系统出导出一个大的 pdf，包含很多小的 pdf</li>
<li>每个小的 pdf 报告中包含一些信息，比如 报告标题、姓名、编号、医院、总页数</li>
<li>拿到这些信息之后，分割大的 pdf，将小的 pdf 报告剥离处理</li>
<li>然后重命名这些报告，格式为 <code>姓名-编号.pdf</code></li>
<li>将这些报告移动到对应医院的目录下，然后将这些医院目录压缩</li>
</ol>
<p>外部报告：</p>
<ol>
<li>外部会发过来压缩包，其中包含单个的 pdf 报告</li>
<li>解压缩后将报告拿出来，提取其中的信息，信息基本同内部报告</li>
<li>重命名</li>
<li>移动到对应的医院目录下，并压缩</li>
</ol>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>人生苦短，我用python。<br>嗯，python大法好，处理这些琐碎的事情写个 python 脚本跑一下不就好了吗。<br>python 版本使用的python 3.x。</p>
<p>梳理了下输球，首先需要解析大 pdf 中的一些关键信息，转化为我们需要的报告信息，首先写个Model叫做 <code>Sample</code>，包含 title、number、name、total_page、hospital 等等，然后依次解析 pdf 生成组成 samples 列表，最后根据报告列表分割处理pdf 就好了。</p>
<h2 id="解析-pdf"><a href="#解析-pdf" class="headerlink" title="解析 pdf"></a>解析 pdf</h2><p>有个 python 库叫做 <a href="https://github.com/euske/pdfminer" target="_blank" rel="external">pdfminer</a>，这个库已经不支持python 3.x 版本了，该项目注明了可以使用 <a href="https://github.com/pdfminer/pdfminer.six" target="_blank" rel="external">pdfminer.six</a>来支持3.x的版本。</p>
<p>基本语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_samples</span><span class="params">()</span>:</span></div><div class="line">    fp = open(get_origin_report_path(), <span class="string">'rb'</span>)  <span class="comment"># 以二进制读模式打开</span></div><div class="line">    <span class="comment"># 用文件对象来创建一个pdf文档分析器</span></div><div class="line">    praser = PDFParser(fp)</div><div class="line">    <span class="comment"># 创建一个PDF文档</span></div><div class="line">    doc = PDFDocument()</div><div class="line">    <span class="comment"># 连接分析器 与文档对象</span></div><div class="line">    praser.set_document(doc)</div><div class="line">    doc.set_parser(praser)</div><div class="line"></div><div class="line">    <span class="comment"># 提供初始化密码</span></div><div class="line">    <span class="comment"># 如果没有密码 就创建一个空的字符串</span></div><div class="line">    doc.initialize()</div><div class="line"></div><div class="line">    <span class="comment"># 检测文档是否提供txt转换，不提供就忽略</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> doc.is_extractable:</div><div class="line">        <span class="keyword">raise</span> PDFTextExtractionNotAllowed</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="comment"># 创建PDf 资源管理器 来管理共享资源</span></div><div class="line">        rsrcmgr = PDFResourceManager()</div><div class="line">        <span class="comment"># 创建一个PDF设备对象</span></div><div class="line">        laparams = LAParams()</div><div class="line">        device = PDFPageAggregator(rsrcmgr, laparams=laparams)</div><div class="line">        <span class="comment"># 创建一个PDF解释器对象</span></div><div class="line">        interpreter = PDFPageInterpreter(rsrcmgr, device)</div><div class="line"></div><div class="line">        <span class="comment"># 循环遍历列表，每次处理一个page的内容</span></div><div class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> doc.get_pages():  <span class="comment"># doc.get_pages() 获取page列表</span></div><div class="line">            number_index = <span class="number">0</span></div><div class="line">            name_index = <span class="number">0</span></div><div class="line">            sample = Sample()</div><div class="line">            interpreter.process_page(page)</div><div class="line">            <span class="comment"># 接受该页面的LTPage对象</span></div><div class="line">            layout = device.get_result()</div><div class="line">            <span class="comment"># 这里layout是一个LTPage对象 里面存放着 这个page解析出的各种对象 一般包括LTTextBox, LTFigure, LTImage, LTTextBoxHorizontal 等等 想要获取文本就获得对象的text属性，</span></div><div class="line">            <span class="keyword">for</span> index, out <span class="keyword">in</span> enumerate(layout):</div><div class="line">                <span class="comment"># if hasattr(out, "get_text"):</span></div><div class="line">                <span class="comment"># if (isinstance(out, LTTextBoxHorizontal)):</span></div><div class="line">                <span class="keyword">if</span> (isinstance(out, LTTextBox)):</div><div class="line">                    <span class="keyword">with</span> open(get_log_path(), <span class="string">'a'</span>) <span class="keyword">as</span> outfile:</div><div class="line">                        results = out.get_text().replace(<span class="string">u'\xa0'</span>, <span class="string">u' '</span>)</div><div class="line">                        parse()</div><div class="line">                        ...</div><div class="line">                        ....</div></pre></td></tr></table></figure>
<p>官网给出的 layout 布局</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/pdfminer_layout.png" alt="layout"></p>
<p>我们主要拿其中的文本信息，所以拿到每一页 pdf 的LTPage后，遍历其中的包含 text 属性的控件就好了，拿到文本信息，根据正则匹配到关心的文本信息，赋值给新建的<code>sample</code>，依次循环，最后组成 <code>samples</code> 报告列表给后面使用。<br>解析完了后就需要处理 pdf 了。</p>
<h3 id="分割-pdf"><a href="#分割-pdf" class="headerlink" title="分割 pdf"></a>分割 pdf</h3><p>首先要做的是将大的 pdf 分割成小的 pdf，搜了下分割 pdf 有个python 库叫做 <a href="https://pythonhosted.org/PyPDF2/" target="_blank" rel="external">PyPDF2</a>，参考API 写了一个工具方法用来分割 pdf。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_pdf</span><span class="params">(infn, outfn, start_page, end_page)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    分割pdf文档，如果需要的话</div><div class="line"></div><div class="line">    :param infn: 源报告目录</div><div class="line">    :param outfn: 分割后输出文档目录</div><div class="line">    :param start_page:</div><div class="line">    :param end_page:</div><div class="line">    :return:</div><div class="line">    """</div><div class="line">    pdf_output = PdfFileWriter()</div><div class="line">    pdf_input = PdfFileReader(open(infn, <span class="string">'rb'</span>))</div><div class="line">    <span class="comment"># 获取 pdf 共用多少页</span></div><div class="line">    page_count = pdf_input.getNumPages()</div><div class="line">    <span class="comment"># 将 pdf 的分割页面，输出到一个新的文件</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start_page, end_page):</div><div class="line">        pdf_output.addPage(pdf_input.getPage(i))</div><div class="line">    pdf_output.write(open(outfn, <span class="string">'wb'</span>))</div><div class="line">    print(<span class="string">'---分割pdf完毕--'</span>)</div></pre></td></tr></table></figure>
<p>根据第一步得出的 samples，循环一下拿出其中的total_page，依次分割就好了。</p>
<p>最后就是重命名、移动、压缩，不写了。</p>
<h1 id="打包成-exe-可执行文件"><a href="#打包成-exe-可执行文件" class="headerlink" title="打包成 exe 可执行文件"></a>打包成 exe 可执行文件</h1><p>老婆使用的是 Windowns，所以最后要打包成 <code>.exe</code> 可执行文件，搜了下 pyinstaller 可以解决，但是还是需要在对应的平台才能打出对应平台的可执行文件，可就是说想要打出 <code>.exe</code> 必须在 Windows 下打包，这就有点蛋疼了。然后弄了一下，发现 Windows 用来做开发真的是难用无比。<br>最后也没打 <code>.exe</code>，直接在 Windows 下装了python，双击 <code>.py</code> 文件好了，有bug的话替换一下文件好了，不用重新打包。</p>
<h1 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h1><p>项目交付老婆使用后，极其的好用，大幅提升了工作效率，减少出错概率，老婆甚至发了个朋友圈夸奖了一番，感觉美滋滋。</p>
<p>美了不到两天就出 bug 了。</p>
<p>bug是这样的，比如有个编号<code>编号：G201802020108</code> 正常解析出来 <code>sample.number = G201802020108</code> 才对，但是结果可能是这样的<code>G20180202</code>，后面少了几位。拿到原始的大 pdf 跑了一遍发现确实是这样，每个 pdf 在解析时我都把文本信息存了下来以便查问题用，这时派上了用场，打开看了下文本信息被这样处理了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">编号：G20180202</div><div class="line"><span class="number">0108</span></div></pre></td></tr></table></figure>
<p>本来在一行或者说在一个 <code>LTTextBox</code> 中的内容被分割成了两个，所以出现了内容少的问题。</p>
<p>找到了问题原因就好处理了。<br>首先想到了一个方案，每个 <code>LTxx</code> 控件在当页 pdf 中的位置由坐标表示，左上角坐标是 <code>{x0:0,y0:0, x1:0,y1:0}</code>，只要框住了编号信息所在的坐标范围，只要在该范围内的，所有文本信息 append 一下然后再正则匹配就好了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">in_number_area</span><span class="params">(text_box)</span>:</span></div><div class="line">    <span class="comment"># x0,y0,x1,y1</span></div><div class="line">    scope = (<span class="number">370</span>, <span class="number">700</span>, <span class="number">560</span>, <span class="number">740</span>)</div><div class="line">    <span class="keyword">if</span> in_area(text_box.bbox, scope):</div><div class="line">        print(<span class="string">'样本编号匹配！坐标点：'</span>, text_box.bbox)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    </div><div class="line"></div><div class="line"><span class="comment"># 判断TextBox坐标范围是否在规定范围内</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">in_area</span><span class="params">(bbox, scope)</span>:</span></div><div class="line">    <span class="keyword">if</span> bbox[<span class="number">0</span>] &gt; scope[<span class="number">0</span>] <span class="keyword">and</span> bbox[<span class="number">1</span>] &gt; scope[<span class="number">1</span>] <span class="keyword">and</span> bbox[<span class="number">2</span>] &lt; scope[<span class="number">2</span>] <span class="keyword">and</span> bbox[<span class="number">3</span>] &lt; scope[<span class="number">3</span>]:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>给定固定坐标范围，找到在该坐标范围内的控件，然后再去匹配。</p>
<p>跑了一下确实生效了，但是问题依然没有解决，为什么呢？因为报告种类不一，导致格式就不一样，坐标范围也不一样，也就是说不能动态的找到坐标范围。该方案失败。</p>
<p>于是又想到了第二个方案，直接看代码吧</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 解析编号</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> utils.number_legal_for_internal(sample.number):</div><div class="line">    num = utils.parse_sample_num(results)</div><div class="line">    <span class="keyword">if</span> num:</div><div class="line">        number_index = index</div><div class="line">        sample.number = num</div><div class="line">        <span class="keyword">continue</span></div><div class="line">    <span class="comment"># 解决编号被分成两段的问题</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> utils.number_legal_for_internal(sample.number) <span class="keyword">and</span> number_index <span class="keyword">and</span> (</div><div class="line">            index == number_index + <span class="number">1</span> <span class="keyword">or</span> index == number_index + <span class="number">2</span>):</div><div class="line">        print(<span class="string">'修正后的编号：'</span>)</div><div class="line">        num = utils.parse_sample_num(<span class="string">'样本编号：'</span> + sample.number + results)</div><div class="line">        sample.number = num</div><div class="line">        <span class="keyword">if</span> utils.number_legal_for_internal(num):</div><div class="line">            number_index = <span class="number">0</span></div><div class="line">            <span class="keyword">continue</span></div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>基本解决。</p>
<p>其实第二个方案也不太完美，为什么呢？编号还好说，一般都是字母加数字，如果出现这个bug一般都能比较好判断是否合法，比如编号长度 &gt;=11，但是，如果是名字呢，就没有很好的合法规则来判断，比如<code>名字：张三丰</code>，<code>丰</code>字被分割了，而合法判断是名字长度 &gt;=2，那最后结果就是<code>张三</code>而不是<code>张三丰</code>。</p>
<p>所以，其实还有一个优化方案，在方案一和方案二的基础上，第一步先匹配关键字，比如<code>姓名：</code>，匹配到了以后再框定坐标范围，一般名字都是6字以内，编号是20位以内，划定坐标范围后将范围内的匹配控件文本信息都拿出来再一起解析。基本做到了动态判断坐标范围。</p>
<p>外部报告跟内部报告基本是一样的，区别是首先需要解压一下，然后解析、处理，不写了。</p>
<h1 id="还有哪些可以做"><a href="#还有哪些可以做" class="headerlink" title="还有哪些可以做"></a>还有哪些可以做</h1><p>前面写了怎么解析处理pdf，其实还有一部分工作也可以用脚本来处理，比如，大的pdf 下载可以通过脚本处理；处理好的 pdf 报告要通过邮件法发送给客户，也可以通过脚本处理；有时还需要把解析出的信息填到表格中，也是可以用脚本处理的。</p>
<p>总结下来一共有这几个功能：</p>
<ul>
<li>爬虫，从系统中导出大的 pdf 报告</li>
<li>pdf 解析和分割</li>
<li>归类，压缩</li>
<li>生成表格</li>
<li>发送邮件</li>
</ul>
<p>目前只做了2 和3 ，其余的有时间慢慢写。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>为什么写这篇文章呢？<br>其实用到的东西很简单，看几分钟 python 入门然后再找两个开源库就搞定了，也没必要记录什么技术知识点。<br>我真正想说的是一些感悟，程序员碰到这种问题一般都会想办法写一些脚本处理，没什么稀奇的。但是对于不会写程序的人来说，有这个程序和没有这个程序简直就是不一样的工作，就拿这件事来说，用了这个程序之后，我老婆的工作效率明显提升，每天能节省出1-2小时时间做别的事情，从交付那天起，基本没听过老婆再抱怨工作了。简直开心。</p>
<p>还有就是以前总感觉程序员这个工作对生活的帮助简直就是没啥用，比如，你看谁谁现在是医生，去医院都不用挂号，直接就能看病；谁谁是老师，孩子上学的事情根本不用愁等等诸如此类，职业除了能养活自己之外能够反哺生活，在生活中提供一些价值。反观程序员对生活上的帮助简直就是0，甚至可以说是负数。</p>
<p>现在是高速发展的信息时代，干什么工作都离不开手机、电脑，甚至人工智能在某些方面都开始取代人力去做一些工作，所以我觉得越来越能体现出程序员的价值，可以控制机器取代人工去做一些重复性的、机械性的工作，所以在有能力的前提下学习一些开发知识会大有裨益。就像每个人都学英语一样，在未来，编程也有可能是一门基础学科，每个人都应该掌握。</p>
<p>回到现在，简单的用一些简单的脚本提升生活幸福感，把这些烦人的工作交给机器去做，人类最擅长的是浪费时间，恩。</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/machine_time1.jpg" alt=""></p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/machine_time2.jpg" alt=""></p>
<p>本文链接： <a href="http://w4lle.com/2018/02/02/python-pdf/">http://w4lle.com/2018/02/02/python-pdf/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近老婆工作中碰到一些困难，总是跟我抱怨工作好烦，不开心。&lt;br&gt;主要是是因为要处理一些报告，这些 pdf 格式的样本报告比较多，基本都是人工操作比较容易出错，也比较琐碎，好心情都被磨没了。&lt;/p&gt;
&lt;p&gt;然后我说要么写个小程序吧，帮你处理这些琐碎的工作，然后就大概梳理了一下主要需求：&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://w4lle.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="其他" scheme="http://w4lle.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>区块链（一）区块链和以太坊</title>
    <link href="http://w4lle.com/2017/10/27/ethereum-0/"/>
    <id>http://w4lle.com/2017/10/27/ethereum-0/</id>
    <published>2017-10-27T11:37:06.000Z</published>
    <updated>2017-10-27T13:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区块链是什么"><a href="#区块链是什么" class="headerlink" title="区块链是什么"></a>区块链是什么</h1><blockquote>
<p>区块链（英语：blockchain 或 block chain）是用分布式数据库识别、传播和记载信息的智能化对等网络, 也称为价值互联网。中本聪在2008年，于《比特币白皮书》中提出“区块链”概念，并在2009年创立了比特币社会网络，开发出第一个区块，即“创世区块”。</p>
</blockquote>
<a id="more"></a>
<p>区块链，简单的讲就是一个分布式存储的一个大账本，由一条条的交易记录（block）组成，并且任何人都可以拥有这个账本并且可以存储交易记录，几乎在同一时间这条记录就会被同步到全世界的副本上，这就使得没有人能够修改本地账本中的记录，使其拥有了去中心化的能力。可以理解为这就是区块链技术的基本内容，比特币和以太坊和其他代币都是以此为基础。最有名气的就属比特币了。</p>
<p>考虑现实生活，比如想去找一个陌生人借钱，那么就必须有一个双方都认可的第三方存在，比如银行。由于区块链的存在，这个第三方就可以不需要了。比如，我要借给 A 一块钱，我要在账本上写一条，我要借给 A 一块钱，首先会去检查你有没有一块钱，如果有的话就会记录下来，并且同时在你的账户中扣掉一块钱同时在 A 的账户中增加一块钱，同时同步到所有持有该账本的账户上。</p>
<p>因此，区块链具有以下特点：</p>
<ul>
<li>去中心化</li>
<li>分布式</li>
<li>密码性安全</li>
</ul>
<h1 id="以太坊是什么"><a href="#以太坊是什么" class="headerlink" title="以太坊是什么"></a>以太坊是什么</h1><blockquote>
<p>以太坊是一个全新开放的区块链平台，它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。</p>
</blockquote>
<p>以太坊相比于区块链有了更进一步的发展，它可以在链上创建一些自动运行的程序称之为智能合约，只要这个智能合约发布到了链上，任何人都无法修改它，并且它是对任何人透明的，任何人都可以看到其代码。任何人都可以发布智能合约，编写智能合约所使用的高级语言也是图灵完备的（意味着语言可以使用计图灵机完成任何图灵机可以完成的任务），这就使得这是可编程的，任何人支付一笔费用 (Gas) 都可以部署编写的智能合约供其他人使用。</p>
<p>考虑现实生活，比如说使用基于以太坊的智能合约存钱，该合约约定月利率1%，那么假如我存了100块钱进去，一个月后来取，那么我能取到的金额必然是 100 + 100 * 0.01。</p>
<p>所以相对于区块链，以太坊多了两个特点：</p>
<ul>
<li>智能合约</li>
<li>图灵完备</li>
</ul>
<h1 id="挖矿是怎么回事？"><a href="#挖矿是怎么回事？" class="headerlink" title="挖矿是怎么回事？"></a>挖矿是怎么回事？</h1><p>以太坊的本质就是一个基于交易的状态机(transaction-based state machine)。以太坊的状态包含很多交易，这些交易被打包到区块中（block），也就是说每个 block 包含了一系列的交易，每个区块与它的前一个区块链接起来组成区块链。<br><img src="http://7xs23g.com1.z0.glb.clouddn.com/blockchain.png" alt="blockchain"><br>为了让交易被认为是有效的，都必须要经历一个验证的过程，这个过程其实就是挖矿。挖矿实际上就是矿工用他们的计算资源来创建一个包含有效交易的区块出来。然而当你在计算区块的时候别的矿工同样也在计算，如果大家同时提交的话，怎么证明谁的区块是有效的？所以在提交区块到区块链上时，都需要提供一个数学机制的证明，称之为工作量证明（proof of work），所以一个矿工必须要比其他矿工更快的提供出这个证明来抢占区块的有效性将之合并到区块两上，与此同时，别的矿工会及时的将区块链的状态更新至最新。证实了一个新区块的矿工都会被奖励一定价值的奖赏。奖赏就是以太坊使的用一种内在数字代币—以太币(Ether)。</p>
<p>另外，以太坊和区块链的架构不同在于，以太坊区块不仅包含交易记录和最近的状态，还包含区块序号和难度值。</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/ethereum-blockchain.png" alt=""></p>
<h1 id="我们能用来干嘛"><a href="#我们能用来干嘛" class="headerlink" title="我们能用来干嘛"></a>我们能用来干嘛</h1><p>我们公司 1024 程序员节当天搞了个 HackathonDay 活动，我们报名参加了下，并且选题就是基于区块链的实际应用，虽然基本只有一天的时间来学习区块链的相关知识，我们还是做出了一些 Demo，基本算是入门。<br>所以接下来的文章会写到基于以太坊搭建一个私有链、创建账户、进行挖矿、进行转账交易、基于 Solidity 语言编写智能合约、部署到区块链上、编写 DApp 来使用智能合约等等。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://github.com/ethereum/wiki/wiki/%5B%E4%B8%AD%E6%96%87%5D-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6" target="_blank" rel="external">以太坊白皮书</a></li>
<li><a href="http://ethfans.org/posts/how-does-ethereum-work-anyway" target="_blank" rel="external">以太坊的工作原理</a></li>
<li><a href="http://wangxiaoming.com/blog/2016/05/05/blockchain-tech-what-is-blockchain/" target="_blank" rel="external">区块链是什么？</a></li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2017/10/27/ethereum-0/">http://w4lle.com/2017/10/27/ethereum-0/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;区块链是什么&quot;&gt;&lt;a href=&quot;#区块链是什么&quot; class=&quot;headerlink&quot; title=&quot;区块链是什么&quot;&gt;&lt;/a&gt;区块链是什么&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;区块链（英语：blockchain 或 block chain）是用分布式数据库识别、传播和记载信息的智能化对等网络, 也称为价值互联网。中本聪在2008年，于《比特币白皮书》中提出“区块链”概念，并在2009年创立了比特币社会网络，开发出第一个区块，即“创世区块”。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="区块链" scheme="http://w4lle.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>热修复总结</title>
    <link href="http://w4lle.com/2017/05/04/hotpatch-summary/"/>
    <id>http://w4lle.com/2017/05/04/hotpatch-summary/</id>
    <published>2017-05-04T10:45:31.000Z</published>
    <updated>2017-05-15T02:51:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="热修复总结"><a href="#热修复总结" class="headerlink" title="热修复总结"></a>热修复总结</h1><table>
<thead>
<tr>
<th style="text-align:center">平台</th>
<th style="text-align:center">阿里 AndFix</th>
<th style="text-align:center">阿里 HotFix1.x</th>
<th style="text-align:center">Nuwa</th>
<th style="text-align:center">微信Tinker</th>
<th style="text-align:center">美团Robust</th>
<th style="text-align:center">阿里 HotFix2.x</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">即时生效</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">看情况</td>
</tr>
<tr>
<td style="text-align:center">性能损耗</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较大</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较小</td>
</tr>
<tr>
<td style="text-align:center">补丁包大小</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">较大</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较小</td>
</tr>
<tr>
<td style="text-align:center">占Rom体积</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">较大</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">看情况</td>
</tr>
<tr>
<td style="text-align:center">接入复杂度</td>
<td style="text-align:center">简单</td>
<td style="text-align:center">简单</td>
<td style="text-align:center">简单</td>
<td style="text-align:center">复杂</td>
<td style="text-align:center">简单</td>
<td style="text-align:center">简单</td>
</tr>
<tr>
<td style="text-align:center">安全校验</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">类替换</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">资源替换</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">即将支持</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">so替换</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">即将支持</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">全平台支持</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">开发透明</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">gradle支持</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">接口文档</td>
<td style="text-align:center">较少</td>
<td style="text-align:center">丰富</td>
<td style="text-align:center">较少</td>
<td style="text-align:center">丰富</td>
<td style="text-align:center">丰富</td>
<td style="text-align:center">丰富</td>
</tr>
<tr>
<td style="text-align:center">成功率</td>
<td style="text-align:center">较低</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">较高</td>
<td style="text-align:center">最高</td>
<td style="text-align:center">较高</td>
</tr>
<tr>
<td style="text-align:center">后台管理</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">加固兼容</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">部分兼容</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">不确定</td>
</tr>
</tbody>
</table>
<p>上表基本涵盖了具有代表性的各种热修复方案，涉及到的各种关键指标的横向对比。</p>
<p>Slider 中大概总结了各种方案的实现方式，以及常见的问题。</p>
<p>Slider 地址： <a href="http://w4lle.github.io/sliders/hot-fix/index.html" target="_blank" rel="external">http://w4lle.github.io/sliders/hot-fix/index.html</a></p>
<p>详细的各种方案分析：</p>
<ul>
<li><a href="http://w4lle.github.io/2016/03/03/Android%E7%83%AD%E8%A1%A5%E4%B8%81%E4%B9%8BAndFix%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">Android热补丁之AndFix原理解析</a></li>
<li><a href="http://w4lle.github.io/2016/05/02/%E4%BB%8EInstant%20run%E8%B0%88Android%E6%9B%BF%E6%8D%A2Application%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">从Instant run谈Android替换Application和动态加载机制</a></li>
<li><a href="http://w4lle.github.io/2016/12/16/tinker/" target="_blank" rel="external">Android热补丁之Tinker原理解析</a></li>
<li><a href="http://w4lle.github.io/2017/03/31/robust-0/" target="_blank" rel="external">Android热补丁之Robust原理解析(一)</a></li>
</ul>
<p>水平有限，难免有写的不对的地方，欢迎交流。</p>
<p>本文链接： <a href="http://w4lle.com/2017/05/04/hotpatch-summary/">http://w4lle.com/2017/05/04/hotpatch-summary/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;热修复总结&quot;&gt;&lt;a href=&quot;#热修复总结&quot; class=&quot;headerlink&quot; title=&quot;热修复总结&quot;&gt;&lt;/a&gt;热修复总结&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;平台&lt;/th&gt;
&lt;t
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
      <category term="热补丁" scheme="http://w4lle.com/tags/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>Android热补丁之Robust原理解析(一)</title>
    <link href="http://w4lle.com/2017/03/31/robust-0/"/>
    <id>http://w4lle.com/2017/03/31/robust-0/</id>
    <published>2017-03-31T07:58:12.000Z</published>
    <updated>2018-05-29T08:40:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>早在16年9月份，美团技术团队就写过一篇文章描述 Android 热补丁框架Robust的简单实现原理，但是并没有开源；然后在17年3月份，美团团队宣布正式开源 Robust并且配套了自动打补丁包工具。本系列文章主要解析Robust实现原理，分为几个方面</p>
<ul>
<li>补丁加载过程</li>
<li>基础包插桩过程</li>
<li>补丁包生成过程</li>
</ul>
<p>本文为第一篇，主要讲解补丁加载过程和基础包插桩过程，分析版本 <code>0.3.2</code>。</p>
<a id="more"></a>
<p>系列文章:</p>
<ul>
<li><a href="http://w4lle.com/2017/03/31/robust-0/">Android热补丁之Robust原理解析(一)</a></li>
<li><a href="http://w4lle.com/2018/05/28/robust-1/">Android热补丁之Robust（二）自动化补丁原理解析</a></li>
<li><a href="http://w4lle.com/2018/05/29/robust-2/">Android热补丁之Robust（三）坑和解</a></li>
</ul>
<h1 id="从-InstantRun-说起"><a href="#从-InstantRun-说起" class="headerlink" title="从 InstantRun 说起"></a>从 InstantRun 说起</h1><p>不得不说 InstantRun 真是个好东西。目前主流的热修复框架都有或多或少的参考 InstantRun 的某些技术点，比如 <a href="https://github.com/Tencent/tinker" target="_blank" rel="external">Tinker</a> 的官方文章中明确考虑过 InstantRun 中的 Application 替换，虽然最后没有采用，但是身为其兄弟库的 <a href="http://tinkerpatch.com/Docs/intro" target="_blank" rel="external">TinkerPatch</a> 中一键接入方案就采用的该技术点。关于该技术点，可以参考我之前写的一篇文章 <a href="http://w4lle.github.io/2017/01/05/one-key-for-tinker/" target="_blank" rel="external">一键接入Tinker</a> 。</p>
<p>我们知道，InstantRun 对应三种更新机制：</p>
<ul>
<li>冷插拔，我们称之为重启更新机制</li>
<li>温插拔，我们称之为重启Activity更新机制</li>
<li>热插拔，我们称之为热更新机制</li>
</ul>
<p>如果你还不熟悉 InstantRun，请参考我的这篇文章<a href="http://w4lle.github.io/2016/05/02/%E4%BB%8EInstant%20run%E8%B0%88Android%E6%9B%BF%E6%8D%A2Application%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">从Instant run谈Android替换Application和动态加载机制</a></p>
<p>而这篇文章的主角 Robust ，其热修复的关键技术点就是采用了 InstantRun 中的热更新机制，对应于多 ClassLoader 的动态加载方案，即一个 dex 文件对应一个新建 ClassLoader 。</p>
<h1 id="Robust-原理解析"><a href="#Robust-原理解析" class="headerlink" title="Robust 原理解析"></a>Robust 原理解析</h1><p>Robust 的原理可以简单描述为：</p>
<ol>
<li>打基础包时插桩，在每个方法前插入一段类型为 <code>ChangeQuickRedirect</code> 静态变量的逻辑</li>
<li>加载补丁时，从补丁包中读取要替换的类及具体替换的方法实现，新建 ClassLoader 加载补丁dex。</li>
</ol>
<p>我们来分别分析。</p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>打基础包时，Robust 为每个类新增了一个类型为 <code>ChangeQuickRedirect</code> 的静态变量，并且在每个方法前，增加判断该变量是否为空的逻辑，如果不为空，走打基础包时插桩的逻辑，否则走正常逻辑。我们反编译出基础包中的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SecondActivity</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ChangeQuickRedirect u;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (u != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (PatchProxy.isSupport(<span class="keyword">new</span> Object[]&#123;bundle&#125;, <span class="keyword">this</span>, u, <span class="keyword">false</span>, <span class="number">78</span>)) &#123;</div><div class="line">                PatchProxy.accessDispatchVoid(<span class="keyword">new</span> Object[]&#123;bundle&#125;, <span class="keyword">this</span>, u, <span class="keyword">false</span>, <span class="number">78</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">super</span>.onCreate(bundle);</div><div class="line">        ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>对应于补丁文件，需要有三个文件</p>
<ul>
<li><code>PatchesInfoImpl</code> 用于记录修改的类，及其对应的 <code>ChangeQuickRedirect</code> 接口的实现，我们反编译补丁包得出以下结果，其中的类名是混淆后的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatchesInfoImpl</span> <span class="keyword">implements</span> <span class="title">PatchesInfo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">getPatchedClassesInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">        List arrayList = <span class="keyword">new</span> ArrayList();</div><div class="line">        arrayList.add(<span class="keyword">new</span> PatchedClassInfo(<span class="string">"com.meituan.sample.robusttest.l"</span>, <span class="string">"com.meituan.robust.patch.SampleClassPatchControl"</span>));</div><div class="line">        arrayList.add(<span class="keyword">new</span> PatchedClassInfo(<span class="string">"com.meituan.sample.robusttest.p"</span>, <span class="string">"com.meituan.robust.patch.SuperPatchControl"</span>));</div><div class="line">        arrayList.add(<span class="keyword">new</span> PatchedClassInfo(<span class="string">"com.meituan.sample.SecondActivity"</span>, <span class="string">"com.meituan.robust.patch.SecondActivityPatchControl"</span>));</div><div class="line">        EnhancedRobustUtils.isThrowable = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> arrayList;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>xxxPatchControl</code> 是 <code>ChangeQuickRedirect</code> 接口的具体实现，是一个代理，具体的替换方法是在 <code>xxxPatch</code> 类中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivityPatchControl</span> <span class="keyword">implements</span> <span class="title">ChangeQuickRedirect</span> </span>&#123;</div><div class="line">...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSupport</span><span class="params">(String methodName, Object[] paramArrayOfObject)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"78:79:90:"</span>.contains(methodName.split(<span class="string">":"</span>)[<span class="number">3</span>]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">accessDispatch</span><span class="params">(String methodName, Object[] paramArrayOfObject)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            SecondActivityPatch secondActivityPatch;</div><div class="line">            ...</div><div class="line">            Object obj = methodName.split(<span class="string">":"</span>)[<span class="number">3</span>];</div><div class="line">            <span class="keyword">if</span> (<span class="string">"78"</span>.equals(obj)) &#123;</div><div class="line">                secondActivityPatch.onCreate((Bundle) paramArrayOfObject[<span class="number">0</span>]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (<span class="string">"79"</span>.equals(obj)) &#123;</div><div class="line">                <span class="keyword">return</span> secondActivityPatch.getTextInfo((String) paramArrayOfObject[<span class="number">0</span>]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (<span class="string">"90"</span>.equals(obj)) &#123;</div><div class="line">                secondActivityPatch.RobustPubliclambda$onCreate$<span class="number">0</span>((View) paramArrayOfObject[<span class="number">0</span>]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</div><div class="line">            th.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终调用 <code>accessDispatch</code> 方法，该方法会根据传递过来的方法签名，调用<code>xxxPatch</code>的修改过的方法。</p>
<ul>
<li><code>xxxPatch</code> 具体的替换实现类，代码就不贴了。</li>
</ul>
<p>其过程可以简单描述为，下发补丁包后，新建 DexClassLoader 加载补丁 dex 文件，反射得到 <code>PatchesInfoImpl</code> class，并创建其对象，调用 <code>getPatchedClassesInfo()</code> 方法得到哪些修改的类（比如 SecondActivity），然后再通过反射循环拿到每个修改类在当前环境中的的class，将其中类型为 <code>ChangeQuickRedirect</code> 的静态变量反射修改为 <code>xxxPatchControl.java</code> 这个class new 出来的对象。</p>
<p>用官方的一种图很好的表达了替换原理。</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/patching.png" alt="Robust"></p>
<h2 id="补丁加载过程分析"><a href="#补丁加载过程分析" class="headerlink" title="补丁加载过程分析"></a>补丁加载过程分析</h2><p>demo中的补丁加载就一句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> PatchExecutor(getApplicationContext(), <span class="keyword">new</span> PatchManipulateImp(),  <span class="keyword">new</span> Callback()).start();</div></pre></td></tr></table></figure>
<p><code>PatchExecutor</code> 是个 Thread</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public class PatchExecutor extends Thread &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        ...</div><div class="line">        applyPatchList(patches);</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 应用补丁列表</div><div class="line">     */</div><div class="line">    protected void applyPatchList(List&lt;Patch&gt; patches) &#123;</div><div class="line">        ...</div><div class="line">        for (Patch p : patches) &#123;</div><div class="line">            ...</div><div class="line">            currentPatchResult = patch(context, p);</div><div class="line">            ...</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected boolean patch(Context context, Patch patch) &#123;</div><div class="line">        ...</div><div class="line">        DexClassLoader classLoader = new DexClassLoader(patch.getTempPath(), context.getCacheDir().getAbsolutePath(),</div><div class="line">                null, PatchExecutor.class.getClassLoader());</div><div class="line">        patch.delete(patch.getTempPath());</div><div class="line">        ...</div><div class="line">        try &#123;</div><div class="line">            patchsInfoClass = classLoader.loadClass(patch.getPatchesInfoImplClassFullName());</div><div class="line">            patchesInfo = (PatchesInfo) patchsInfoClass.newInstance();</div><div class="line">            &#125; catch (Throwable t) &#123;</div><div class="line">             ...</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">        for (PatchedClassInfo patchedClassInfo : patchedClasses) &#123;</div><div class="line">            ...</div><div class="line">            try &#123;</div><div class="line">                oldClass = classLoader.loadClass(patchedClassName.trim());</div><div class="line">                Field[] fields = oldClass.getDeclaredFields();</div><div class="line">                for (Field field : fields) &#123;</div><div class="line">                    if (TextUtils.equals(field.getType().getCanonicalName(), ChangeQuickRedirect.class.getCanonicalName()) &amp;&amp; TextUtils.equals(field.getDeclaringClass().getCanonicalName(), oldClass.getCanonicalName())) &#123;</div><div class="line">                        changeQuickRedirectField = field;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                ...</div><div class="line">                try &#123;</div><div class="line">                    patchClass = classLoader.loadClass(patchClassName);</div><div class="line">                    Object patchObject = patchClass.newInstance();</div><div class="line">                    changeQuickRedirectField.setAccessible(true);</div><div class="line">                    changeQuickRedirectField.set(null, patchObject);</div><div class="line">                    &#125; catch (Throwable t) &#123;</div><div class="line">                    ...</div><div class="line">                &#125;</div><div class="line">            &#125; catch (Throwable t) &#123;</div><div class="line">                 ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>开启一个子线程，通过指定的路径去读patch文件的jar包，patch文件可以为多个，每个patch文件对应一个 DexClassLoader 去加载，每个patch文件中存在PatchInfoImp，通过遍历其中的类信息进而反射修改其中 <code>ChangeQuickRedirect</code> 对象的值。</p>
<h2 id="基础包插桩过程分析"><a href="#基础包插桩过程分析" class="headerlink" title="基础包插桩过程分析"></a>基础包插桩过程分析</h2><p>类似 InstantRun ， Robust 也是使用 Transform API 修改字节码文件，该 API 允许第三方插件在  .class 文件打包为 dex 文件之前操作编译好的 .class 字节码文件。</p>
<p>Robust 中的 <code>Gradle-Plugin</code> 就是操作字节码的名为 <code>robust</code> 的 gradle 插件项目。我们来简单看下实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobustTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project target)</span> </span>&#123;</div><div class="line">            <span class="comment">//解析项目下robust.xml配置文件</span></div><div class="line">            robust = <span class="keyword">new</span> XmlSlurper().parse(<span class="keyword">new</span> File(<span class="string">"$&#123;project.projectDir&#125;/$&#123;Constants.ROBUST_XML&#125;"</span>))</div><div class="line">            ...</div><div class="line">            project.android.registerTransform(<span class="keyword">this</span>)</div><div class="line">            project.afterEvaluate(<span class="keyword">new</span> RobustApkHashAction())</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(Context context, Collection&lt;TransformInput&gt; inputs, Collection&lt;TransformInput&gt; referencedInputs, TransformOutputProvider outputProvider, <span class="keyword">boolean</span> isIncremental)</span> <span class="keyword">throws</span> IOException, TransformException, InterruptedException </span>&#123;</div><div class="line">    ...</div><div class="line">    ClassPool classPool = <span class="keyword">new</span> ClassPool()</div><div class="line">    project.android.bootClasspath.each &#123;</div><div class="line">        logger.debug <span class="string">"android.bootClasspath   "</span> + (String) it.absolutePath</div><div class="line">        classPool.appendClassPath((String) it.absolutePath)</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    def box = ConvertUtils.toCtClasses(inputs, classPool)</div><div class="line">    insertRobustCode(box, jarFile)</div><div class="line">    writeMap2File(methodMap, Constants.METHOD_MAP_OUT_PATH)</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先读取 robust.xml 配置文件并初始化，可配置选项包括：</p>
<ul>
<li>一些开关选项</li>
<li>需要热补丁的包名或者类名，这些包名下的所有类都被会插入代码</li>
<li>不需要热补的包名或者类名，可以在需要热补的包中剔除指定的类或者包</li>
</ul>
<p>然后通过 <code>Transform</code> API 调用 <code>transform()</code> 方法，扫描所有类加入到 <code>classPool</code> 中，调用 <code>insertRobustCode()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="function">def <span class="title">insertRobustCode</span><span class="params">(List&lt;CtClass&gt; box, File jarFile)</span> </span>&#123;</div><div class="line">    ZipOutputStream outStream=<span class="keyword">new</span> JarOutputStream(<span class="keyword">new</span> FileOutputStream(jarFile));</div><div class="line">    <span class="keyword">new</span> ForkJoinPool().submit &#123;</div><div class="line">        box.each &#123; ctClass -&gt;</div><div class="line">            <span class="keyword">if</span> (isNeedInsertClass(ctClass.getName())) &#123;</div><div class="line">               <span class="comment">//将class设置为public ctClass.setModifiers(AccessFlag.setPublic(ctClass.getModifiers()))</span></div><div class="line">                <span class="keyword">boolean</span> addIncrementalChange = <span class="keyword">false</span>;</div><div class="line">                ctClass.declaredBehaviors.findAll &#123;</div><div class="line">                <span class="comment">//规避接口和无方法类</span></div><div class="line">                    <span class="keyword">if</span> (ctClass.isInterface() || ctClass.declaredMethods.length &lt; <span class="number">1</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (!addIncrementalChange) &#123;</div><div class="line">                    <span class="comment">//插入 public static ChangeQuickRedirect changeQuickRedirect;</span></div><div class="line">                        addIncrementalChange = <span class="keyword">true</span>;</div><div class="line">                        ClassPool classPool = it.declaringClass.classPool</div><div class="line">                        CtClass type = classPool.getOrNull(Constants.INTERFACE_NAME);</div><div class="line">                        CtField ctField = <span class="keyword">new</span> CtField(type, Constants.INSERT_FIELD_NAME, ctClass);</div><div class="line">                        ctField.setModifiers(AccessFlag.PUBLIC | AccessFlag.STATIC)</div><div class="line">                        ctClass.addField(ctField)</div><div class="line">                        logger.debug <span class="string">"ctClass: "</span> + ctClass.getName();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (it.getMethodInfo().isStaticInitializer()) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="comment">// synthetic 方法暂时不aop 比如AsyncTask 会生成一些同名 synthetic方法,对synthetic 以及private的方法也插入的代码，主要是针对lambda表达式</span></div><div class="line">                    <span class="keyword">if</span> ((it.getModifiers() &amp; AccessFlag.SYNTHETIC) != <span class="number">0</span> &amp;&amp; !AccessFlag.isPrivate(it.getModifiers())) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//不支持构造方法</span></div><div class="line">                    <span class="keyword">if</span> (it.getMethodInfo().isConstructor()) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//规避抽象方法</span></div><div class="line">                    <span class="keyword">if</span> ((it.getModifiers() &amp; AccessFlag.ABSTRACT) != <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//规避NATIVE方法</span></div><div class="line">                    <span class="keyword">if</span> ((it.getModifiers() &amp; AccessFlag.NATIVE) != <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//规避接口</span></div><div class="line">                    <span class="keyword">if</span> ((it.getModifiers() &amp; AccessFlag.INTERFACE) != <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (it.getMethodInfo().isMethod()) &#123;</div><div class="line">                        <span class="keyword">if</span> (AccessFlag.isPackage(it.modifiers)) &#123;</div><div class="line">                            it.setModifiers(AccessFlag.setPublic(it.modifiers))</div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">//判断是否有方法调用，返回是否插庄</span></div><div class="line">                        <span class="keyword">boolean</span> flag = modifyMethodCodeFilter(it)</div><div class="line">                        <span class="keyword">if</span> (!flag) &#123;</div><div class="line">                            <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//方法过滤</span></div><div class="line">                    <span class="keyword">if</span> (isExceptMethodLevel &amp;&amp; exceptMethodList != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">for</span> (String exceptMethod : exceptMethodList) &#123;</div><div class="line">                            <span class="keyword">if</span> (it.name.matches(exceptMethod)) &#123;</div><div class="line">                                <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (isHotfixMethodLevel &amp;&amp; hotfixMethodList != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">for</span> (String name : hotfixMethodList) &#123;</div><div class="line">                            <span class="keyword">if</span> (it.name.matches(name)) &#123;</div><div class="line">                                <span class="keyword">return</span> <span class="keyword">true</span></div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">return</span> !isHotfixMethodLevel</div><div class="line">                &#125;.each &#123; ctBehavior -&gt;</div><div class="line">                    <span class="comment">// methodMap must be put here</span></div><div class="line">                    methodMap.put(ctBehavior.longName, insertMethodCount.incrementAndGet());</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (ctBehavior.getMethodInfo().isMethod()) &#123;</div><div class="line">                            <span class="keyword">boolean</span> isStatic = ctBehavior.getModifiers() &amp; AccessFlag.STATIC;</div><div class="line">                            CtClass returnType = ctBehavior.getReturnType0();</div><div class="line">                            String returnTypeString = returnType.getName();</div><div class="line">                            def body = <span class="string">"if ($&#123;Constants.INSERT_FIELD_NAME&#125; != null) &#123;"</span></div><div class="line">                            body += <span class="string">"Object argThis = null;"</span></div><div class="line">                            <span class="keyword">if</span> (!isStatic) &#123;</div><div class="line">                                body += <span class="string">"argThis = \$0;"</span></div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            body += <span class="string">"   if (com.meituan.robust.PatchProxy.isSupport(\$args, argThis, $&#123;Constants.INSERT_FIELD_NAME&#125;, $isStatic, "</span> + methodMap.get(ctBehavior.longName) + <span class="string">")) &#123;"</span></div><div class="line">                            body += getReturnStatement(returnTypeString, isStatic, methodMap.get(ctBehavior.longName));</div><div class="line">                            body += <span class="string">"   &#125;"</span></div><div class="line">                            body += <span class="string">"&#125;"</span></div><div class="line">                            ctBehavior.insertBefore(body);</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">catch</span> (Throwable t ) &#123;</div><div class="line">                        logger.error <span class="string">"ctClass: "</span> + ctClass.getName() + <span class="string">" error: "</span> + t.toString();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                &#125;</div><div class="line">            zipFile(ctClass.toBytecode(),outStream,ctClass.name.replaceAll(<span class="string">"\\."</span>,<span class="string">"/"</span>)+<span class="string">".class"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;.get()</div><div class="line">    outStream.close();</div><div class="line">    logger.debug <span class="string">"robust insertMethodCount: "</span> + insertMethodCount.get()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法做了以下几件事：</p>
<ul>
<li>将class设置为public</li>
<li>规避 接口</li>
<li>规避 无方法类</li>
<li>规避 构造方法</li>
<li>规避 抽象方法</li>
<li>规避 native方法</li>
<li>规避 synthetic方法</li>
<li>过滤配置文件中不需要修复的类</li>
<li>通过 javassist 在类中插入 <code>public static ChangeQuickRedirect changeQuickRedirect;</code></li>
<li>通过 javassist 在方法中插入逻辑代码段</li>
<li>通过 zipFile() 方法写回class文件</li>
</ul>
<p>最后调用 <code>writeMap2File()</code> 将插桩的方法信息写入 robust/methodsMap.robust 文件中，此文件和混淆的mapping文件需要备份。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里本篇文章结束，主要讲了下基础原理、补丁加载流程和插桩过程。我们也可以简单的对 Robust 做下总结。</p>
<p>优点：</p>
<ul>
<li>由于使用多ClassLoader方案（补丁中无新增Activity，所以不算激进类型的动态加载，无需hook system），兼容性和稳定性更好，不存在preverify的问题</li>
<li>由于采用 InstantRun 的热更新机制，所以可以即时生效，不需要重启</li>
<li>支持Android2.3-7.X版本</li>
<li>对性能影响较小，不需要合成patch</li>
<li>支持方法级别的修复，支持静态方法</li>
<li>支持新增方法和类</li>
<li>支持ProGuard的混淆、内联、编译器优化后引起的问题(桥方法、lambda、内部类等)等操作</li>
</ul>
<p>当然，有优点就会有缺点：</p>
<ul>
<li>暂时不支持新增字段，但可以通过新增类解决</li>
<li>暂时不支持修复构造方法，已经在内测</li>
<li>暂时不支持资源和 so 修复，不过这个问题不大，因为独立于 dex 补丁，已经有很成熟的方案了，就看怎么打到补丁包中以及 diff 方案。</li>
<li>对于返回值是 this 的方法支持不太好</li>
<li><strong>没有安全校验，需要开发者在加载补丁之前自己做验证</strong></li>
<li>可能会出现深度方法内联导致的不可预知的错误(几率很小可以忽略)</li>
</ul>
<p>总的来说，Robust是可用的、高稳定性的、成功率很高（官方说99.9%）的、无侵入的一款优秀的热修复框架。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://tech.meituan.com/android_robust.html" target="_blank" rel="external">Android热更新方案Robust</a></li>
<li><a href="http://tech.meituan.com/android_autopatch.html" target="_blank" rel="external">Android热更新方案Robust开源，新增自动化补丁工具
</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26036302" target="_blank" rel="external">热修复框架研究之Robust原理</a></li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2017/03/31/robust-0/">http://w4lle.com/2017/03/31/robust-0/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早在16年9月份，美团技术团队就写过一篇文章描述 Android 热补丁框架Robust的简单实现原理，但是并没有开源；然后在17年3月份，美团团队宣布正式开源 Robust并且配套了自动打补丁包工具。本系列文章主要解析Robust实现原理，分为几个方面&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;补丁加载过程&lt;/li&gt;
&lt;li&gt;基础包插桩过程&lt;/li&gt;
&lt;li&gt;补丁包生成过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文为第一篇，主要讲解补丁加载过程和基础包插桩过程，分析版本 &lt;code&gt;0.3.2&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
      <category term="热补丁" scheme="http://w4lle.com/tags/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>再见，薄荷！</title>
    <link href="http://w4lle.com/2017/03/08/goodbye-boohee/"/>
    <id>http://w4lle.com/2017/03/08/goodbye-boohee/</id>
    <published>2017-03-07T16:00:00.000Z</published>
    <updated>2017-03-08T12:56:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015.3.23 - 2017.3.8 </p>
<p>两年时光，匆匆而逝。</p>
<p>来到薄荷已经两年时间，说长不长，说短不短。</p>
<a id="more"></a>
<p>两年来在公司也成长了很多，包括技术和技术以外的其他东西。</p>
<p>薄荷是很注重技术氛围的公司，我们的技术团队是我工作以来技术氛围最为浓厚的团队，具体体现在每周三晚的技术分享和每周末每人一篇的技术博客。坚持写作是薄荷长久以来的优秀传统，我之前一直在CSDN写博客，隔三差五写一篇有时候不够积极，但是从加入薄荷后写作的积极性也有了提高，个人博客从2016年搭建至今也持续写了一些文章，其中包括一些质量还不错的文章被广泛阅读，一年的时间博客也有了6w的访问量，虽然不多，对我来说也是一种激励，说明分享的东西也会对别人有用。</p>
<p>至于Android组，我们有充分自由的技术栈选择，在可用性和稳定性的前提下，都可以引入项目中使用。在这两年时间里，我也主动承担了一些基础工作，慢慢也成长为Android组的负责人，有付出就会有回报，不用着急，想要的，时光都会给你。两年时间更新了多少版本已经记不得，但是每一个版本更新都有我的付出。有过开心，有过失落，不管怎样，这段工作已经过去，付出的汗水终究没有白费。</p>
<p>要感谢stormzhang对我工作的信任和帮助，也要谢谢skykai、loody、ttdevs这些小伙伴们，是大家的工作态度让我们这个团队这么有凝聚力。每当别人问起你心中的理想团队是什么样子，我都会毫不犹豫的回答，我现在所在的团队就是我向往的团队。大家对技术的热情，工作的积极态度，团队足够open的氛围，遇到问题永不服输的精神，生活中的互相帮助，碰巧也有共同的爱好，我说这就是我理想的团队。</p>
<p>在薄荷的这两年，也完成了人生中的两件大事。结婚、生子。我很感恩。感恩有个贤惠的媳妇儿，感恩我们有健康漂亮的小jojo，自从有了jojo我们家欢笑就没断过，每天哈哈哈。男人不就是这样，妻儿老小一人扛，家庭幸福比啥都强。希望时间可以慢点走，我们的小jojo慢慢健康长大，让我们多享受小jojo成长带给我们的快乐。</p>
<p>由于个人原因离开公司，今天下午办的离职手续，临走之前，提交了最后一行代码，commit message是“Goodbye”。团队小伙伴们一直把我送到地铁站才离去，我的心里也是很多不舍，但是人生不就是这样么，天下没有不散的筵席，只能心中默念祝大家都好！</p>
<p>虽然有些不舍，但我心里更多的是对新生活的期待，期待美好的明天，期待给家人一个稳定的家，期待简单的稳稳的幸福。期待父母身体健康，期待老婆贤惠漂亮，期待jojo健康成长。期待永远年轻，永远热泪盈眶，永远相信梦想。</p>
<p>已经远去的，带着美好记忆挥挥手说声拜拜。</p>
<p>将要到来的，怀着期待张开双手迎接未来。</p>
<p>再见，薄荷。</p>
<p>你好，明天。</p>
<p>本文链接： <a href="http://w4lle.com/2017/03/08/goodbye-boohee/">http://w4lle.com/2017/03/08/goodbye-boohee/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015.3.23 - 2017.3.8 &lt;/p&gt;
&lt;p&gt;两年时光，匆匆而逝。&lt;/p&gt;
&lt;p&gt;来到薄荷已经两年时间，说长不长，说短不短。&lt;/p&gt;
    
    </summary>
    
    
      <category term="其他" scheme="http://w4lle.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Gradle模块化配置</title>
    <link href="http://w4lle.com/2017/01/22/gradle-modules/"/>
    <id>http://w4lle.com/2017/01/22/gradle-modules/</id>
    <published>2017-01-22T01:53:37.000Z</published>
    <updated>2017-01-23T00:56:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文以<a href="https://github.com/shwenzhang/AndResGuard" target="_blank" rel="external">AndResGuard</a>和<a href="https://github.com/Tencent/tinker" target="_blank" rel="external">Tinker</a>为例讲解下如何模块化配置Gradle，以及一键打Tinker补丁包的实现方法。<br><a id="more"></a></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>随着项目越来越大，引用第三方库的gradle愈来愈多，app的build.gradle文件也越来越长，拿薄荷App为例已经达到了1000行左右，一大坨代码赛在一起看起来很不爽。并且将第三方库的配置移植到新项目也很困难，稍微不注意就会出错。</p>
<h1 id="AndResGuard配置"><a href="#AndResGuard配置" class="headerlink" title="AndResGuard配置"></a>AndResGuard配置</h1><p>首先新建resguard.gradle文件，配置内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">apply plugin: <span class="string">'AndResGuard'</span></div><div class="line">andResGuard &#123;</div><div class="line">    use7zip = <span class="keyword">true</span></div><div class="line">    useSign = <span class="keyword">true</span></div><div class="line">    keepRoot = <span class="keyword">false</span></div><div class="line">    whiteList&#123;...&#125;</div><div class="line">    compressFilePattern&#123;...&#125;</div><div class="line">    sevenzip&#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在主项目的build.gradle中加入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">apply from: <span class="string">'../resguard.gradle'</span></div><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath (<span class="string">'com.tencent.mm:AndResGuard-gradle-plugin:1.1.16'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就配置好了，子Project依赖resguard脚本，sync下就能看到resguard Task了。那么移植到新项目只需要把resguard.gradle拷贝过去就ok了。</p>
<h1 id="Tinker配置"><a href="#Tinker配置" class="headerlink" title="Tinker配置"></a>Tinker配置</h1><p>由于要配合AndResGuard使用，Tinker的gradle配置相对来说复杂些，然后我又在中间插入了自动备份和多渠道打包的task，然后就可以一键打Release包和补丁包。</p>
<p>首先新建tinker.gralde文件，首先把Tinker的官方基本配置copy进来此处代码略。先看下Project的build.gradle文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">apply from: <span class="string">'../tinker.gradle'</span></div><div class="line">apply from: <span class="string">'../utils.gradle'</span></div><div class="line">dependencies &#123;</div><div class="line">    classpath (<span class="string">"com.tencent.tinker:tinker-patch-gradle-plugin:$&#123;TINKER_VERSION&#125;"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Project只需要配置这两行代码就可以了。其中的utils.gradle是一个工具脚本文件，其中有一些常用的工具方法。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//utils.gradle</span></div><div class="line">ext &#123;</div><div class="line">    releaseTime = <span class="keyword">this</span>.&amp;releaseTime</div><div class="line">    packageChannel = <span class="keyword">this</span>.&amp;packageChannel</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">def <span class="title">releaseTime</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date().format(<span class="string">"yyyy-MM-dd"</span>, TimeZone.getTimeZone(<span class="string">"UTC"</span>))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//多渠道打包，使用的美团方案</span></div><div class="line"><span class="function">def <span class="title">packageChannel</span><span class="params">(String releaseApk)</span> </span>&#123;</div><div class="line">    print <span class="string">"begin package Channel! \n "</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        def stdout = <span class="keyword">new</span> ByteArrayOutputStream()</div><div class="line">        exec &#123;</div><div class="line">            commandLine <span class="string">'python'</span>, rootProject.getRootDir().getAbsolutePath() + <span class="string">"/app/multi_build.py"</span>, releaseApk</div><div class="line">            standardOutput = stdout</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stdout.toString().trim()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (ignored) &#123;</div><div class="line">        print <span class="string">"package Channel Error! \n "</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"UnKnown"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的多渠道打包方案仍然使用的美团之前的往META-INF插入空文件的做法，是因为AndResGuard赞不支持v2签名，暂时无法使用新一代的v2签名多渠道打包方案<a href="https://github.com/Meituan-Dianping/walle" target="_blank" rel="external">walle</a>。</p>
<p>继续看tinker.gradle，首先需要配置依赖库和打包时的插入代码比如版本号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    defaultConfig &#123;</div><div class="line">        <span class="comment">//每次发补丁需要更改此处 增加patch版本号。升级app 版本要还原0.0</span></div><div class="line">        buildConfigField <span class="string">"String"</span>, <span class="string">"PATCH_VERSION"</span>, <span class="string">"\"0.0\""</span></div><div class="line">        buildConfigField <span class="string">"String"</span>, <span class="string">"PLATFORM"</span>, <span class="string">"\"all\""</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    provided(<span class="string">"com.tencent.tinker:tinker-android-anno:$&#123;cfg.TINKER_VERSION&#125;"</span>)</div><div class="line">    compile(<span class="string">"com.tencent.tinker:tinker-android-lib:$&#123;cfg.TINKER_VERSION&#125;"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样配置完Tinker就可以可用了，然后我们要处理和AndResGuard配置使用以及自动备份自动打渠道包，步骤如下：</p>
<ol>
<li>使用resguard打正式包后需要备份apk、R、mapping、Resource mapping；并且打渠道包</li>
<li>打补丁包需要自动填入resguard新打出包的路径buildApkPath，apk、R、mapping、Resource mapping文件的对应路径。</li>
<li>打补丁包时resguard新打出的包不需要备份</li>
<li>需要区分debug和release切换备份路径</li>
</ol>
<p>对应以上几点，给出关键代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div></pre></td><td class="code"><pre><div class="line">def cfg = rootProject.ext</div><div class="line">def bakPath = file(<span class="string">"$&#123;buildDir.parent&#125;/tinkerBackup/"</span>)</div><div class="line">def bakResguard = file(<span class="string">"$&#123;bakPath&#125;"</span>)</div><div class="line">def debugBakPath = file(<span class="string">"$&#123;buildDir.absolutePath&#125;/tinkerBackup"</span>)</div><div class="line">ext &#123;</div><div class="line">    appName = <span class="string">"nicepro"</span></div><div class="line">    ...</div><div class="line">    省略tinker配置</div><div class="line">&#125;</div><div class="line">    def isNeedBackup = <span class="keyword">true</span></div><div class="line">    task AtinkerPatchPrepare &lt;&lt; &#123;</div><div class="line">        isNeedBackup = <span class="keyword">false</span></div><div class="line">        def backUpVersion = <span class="string">""</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">new</span> File(<span class="string">"$&#123;bakResguard&#125;/version.txt"</span>).exists()) &#123;</div><div class="line">            backUpVersion = <span class="keyword">new</span> File(<span class="string">"$&#123;bakResguard&#125;/version.txt"</span>).getText()</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!backUpVersion.isEmpty()) &#123;</div><div class="line">            print <span class="string">"app version : + $&#123;backUpVersion&#125; \n"</span></div><div class="line">            project.tinkerPatch.oldApk = <span class="string">"$&#123;bakResguard&#125;/$&#123;backUpVersion&#125;.apk"</span></div><div class="line">            project.tinkerPatch.buildConfig.applyResourceMapping = <span class="string">"$&#123;bakResguard&#125;/$&#123;backUpVersion&#125;_R.txt"</span></div><div class="line">            project.andResGuard.mappingFile = file(<span class="string">"$&#123;bakResguard&#125;/resource_mapping_$&#123;backUpVersion&#125;.txt"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * bak apk and mapping</div><div class="line">     */</div><div class="line">    android.applicationVariants.all &#123; variant -&gt;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * task type, you want to bak</div><div class="line">         */</div><div class="line">        def taskName = <span class="string">'release'</span></div><div class="line"><span class="comment">//        def taskName = 'debug'</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (taskName.equals(<span class="string">"debug"</span>)) &#123;</div><div class="line">            bakResguard = file(<span class="string">"$&#123;buildDir.absolutePath&#125;/tinkerBackup"</span>)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        tasks.all &#123;</div><div class="line">            <span class="keyword">if</span> (variant.buildType.name == taskName) &#123;</div><div class="line"></div><div class="line">                def backUpVersion = <span class="string">""</span></div><div class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> File(<span class="string">"$&#123;bakResguard&#125;/version.txt"</span>).exists()) &#123;</div><div class="line">                    backUpVersion = <span class="keyword">new</span> File(<span class="string">"$&#123;bakResguard&#125;/version.txt"</span>).getText()</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (<span class="string">"tinkerPatch$&#123;taskName.capitalize()&#125;"</span>.equalsIgnoreCase(it.name)) &#123;</div><div class="line">                    def resguardTask</div><div class="line">                    tasks.all &#123;</div><div class="line">                        <span class="keyword">if</span> (it.name.equalsIgnoreCase(<span class="string">"resguard$&#123;taskName.capitalize()&#125;"</span>)) &#123;</div><div class="line">                            resguardTask = it</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    it.doFirst(&#123;</div><div class="line">                        <span class="comment">// change build apk path</span></div><div class="line">                        it.buildApkPath = <span class="string">"$&#123;buildDir&#125;/outputs/apk/AndResGuard_$&#123;appName&#125;_$&#123;cfg.versionName&#125;_$&#123;releaseTime()&#125;/$&#123;appName&#125;_$&#123;cfg.versionName&#125;_$&#123;releaseTime()&#125;_signed_7zip_aligned.apk"</span></div><div class="line">                        project.android.ext.tinkerOldApkPath = <span class="string">"$&#123;bakResguard&#125;/$&#123;backUpVersion&#125;.apk"</span></div><div class="line">                        project.android.ext.tinkerApplyResourcePath = <span class="string">"$&#123;bakResguard&#125;/$&#123;backUpVersion&#125;_R.txt"</span></div><div class="line">                    &#125;)</div><div class="line">                    it.dependsOn AtinkerPatchPrepare</div><div class="line">                    it.dependsOn resguardTask</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (<span class="string">"resguard$&#123;taskName.capitalize()&#125;"</span>.equalsIgnoreCase(it.name)) &#123;</div><div class="line">                    <span class="keyword">if</span> (!backUpVersion.isEmpty() &amp;&amp; <span class="keyword">new</span> File(<span class="string">"$&#123;backUpVersion&#125;_mapping.txt"</span>).exists()) &#123;</div><div class="line">                        ext.andResMappingFile = <span class="keyword">new</span> File(<span class="string">"$&#123;backUpVersion&#125;_mapping.txt"</span>)</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        ext.andResMappingFile = <span class="keyword">null</span></div><div class="line">                    &#125;</div><div class="line">                    it.doLast &#123;</div><div class="line">                        <span class="keyword">if</span> (!isNeedBackup) &#123;</div><div class="line">                            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">                        &#125;</div><div class="line">                        def date = <span class="keyword">new</span> Date().format(<span class="string">"MMdd-HH-mm-ss"</span>)</div><div class="line">                        def orgAndresPrefix = <span class="string">"AndResGuard_$&#123;appName&#125;_$&#123;cfg.versionName&#125;_$&#123;releaseTime()&#125;"</span></div><div class="line">                        def orgApkPrefix = <span class="string">"$&#123;appName&#125;_$&#123;cfg.versionName&#125;_$&#123;releaseTime()&#125;"</span></div><div class="line">                        def targetApkPrefix = <span class="string">"$&#123;appName&#125;_$&#123;taskName.capitalize()&#125;_$&#123;cfg.versionName&#125;_$&#123;date&#125;"</span></div><div class="line"></div><div class="line">                        <span class="comment">//backUpVersion</span></div><div class="line">                        File version = <span class="keyword">new</span> File(<span class="string">"$&#123;bakResguard&#125;/version.txt"</span>)</div><div class="line">                        <span class="keyword">if</span> (!version.parentFile.exists()) &#123;</div><div class="line">                            version.parentFile.mkdir()</div><div class="line">                        &#125;</div><div class="line">                        version.write(<span class="string">"$&#123;targetApkPrefix&#125;"</span>)</div><div class="line"></div><div class="line">                        copy &#123;</div><div class="line">                            from <span class="string">"$&#123;buildDir&#125;/outputs/apk/$&#123;orgAndresPrefix&#125;/$&#123;orgApkPrefix&#125;_signed_7zip_aligned.apk"</span></div><div class="line">                            <span class="function">into <span class="title">file</span><span class="params">(bakResguard.absolutePath)</span></span></div><div class="line">                            rename &#123; String fileName -&gt;</div><div class="line">                                <span class="keyword">try</span> &#123;</div><div class="line">                                    fileName.replace(<span class="string">"$&#123;orgApkPrefix&#125;_signed_7zip_aligned.apk"</span>, <span class="string">"$&#123;targetApkPrefix&#125;.apk"</span>)</div><div class="line">                                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                                    print <span class="string">"rename apk mapping error"</span></div><div class="line">                                    e.printStackTrace()</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                            from <span class="string">"$&#123;buildDir&#125;/outputs/mapping/$&#123;taskName&#125;/mapping.txt"</span></div><div class="line">                            <span class="function">into <span class="title">file</span><span class="params">(bakResguard.absolutePath)</span></span></div><div class="line">                            rename &#123; String fileName -&gt;</div><div class="line">                                fileName.replace(<span class="string">"mapping.txt"</span>, <span class="string">"$&#123;targetApkPrefix&#125;_mapping.txt"</span>)</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            from <span class="string">"$&#123;buildDir&#125;/intermediates/symbols/$&#123;taskName&#125;/R.txt"</span></div><div class="line">                            <span class="function">into <span class="title">file</span><span class="params">(bakResguard.absolutePath)</span></span></div><div class="line">                            rename &#123; String fileName -&gt;</div><div class="line">                                fileName.replace(<span class="string">"R.txt"</span>, <span class="string">"$&#123;targetApkPrefix&#125;_R.txt"</span>)</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            from <span class="string">"$&#123;buildDir&#125;/outputs/apk/$&#123;orgAndresPrefix&#125;/resource_mapping_$&#123;orgApkPrefix&#125;.txt"</span></div><div class="line">                            <span class="function">into <span class="title">file</span><span class="params">(bakResguard.absolutePath)</span></span></div><div class="line">                            rename &#123; String fileName -&gt;</div><div class="line">                                <span class="keyword">try</span> &#123;</div><div class="line">                                    fileName.replace(<span class="string">"resource_mapping_$&#123;orgApkPrefix&#125;.txt"</span>, <span class="string">"resource_mapping_$&#123;targetApkPrefix&#125;.txt"</span>)</div><div class="line">                                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                                    print <span class="string">"rename resource mapping error"</span></div><div class="line">                                    e.printStackTrace()</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                            print <span class="string">"one resguard backup tinker base apk ok! \n"</span></div><div class="line">                        &#125;</div><div class="line">                        packageChannel(<span class="string">"$&#123;buildDir&#125;/outputs/apk/$&#123;orgAndresPrefix&#125;/$&#123;orgApkPrefix&#125;_signed_7zip_aligned.apk"</span>)</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>配置完成。发补丁包只需执行<code>./gradlew resguardRelease</code>便会打出多渠道包以及备份tinker需要的文件。</p>
<p>打tinker补丁不需要手动填依赖文件，包只需执行<code>./gradlew tinkerProcessRelease</code>。</p>
<p>正好现在并行三个项目，移植过程很快，copy两个gradle配置文件就搞定了。app的build.gradle代码也只有不到200行。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p> <a href="http://blog.csdn.net/innost/article/details/48228651" target="_blank" rel="external">深入理解Android之Gradle</a></p>
<p>本文链接： <a href="http://w4lle.com/2017/01/22/gradle-modules/">http://w4lle.com/2017/01/22/gradle-modules/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文以&lt;a href=&quot;https://github.com/shwenzhang/AndResGuard&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AndResGuard&lt;/a&gt;和&lt;a href=&quot;https://github.com/Tencent/tinker&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Tinker&lt;/a&gt;为例讲解下如何模块化配置Gradle，以及一键打Tinker补丁包的实现方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Things初探</title>
    <link href="http://w4lle.com/2017/01/06/AndroidThings-0/"/>
    <id>http://w4lle.com/2017/01/06/AndroidThings-0/</id>
    <published>2017-01-06T09:26:47.000Z</published>
    <updated>2017-01-08T08:57:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Android Things是Google推出的全新物联网操作系统<br><a id="more"></a><br>前身是去年发布的物联网平台 Brillo。Brillo 使用 C/C++ 基于 NDK 进行开发，而Android Things使用JAVA、Android Studio、Android SDK、NDK等进行开发，另外还新增了名为<code>Things Support Library</code>的库这个库有两个主要功能：通过多种协议和接口（GPIO、PWM、I2C、SPI、UART等）访问传感器和执行器的外围I/O API；以及一个用户驱动API（User Driver API），可以给应用程序添加新的设备驱动，用于将硬件事件注入系统，使它们可以为应用程序所用。还有，Android Things 天生支持物联网通讯协议 Weave，可让所有类型的设备能够连上云端并与其他服务如 Google Assistant 交互。Android Things目前支持三种硬件平台：Intel Edison、NXP Pico、Raspberry Pi 3。</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/things0.png" alt=""></p>
<p>简单来说，通过Android Things，开发者可以像开发Android应用一样简单地控制硬件设备。</p>
<h1 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h1><p>硬件平台选择了树莓派3，需要准备的硬件设备：</p>
<ul>
<li>树莓派3开发板一个</li>
<li>SD卡一张，我买的32G</li>
<li>USB插口线一条</li>
<li>HDMI视频输出线一条</li>
<li>显示器一台</li>
<li>有线鼠标一个</li>
<li>LED灯2个</li>
<li>杜邦线若干条</li>
<li>网线一条</li>
</ul>
<p>然后准备把从官网下载解压好的img文件烧入SD卡，步骤参考<a href="https://developer.android.com/things/hardware/developer-kits.html" target="_blank" rel="external">官网</a>和<a href="https://www.raspberrypi.org/documentation/installation/installing-images/mac.md" target="_blank" rel="external">树莓派官网</a>，我按照官网操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo dd bs=1m if=iot_rpi3.img of=/dev/disk2</div></pre></td></tr></table></figure>
<p>提示<code>Resource busy</code>，<a href="http://raspberrypi.stackexchange.com/questions/9217/resource-busy-error-when-using-dd-to-copy-disk-img-to-sd-card" target="_blank" rel="external">解决方案</a>如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">df -h</div><div class="line">sudo diskutil unmount /dev/disk2s1</div><div class="line">sudo dd bs=<span class="number">1</span>m <span class="keyword">if</span>=iot_rpi3.img of=/dev/rdisk2</div></pre></td></tr></table></figure>
<p>烧好后把SD卡插入开发板的卡槽里，USB线连电脑，HDMI连显示器。然后通电开机。</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/things1.jpg" alt=""><br><img src="http://7xs23g.com1.z0.glb.clouddn.com/things2.jpg" alt=""></p>
<p>看到这个界面就启动好了，实际上这个界面就是Android应用Launcher的一个Activity IoTLauncher。IoT(Internet of Things)物联网的简称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ code &gt;adb shell dumpsys activity | grep <span class="string">"mFocusedActivity"</span></div><div class="line">  mFocusedActivity: ActivityRecord&#123;a7148f7 u0 com.android.iotlauncher/.IoTLauncher t1&#125;</div></pre></td></tr></table></figure>
<p>然后插网线，内网IP会显示在Launcher界面，然后用adb连接开发板，连wifi</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">adb connect 192.168.1.143</div><div class="line">adb shell am startservice \\n    </div><div class="line">-n com.google.wifisetup/.WifiSetupService \\n    </div><div class="line">-a WifiSetupService.Connect \\n</div><div class="line">-e ssid ssid \\n</div><div class="line">-e passphrase ***</div><div class="line">adb shell ping 8.8.8.8</div></pre></td></tr></table></figure>
<h1 id="连接led灯"><a href="#连接led灯" class="headerlink" title="连接led灯"></a>连接led灯</h1><p>根据demo给的图连接led灯</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/rpi3_schematics.png" alt=""></p>
<p>这张图给出了两根线一个插地线，一个插绿色的GPIO。<br>这里放上一张图展示了树莓派上对应的针脚类型和name，接下来的操作led需要name才能控制。</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/gpio.png" alt=""></p>
<h1 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h1><p>官网提供了几个Sample，我们下载下来然后运行第一个Sample-Blink。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">PeripheralManagerService service = <span class="keyword">new</span> PeripheralManagerService();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    mLedGpio = service.openGpio(<span class="string">"BCM5"</span>);</div><div class="line">    mLedGpio.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW);</div><div class="line">&#125; <span class="keyword">catch</span> &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>openGpio方法中的参数就是上面提到的针脚对应的name。程序跑起来之后就可以看到每隔一秒led闪一下，挺有意思。</p>
<p>我们稍微改造下，写一个xml文件中有一个button，每次点击button控制led灯的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">findViewById(R.id.btn_blink).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mLedGpio.setValue(!mLedGpio.getValue());</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>外接鼠标，每点一下button改变一下led的亮灭。<br>然后再改下，插两个led灯，第二个在BCM21 <code>mLedGpio2 = service.openGpio(&quot;BCM21&quot;);</code><br>然后每隔1s控制两个灯的状态取反。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mLedGpio2.setValue(mLedGpio.getValue());</div><div class="line">mLedGpio.setValue(!mLedGpio.getValue());</div></pre></td></tr></table></figure>
<p>效果如图，gif压缩太严重，凑合看吧。<br><img src="http://7xs23g.com1.z0.glb.clouddn.com/things3.gif" alt=""></p>
<p>对于开发者来说，通过Android Things控制硬件真的感觉跟开发一款Android App没有太大什么区别，同样的开发工具，同样的开发环境，甚至SDK大于24的Andriod App同样可以安装运行在Android Things系统上；而对于NDK开发，跟Android上也是一模一样。</p>
<h1 id="Android-Everywhere"><a href="#Android-Everywhere" class="headerlink" title="Android Everywhere"></a>Android Everywhere</h1><p>还记得RoyLi在做的名为Ruff的物联网平台，RoyLi是这样介绍它的</p>
<blockquote>
<p> Ruff 让不会做硬件的软件工程师根据产品经理的创意编写应用，(软件工程师)不用关心底层实现和驱动移植问题，通过开发者建立的应用生态最终解决物联网软件落后的问题。<br>Ruff的目的就是要做物联网领域的Android平台，采用比较流行的JavaScript作为编程语言直接操作硬件。</p>
</blockquote>
<p>而现在Android Things已经移植到了物联网领域，Google的野心也可见一斑，其对于像Ruff这样的创业项目的冲击也可想而知。放一张2015年Google I/O大会上的旧图</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/google_to.png" alt=""></p>
<p>Android有庞大的开发者支持，完善的开发工具配套，也许Android真的可以做到连接万物的可能，Android在不远的未来真的可能无处不在，乘此东风，Android开发者也可大有可为。</p>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p>说到物联网就不得不说安全，在软件层面盗个号，个人信息被窃取可能感觉问题不大，但是对于联网的硬件来说就很可怕了，比如说门锁被破解，你家的煤气被远程控制，半夜你家电视突然响了，就问你怕不怕。</p>
<p>Google既然想统一IoT标准，那么IoT的安全性必须重视，因为在标准未统一之前破解某一款硬件设备性意义不大，而标准统一之后，只要破解这个平台就搞定了一切。真心希望Google可以做到让人满意的安全性。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://developer.android.com/things/hardware/index.html" target="_blank" rel="external">Android Things</a><br><a href="https://github.com/androidthings" target="_blank" rel="external">Android Things Sample</a><br><a href="http://www.jianshu.com/nb/3704305" target="_blank" rel="external">ttdevs的树莓派专题</a></p>
<p>本文链接： <a href="http://w4lle.com/2017/01/06/AndroidThings-0/">http://w4lle.com/2017/01/06/AndroidThings-0/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Android Things是Google推出的全新物联网操作系统&lt;br&gt;
    
    </summary>
    
    
      <category term="Android Things" scheme="http://w4lle.com/tags/Android-Things/"/>
    
  </entry>
  
  <entry>
    <title>一键接入Tinker</title>
    <link href="http://w4lle.com/2017/01/05/one-key-for-tinker/"/>
    <id>http://w4lle.com/2017/01/05/one-key-for-tinker/</id>
    <published>2017-01-05T06:15:49.000Z</published>
    <updated>2018-02-05T01:32:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Tinker开源挺长时间了，使用的开发者也越来越多，对于一些小白开发者来说对接Tinker的成本还是挺高的，其中主要因素还是不能理解为什么Application要修改成ApplicationLike，以及改造后对项目中使用Application的地方也要同步修改。</p>
<p>在上篇文章<a href="http://w4lle.github.io/2016/12/16/tinker/" target="_blank" rel="external">Android热补丁之Tinker原理解析</a>中我们已经讲解了这样做的目的以及Tinker的加载补丁的流程，本篇文章主要讲一下一键接入Tinker的实现思路。</p>
<h1 id="InstantRun"><a href="#InstantRun" class="headerlink" title="InstantRun"></a>InstantRun</h1><p>我们的目的是要实现不修改Application达到替换Application的效果，在这篇文章<a href="http://w4lle.github.io/2016/05/02/%E4%BB%8EInstant%20run%E8%B0%88Android%E6%9B%BF%E6%8D%A2Application%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">从Instant run谈Android替换Application和动态加载机制</a>中，详细讲述了如何动态替换Application，总结起来就两步：</p>
<ol>
<li>打包时替换Application标签，插入BootstrapApplication</li>
<li>运行时hook系统api，将BootstrapApplication换回MyApplication</li>
</ol>
<p>那么，我们依然可以用这套方案来实现Tinker的一键接入，动态替换Application。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>有了思路我们就可以敲代码了。</p>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>打包时我们要改变Manifest中Application的标签值，可以通过自定义Gradle插件来实现，关键代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@TaskAction</span></div><div class="line">    <span class="function">def <span class="title">updateManifest</span><span class="params">()</span> </span>&#123;</div><div class="line">        def ns = <span class="keyword">new</span> Namespace(<span class="string">"http://schemas.android.com/apk/res/android"</span>, <span class="string">"android"</span>)</div><div class="line">        def xml = <span class="keyword">new</span> XmlParser().parse(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(manifestPath), <span class="string">"utf-8"</span>))</div><div class="line"></div><div class="line">        def application = xml.application[<span class="number">0</span>]</div><div class="line">        <span class="keyword">if</span> (application) &#123;</div><div class="line">            def metaDataTags = application[<span class="string">'meta-data'</span>]</div><div class="line"></div><div class="line">            String rawApplicationName = application.attributes()[ns.name]</div><div class="line">            metaDataTags.findAll &#123;</div><div class="line">                it.attributes()[ns.name].equals(TINKER_APPLICATION)</div><div class="line">            &#125;.each &#123;</div><div class="line">                it.parent().remove(it)</div><div class="line">            &#125;</div><div class="line">            application.appendNode(<span class="string">'meta-data'</span>, [(ns.name): TINKER_APPLICATION, (ns.value): rawApplicationName])</div><div class="line">            application.attributes()[ns.name] = TINKER_APPLICATION_VALUE</div><div class="line"></div><div class="line">            def printer = <span class="keyword">new</span> XmlNodePrinter(<span class="keyword">new</span> PrintWriter(manifestPath, <span class="string">"utf-8"</span>))</div><div class="line">            printer.preserveWhitespace = <span class="keyword">true</span></div><div class="line">            printer.print(xml)</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>打包出的apk中的AndroidManifest.xml文件基本是这样的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;application android:name="com.w4lle.onekeytinker.BootstrapApplication"&gt;</div><div class="line">    ...</div><div class="line">    &lt;meta-data android:name="ONEKEY_TINKER_APPLICATION" android:value="com.w4lle.onekeytinker.App"/&gt;</div><div class="line">  &lt;/application&gt;</div></pre></td></tr></table></figure>
<p>其中的App是项目中原有的Application，BootstrapApplication是后期我们插入的Application。自定义Gradle插件时可以封装一个Extension配置参数，把Tinker的相关配置封装起来，一些不变的默认配置项都可以写到里面，这样项目的gradle配置可以更简洁。另外说一句，这个Gradle插件的顺序应该是打包工具生成Manifest之后，Tinker相关Task之前。</p>
<h2 id="运行时替换Application"><a href="#运行时替换Application" class="headerlink" title="运行时替换Application"></a>运行时替换Application</h2><p>这一步的主要工作也是分两步，第一就是解析Manifest文件，拿到realApplication(App)和BootstrapApplication；然后hook 系统完成替换。</p>
<p>InstantRun中的替换实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">monkeyPatchApplication</span><span class="params">(@Nullable Context context,</span></span></div><div class="line">                                              @Nullable Application bootstrap,</div><div class="line">                                              @Nullable Application realApplication) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// Find the ActivityThread instance for the current thread</span></div><div class="line">            Class&lt;?&gt; activityThread = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</div><div class="line">            Object currentActivityThread = getActivityThread(context, activityThread);</div><div class="line"></div><div class="line">            <span class="comment">// Find the mInitialApplication field of the ActivityThread to the real application</span></div><div class="line">            Field mInitialApplication = activityThread.getDeclaredField(<span class="string">"mInitialApplication"</span>);</div><div class="line">            mInitialApplication.setAccessible(<span class="keyword">true</span>);</div><div class="line">            Application initialApplication = (Application) mInitialApplication.get(currentActivityThread);</div><div class="line">            <span class="keyword">if</span> (realApplication != <span class="keyword">null</span> &amp;&amp; initialApplication == bootstrap) &#123;</div><div class="line">            <span class="comment">//**2.替换掉ActivityThread.mInitialApplication**</span></div><div class="line">                mInitialApplication.set(currentActivityThread, realApplication);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Replace all instance of the stub application in ActivityThread#mAllApplications with the</span></div><div class="line">            <span class="comment">// real one</span></div><div class="line">            <span class="keyword">if</span> (realApplication != <span class="keyword">null</span>) &#123;</div><div class="line">                Field mAllApplications = activityThread.getDeclaredField(<span class="string">"mAllApplications"</span>);</div><div class="line">                mAllApplications.setAccessible(<span class="keyword">true</span>);</div><div class="line">                List&lt;Application&gt; allApplications = (List&lt;Application&gt;) mAllApplications</div><div class="line">                        .get(currentActivityThread);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; allApplications.size(); i++) &#123;</div><div class="line">                    <span class="keyword">if</span> (allApplications.get(i) == bootstrap) &#123;</div><div class="line">                    <span class="comment">//**1.替换掉ActivityThread.mAllApplications**</span></div><div class="line">                        allApplications.set(i, realApplication);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Figure out how loaded APKs are stored.</span></div><div class="line"></div><div class="line">            <span class="comment">// API version 8 has PackageInfo, 10 has LoadedApk. 9, I don't know.</span></div><div class="line">            Class&lt;?&gt; loadedApkClass;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                loadedApkClass = Class.forName(<span class="string">"android.app.LoadedApk"</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">                loadedApkClass = Class.forName(<span class="string">"android.app.ActivityThread$PackageInfo"</span>);</div><div class="line">            &#125;</div><div class="line">            Field mApplication = loadedApkClass.getDeclaredField(<span class="string">"mApplication"</span>);</div><div class="line">            mApplication.setAccessible(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 10 doesn't have this field, 14 does. Fortunately, there are not many Honeycomb devices</span></div><div class="line">            <span class="comment">// floating around.</span></div><div class="line">            Field mLoadedApk = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                mLoadedApk = Application.class.getDeclaredField(<span class="string">"mLoadedApk"</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</div><div class="line">                <span class="comment">// According to testing, it's okay to ignore this.</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Enumerate all LoadedApk (or PackageInfo) fields in ActivityThread#mPackages and</span></div><div class="line">            <span class="comment">// ActivityThread#mResourcePackages and do two things:</span></div><div class="line">            <span class="comment">//   - Replace the Application instance in its mApplication field with the real one</span></div><div class="line">            <span class="comment">//   - Set Application#mLoadedApk to the found LoadedApk instance</span></div><div class="line">            <span class="keyword">for</span> (String fieldName : <span class="keyword">new</span> String[]&#123;<span class="string">"mPackages"</span>, <span class="string">"mResourcePackages"</span>&#125;) &#123;</div><div class="line">                Field field = activityThread.getDeclaredField(fieldName);</div><div class="line">                field.setAccessible(<span class="keyword">true</span>);</div><div class="line">                Object value = field.get(currentActivityThread);</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, WeakReference&lt;?&gt;&gt; entry :</div><div class="line">                        ((Map&lt;String, WeakReference&lt;?&gt;&gt;) value).entrySet()) &#123;</div><div class="line">                    Object loadedApk = entry.getValue().get();</div><div class="line">                    <span class="keyword">if</span> (loadedApk == <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (mApplication.get(loadedApk) == bootstrap) &#123;</div><div class="line">                        <span class="keyword">if</span> (realApplication != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">//**3.替换掉mApplication**</span></div><div class="line">                            mApplication.set(loadedApk, realApplication);</div><div class="line">                        &#125;</div><div class="line">                        </div><div class="line">                        <span class="keyword">if</span> (realApplication != <span class="keyword">null</span> &amp;&amp; mLoadedApk != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">//**4.替换掉mLoadedApk**</span></div><div class="line">                            mLoadedApk.set(realApplication, loadedApk);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>主要做了两件事：</p>
<ol>
<li>替换Application<ul>
<li>baseContext.mPackageInfo.mApplication 代码3处</li>
<li>baseContext.mPackageInfo.mActivityThread.mInitialApplication 代码2处</li>
<li>baseContext.mPackageInfo.mActivityThread.mAllApplications 代码1处</li>
</ul>
</li>
<li>替换mLoadedApk对象，代码4处</li>
</ol>
<p>详细请查看<a href="http://w4lle.github.io/2016/05/02/%E4%BB%8EInstant%20run%E8%B0%88Android%E6%9B%BF%E6%8D%A2Application%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">从Instant run谈Android替换Application和动态加载机制</a></p>
<p>做完上面这两步这样就可以实现一键接入了。</p>
<h1 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h1><p>在上篇文章中我们提到，由于该方案大量hook系统api，在国内Android碎片化如此严重的市场环境下，该方案兼容性有一些问题，大概有 1/1w的概率会出现替换失败的问题，如果替换失败，那么在系统中运行的Application还是BootstrapApplication，而我们App中的Application已经没有了Application的生命周期和作用。</p>
<p>所以我们要在失败catch中调用下Application的生命周期方法以保证程序能够正常初始化启动起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  ...</div><div class="line">&#125; <span class="keyword">catch</span> &#123;</div><div class="line">  e = <span class="keyword">true</span>;</div><div class="line">  realApplication.onCreate();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration paramConfiguration)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (e &amp;&amp; realApplication != <span class="keyword">null</span>) &#123;</div><div class="line">    realApplication.onConfigurationChanged(paramConfiguration);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">super</span>.onConfigurationChanged(paramConfiguration);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLowMemory</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (e &amp;&amp; realApplication != <span class="keyword">null</span>) &#123;</div><div class="line">    realApplication.onLowMemory();</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">super</span>.onLowMemory();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@TargetApi</span>(<span class="number">14</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> paramInt)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (e &amp;&amp; realApplication != <span class="keyword">null</span>) &#123;</div><div class="line">    realApplication.onTrimMemory(paramInt);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">super</span>.onTrimMemory(paramInt);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTerminate</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (e &amp;&amp; realApplication != <span class="keyword">null</span>) &#123;</div><div class="line">    realApplication.onTerminate();</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">super</span>.onTerminate();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这么做虽然能保证App能启动，但是实际上还会有隐性问题存在。比如App中有如下代码<code>((App) getApplication()).xxx();</code>，那么在替换失败的情况下可能就会崩了， 因为<code>getApplication()</code>得到的是BootstrapApplication，强转为<code>App</code>类型肯定就挂了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整体思路大概讲清楚了，虽然这种方案接入成本低，但是兼容性问题是个很麻烦的事情，说不定啥时候就崩了。推荐大家还是使用Tinker自有的接入方案。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://w4lle.github.io/2016/05/02/%E4%BB%8EInstant%20run%E8%B0%88Android%E6%9B%BF%E6%8D%A2Application%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">从Instant run谈Android替换Application和动态加载机制</a><br><a href="http://www.tinkerpatch.com/" target="_blank" rel="external">TinkerPatch</a></p>
<p>本文链接： <a href="http://w4lle.com/2017/01/05/one-key-for-tinker/">http://w4lle.com/2017/01/05/one-key-for-tinker/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Tinker开源挺长时间了，使用的开发者也越来越多，对于一些小白开发者来说对接Tinker的成本还是挺高的，其中主要因素还是不能理解为什么A
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
      <category term="热补丁" scheme="http://w4lle.com/tags/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>Android热补丁之Tinker原理解析</title>
    <link href="http://w4lle.com/2016/12/16/tinker/"/>
    <id>http://w4lle.com/2016/12/16/tinker/</id>
    <published>2016-12-16T01:49:06.000Z</published>
    <updated>2017-03-08T02:17:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Tinker系列文章：</p>
<ul>
<li><a href="http://w4lle.github.io/2016/12/16/tinker/" target="_blank" rel="external">Android热补丁之Tinker原理解析</a></li>
<li><a href="http://w4lle.github.io/2017/01/05/one-key-for-tinker/" target="_blank" rel="external">一键接入Tinker</a></li>
<li><a href="http://w4lle.github.io/2017/01/22/gradle-modules/" target="_blank" rel="external">Gradle模块化配置</a></li>
</ul>
<p>本文是第一篇。</p>
<blockquote>
<p>本文分析版本  <a href="https://github.com/Tencent/tinker/tree/93ecc9351367badc02a91fac25764bee50e6e6a6" target="_blank" rel="external">93ecc9351367badc02a91fac25764bee50e6e6a6</a><br>项目地址： <a href="https://github.com/Tencent/tinker/" target="_blank" rel="external">Tinker</a></p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在今年的MDCC大会上，微信开发团队宣布正式开源Tinker，在这之前微信团队已经发出过一些Tinker的相关文章，说实话在开源之前我们还是相当期待Tinker开源的，一方面是因为之前使用的热补丁一直存在一些兼容性问题，另一方面也好奇Tinker的实现方案。</p>
<a id="more"></a>
<p>在开源后我们团队第一时间着手研究Tinker，在详细阅读了源码之后，我们确定要在之后的一个版本集成Tinker上线，线上效果显示Tinker的修复效果果然牛逼，错误率明显下降的同时也没有报出兼容性的问题。附一张薄荷app使用Tinker修复前后的错误率对比。</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/fatal.png" alt=""></p>
<h1 id="从接入Tinker入手"><a href="#从接入Tinker入手" class="headerlink" title="从接入Tinker入手"></a>从接入Tinker入手</h1><p>想要深入某个框架，前提是要学会使用它。我们就从Tinker的接入入手一步一步解开它的实现原理。参照<a href="https://github.com/Tencent/tinker/wiki" target="_blank" rel="external">wiki</a>我们做了如下操作。</p>
<p>实现一个Application</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneApplicationForTinker</span> <span class="keyword">extends</span> <span class="title">TinkerApplication</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneApplicationForTinker</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(</div><div class="line">                <span class="comment">//tinkerFlags, tinker支持的类型，dex,library，还是全部都支持！</span></div><div class="line">                ShareConstants.TINKER_ENABLE_ALL,</div><div class="line">                <span class="comment">//ApplicationLike的实现类，只能传递字符串,不能使用class.getName()</span></div><div class="line">                <span class="string">"com.boohee.one.MyApplication"</span>,</div><div class="line">                <span class="comment">//加载Tinker的主类名，对于特殊需求可能需要使用自己的加载类。需要注意的是：</span></div><div class="line">                <span class="comment">//这个类以及它使用的类都是不能被补丁修改的，并且我们需要将它们加到dex.loader[]中。</span></div><div class="line">                <span class="comment">//一般来说，我们使用默认即可。</span></div><div class="line">                <span class="string">"com.tencent.tinker.loader.TinkerLoader"</span>,</div><div class="line">                <span class="comment">//由于合成过程中我们已经校验了各个文件的Md5，并将它们存放在/data/data/..目录中。</span></div><div class="line">                <span class="comment">// 默认每次加载时我们并不会去校验tinker文件的Md5,但是你也可通过开启loadVerifyFlag强制每次加载时校验，</span></div><div class="line">                <span class="comment">// 但是这会带来一定的时间损耗。</span></div><div class="line">                <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的几个参数做了详细说明，Tinker其实提供了注解的方式生成该类，但是我们为了更清楚的了解Tinker的原理，所以并没有使用注解。</p>
<p>然后在<code>AndroidManifest.xml</code>中声明该类为<code>application</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">&lt;application</div><div class="line">        android:name=".tinker.OneApplicationForTinker"</div><div class="line">        ...</div><div class="line">&lt;/application&gt;</div></pre></td></tr></table></figure>
<p>那我们就知道了，app的入口Application就是该类，该类继承自TinkerApplication。然后我们项目中的MyApplication继承自ApplicationLike，其实看到这里，就大概猜到了OneApplicationForTinker可能是一个代理，App中的Application的真正实现还是MyApplication。</p>
<h1 id="Application的替换"><a href="#Application的替换" class="headerlink" title="Application的替换"></a>Application的替换</h1><p>为了做分析前的铺垫，我们从最开始的接入入手，实现了OneApplicationForTinker，继承自TinkerApplication。我们继续往下看。<br>看下TinkerApplication的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TinkerApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TinkerApplication</span><span class="params">(<span class="keyword">int</span> tinkerFlags, String delegateClassName,</span></span></div><div class="line">                                String loaderClassName, <span class="keyword">boolean</span> tinkerLoadVerifyFlag) &#123;</div><div class="line">        <span class="keyword">this</span>.tinkerFlags = tinkerFlags;</div><div class="line">        <span class="keyword">this</span>.delegateClassName = delegateClassName;</div><div class="line">        <span class="keyword">this</span>.loaderClassName = loaderClassName;</div><div class="line">        <span class="keyword">this</span>.tinkerLoadVerifyFlag = tinkerLoadVerifyFlag;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">createDelegate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// Use reflection to create the delegate so it doesn't need to go into the primary dex.</span></div><div class="line">            <span class="comment">// And we can also patch it</span></div><div class="line">            Class&lt;?&gt; delegateClass = Class.forName(delegateClassName, <span class="keyword">false</span>, getClassLoader());</div><div class="line">            Constructor&lt;?&gt; constructor = delegateClass.getConstructor(Application.class, <span class="keyword">int</span>.class, <span class="keyword">boolean</span>.class, <span class="keyword">long</span>.class, <span class="keyword">long</span>.class,</div><div class="line">                Intent.class, Resources[].class, ClassLoader[].class, AssetManager[].class);</div><div class="line">            <span class="keyword">return</span> constructor.newInstance(<span class="keyword">this</span>, tinkerFlags, tinkerLoadVerifyFlag,</div><div class="line">                applicationStartElapsedTime, applicationStartMillisTime,</div><div class="line">                tinkerResultIntent, resources, classLoader, assetManager);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"createDelegate failed"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">ensureDelegate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (delegate == <span class="keyword">null</span>) &#123;</div><div class="line">            delegate = createDelegate();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Hook for sub-classes to run logic after the &#123;<span class="doctag">@link</span> Application#attachBaseContext&#125; has been</div><div class="line">     * called but before the delegate is created. Implementors should be very careful what they do</div><div class="line">     * here since &#123;<span class="doctag">@link</span> android.app.Application#onCreate&#125; will not have yet been called.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onBaseContextAttached</span><span class="params">(Context base)</span> </span>&#123;</div><div class="line">        applicationStartElapsedTime = SystemClock.elapsedRealtime();</div><div class="line">        applicationStartMillisTime = System.currentTimeMillis();</div><div class="line">        loadTinker();</div><div class="line">        ensureDelegate();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Method method = ShareReflectUtil.findMethod(delegate, <span class="string">"onBaseContextAttached"</span>, Context.class);</div><div class="line">            method.invoke(delegate, base);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"onBaseContextAttached method not found"</span>, t);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//重置安全模式次数，大于等于三次会进入安全模式不再加载</span></div><div class="line">        <span class="keyword">if</span> (useSafeMode) &#123;</div><div class="line">            String processName = ShareTinkerInternals.getProcessName(<span class="keyword">this</span>);</div><div class="line">            String preferName = ShareConstants.TINKER_OWN_PREFERENCE_CONFIG + processName;</div><div class="line">            SharedPreferences sp = getSharedPreferences(preferName, Context.MODE_PRIVATE);</div><div class="line">            sp.edit().putInt(ShareConstants.TINKER_SAFE_MODE_COUNT, <span class="number">0</span>).commit();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.attachBaseContext(base);</div><div class="line">        onBaseContextAttached(base);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delegateMethod</span><span class="params">(String methodName)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (delegate != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Method method = ShareReflectUtil.findMethod(delegate, methodName, <span class="keyword">new</span> Class[<span class="number">0</span>]);</div><div class="line">                method.invoke(delegate, <span class="keyword">new</span> Object[<span class="number">0</span>]);</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(String.format(<span class="string">"%s method not found"</span>, methodName), t);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">        ensureDelegate();</div><div class="line">        delegateMethod(<span class="string">"onCreate"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TinkerApplication继承自Application，说明它是正经的Application，而且在manifest文件中声明的也必须是它。然后在Application的各个声明周期方法中反射调用<code>delegate</code>同步Application的周期方法回调，其中的<code>delegate</code>是我们传过来的我们项目中的Application <code>MyApplication</code>。</p>
<p>其中的loaderTinker()方法是Tinker的加载流程，我们稍后会讲到，在反射调用MyApplication的attachBaseContext之前，loaderTinker()已经被调用完成，也就是说，Tinker是在加载完整个流程之后才去调用的app中的Application的attachBaseContext开始真正的整个App的生命周期。说白了就是采用了代理。</p>
<p>看到这里，如果你看过我之前写的<a href="http://w4lle.github.io/2016/05/02/%E4%BB%8EInstant%20run%E8%B0%88Android%E6%9B%BF%E6%8D%A2Application%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">从Instant run谈Android替换Application和动态加载机制</a>，就会发现跟这个好像。区别在于，InstantRun是在编译器修改manifest插入IncrementalClassLoader，运行时动态替换成项目中实际使用的MyApplication，进而替换了ClassLoader和资源等，开发者在毫不知情的情况下就完成了替换。</p>
<p>其中大量使用了反射，hook系统api，替换运行时系统中保有的Application的引用，最终完成替换，Tinker团队之前做过测试，100w人会有几十个在替换的时候出现问题，而且如果反射替换Application的问题，那么这个过程是不可逆的。Tinker为了兼容性问题考虑，采用了工程代理的方式，避免进入兼容性的坑。虽然可以用注解的方式生成，但是这种方式相比InstantRun的那一套接入成本还是增大不少，不过为了线上的稳定，这一切都是值得的。</p>
<p>还有一点需要注意的是，TinkerApplication是采用反射调用的MyApplication，为什么一定是反射，我们直接传过去MyApplication的引用直接调用不就好了吗？关于这一点，我们后面会详细说明。</p>
<h1 id="补丁加载"><a href="#补丁加载" class="headerlink" title="补丁加载"></a>补丁加载</h1><p>在补丁加载之前，我们需要知道补丁文件现在已经下发到app中，并且通过dexDiff合成并且校验然后push到<code>/data/data/package_name/tinker/</code>下。大概的文件目录：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">root@android:/data/data/tinker.sample.android/tinker # ls</div><div class="line">info.lock</div><div class="line">patch-bc7c9396</div><div class="line">patch.info</div><div class="line"></div><div class="line">root@android:/data/data/tinker.sample.android/tinker/patch-bc7c9396 # ls</div><div class="line">dex</div><div class="line">odex</div><div class="line">patch-bc7c9396.apk</div><div class="line">res</div></pre></td></tr></table></figure>
<p>刚才讲到loadTinker()方法是实现Tinker加载补丁的关键，我们继续看下实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadTinker</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//disable tinker, not need to install</span></div><div class="line">    <span class="keyword">if</span> (tinkerFlags == TINKER_DISABLE) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    tinkerResultIntent = <span class="keyword">new</span> Intent();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//reflect tinker loader, because loaderClass may be define by user!</span></div><div class="line">        Class&lt;?&gt; tinkerLoadClass = Class.forName(loaderClassName, <span class="keyword">false</span>, getClassLoader());</div><div class="line"></div><div class="line">        Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class, <span class="keyword">int</span>.class, <span class="keyword">boolean</span>.class);</div><div class="line">        Constructor&lt;?&gt; constructor = tinkerLoadClass.getConstructor();</div><div class="line">        tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), <span class="keyword">this</span>, tinkerFlags, tinkerLoadVerifyFlag);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        <span class="comment">//has exception, put exception error code</span></div><div class="line">        ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);</div><div class="line">        tinkerResultIntent.putExtra(INTENT_PATCH_EXCEPTION, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的<code>loaderClassName</code>是我们传过来的<code>&quot;com.tencent.tinker.loader.TinkerLoader&quot;</code>，反射调用TinkerLoader的tryLoad()方法拿到加载补丁结果，这里为什么也要用反射，是因为Tinker做了很多扩展性的工作，TinkerLoader只是默认实现，开发者完全可以自己定义加载器完成加载流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//TinkerLoader</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * only main process can handle patch version change or incomplete</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Intent <span class="title">tryLoad</span><span class="params">(TinkerApplication app, <span class="keyword">int</span> tinkerFlag, <span class="keyword">boolean</span> tinkerLoadVerifyFlag)</span> </span>&#123;</div><div class="line">        Intent resultIntent = <span class="keyword">new</span> Intent();</div><div class="line"></div><div class="line">        <span class="keyword">long</span> begin = SystemClock.elapsedRealtime();</div><div class="line">        tryLoadPatchFilesInternal(app, tinkerFlag, tinkerLoadVerifyFlag, resultIntent);</div><div class="line">        <span class="keyword">long</span> cost = SystemClock.elapsedRealtime() - begin;</div><div class="line">        ShareIntentUtil.setIntentPatchCostTime(resultIntent, cost);</div><div class="line">        <span class="keyword">return</span> resultIntent;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>调用tryLoadPatchFilesInternal()方法，然后计算消耗时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryLoadPatchFilesInternal</span><span class="params">(TinkerApplication app, <span class="keyword">int</span> tinkerFlag, <span class="keyword">boolean</span> tinkerLoadVerifyFlag, Intent resultIntent)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    ...</div><div class="line">        <span class="comment">//tinker/patch.info</span></div><div class="line">        File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectoryPath);</div><div class="line"></div><div class="line">        <span class="comment">//old = 641e634c5b8f1649c75caf73794acbdf</span></div><div class="line">        <span class="comment">//new = 2c150d8560334966952678930ba67fa8</span></div><div class="line">        File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectoryPath);</div><div class="line"></div><div class="line">        patchInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);</div><div class="line"></div><div class="line">        String oldVersion = patchInfo.oldVersion;</div><div class="line">        String newVersion = patchInfo.newVersion;</div><div class="line"></div><div class="line">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OLD_VERSION, oldVersion);</div><div class="line">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_NEW_VERSION, newVersion);</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> mainProcess = ShareTinkerInternals.isInMainProcess(app);</div><div class="line">        <span class="keyword">boolean</span> versionChanged = !(oldVersion.equals(newVersion));</div><div class="line"></div><div class="line">        String version = oldVersion;</div><div class="line">        <span class="keyword">if</span> (versionChanged &amp;&amp; mainProcess) &#123;</div><div class="line">            version = newVersion;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//patch-641e634c</span></div><div class="line">        String patchName = SharePatchFileUtil.getPatchVersionDirectory(version);</div><div class="line"></div><div class="line">        <span class="comment">//tinker/patch.info/patch-641e634c</span></div><div class="line">        String patchVersionDirectory = patchDirectoryPath + <span class="string">"/"</span> + patchName;</div><div class="line">        File patchVersionDirectoryFile = <span class="keyword">new</span> File(patchVersionDirectory);</div><div class="line"></div><div class="line">        <span class="comment">//tinker/patch.info/patch-641e634c/patch-641e634c.apk</span></div><div class="line">        File patchVersionFile = <span class="keyword">new</span> File(patchVersionDirectoryFile.getAbsolutePath(), SharePatchFileUtil.getPatchVersionFile(version));</div><div class="line"></div><div class="line">        ShareSecurityCheck securityCheck = <span class="keyword">new</span> ShareSecurityCheck(app);</div><div class="line"></div><div class="line"><span class="comment">//校验签名和tinkerId</span></div><div class="line">        <span class="keyword">int</span> returnCode = ShareTinkerInternals.checkSignatureAndTinkerID(app, patchVersionFile, securityCheck);</div><div class="line"></div><div class="line">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_CONFIG, securityCheck.getPackagePropertiesIfPresent());</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForDex = ShareTinkerInternals.isTinkerEnabledForDex(tinkerFlag);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (isEnabledForDex) &#123;</div><div class="line">            <span class="comment">//tinker/patch.info/patch-641e634c/dex</span></div><div class="line">            <span class="keyword">boolean</span> dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);</div><div class="line">            <span class="keyword">if</span> (!dexCheck) &#123;</div><div class="line">                <span class="comment">//file not found, do not load patch</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForNativeLib = ShareTinkerInternals.isTinkerEnabledForNativeLib(tinkerFlag);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (isEnabledForNativeLib) &#123;</div><div class="line">            <span class="comment">//tinker/patch.info/patch-641e634c/lib</span></div><div class="line">            <span class="keyword">boolean</span> libCheck = TinkerSoLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);</div><div class="line">            <span class="keyword">if</span> (!libCheck) &#123;</div><div class="line">                <span class="comment">//file not found, do not load patch</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//check resource</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForResource = ShareTinkerInternals.isTinkerEnabledForResource(tinkerFlag);</div><div class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:isEnabledForResource:"</span> + isEnabledForResource);</div><div class="line">        <span class="keyword">if</span> (isEnabledForResource) &#123;</div><div class="line">            <span class="keyword">boolean</span> resourceCheck = TinkerResourceLoader.checkComplete(app, patchVersionDirectory, securityCheck, resultIntent);</div><div class="line">            <span class="keyword">if</span> (!resourceCheck) &#123;</div><div class="line">                <span class="comment">//file not found, do not load patch</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//we should first try rewrite patch info file, if there is a error, we can't load jar</span></div><div class="line">        <span class="keyword">if</span> (mainProcess &amp;&amp; versionChanged) &#123;</div><div class="line">            patchInfo.oldVersion = version;</div><div class="line">            <span class="comment">//update old version to new</span></div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//是否已经进入安全模式</span></div><div class="line">        <span class="keyword">if</span> (!checkSafeModeCount(app)) &#123;</div><div class="line">            ...</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//now we can load patch jar</span></div><div class="line">        <span class="keyword">if</span> (isEnabledForDex) &#123;</div><div class="line">            <span class="keyword">boolean</span> loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//now we can load patch resource</span></div><div class="line">        <span class="keyword">if</span> (isEnabledForResource) &#123;</div><div class="line">            <span class="keyword">boolean</span> loadTinkerResources = TinkerResourceLoader.loadTinkerResources(tinkerLoadVerifyFlag, patchVersionDirectory, resultIntent);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//all is ok!</span></div><div class="line">        ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_OK);</div><div class="line">        Log.i(TAG, <span class="string">"tryLoadPatchFiles: load end, ok!"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>贴的代码省略了好多判空操作，会判断补丁是否存在，检查补丁信息中的数据是否有效，校验补丁签名以及tinkerId与基准包是否一致。在校验签名时，为了加速校验速度，Tinker只校验 <code>*_meta.txt</code>文件，然后再根据meta文件中的md5校验其他文件。<br>其中，meta文件有以下几种：</p>
<ul>
<li>package_meta.txt 补丁包的基本信息</li>
<li>dex_meta.txt     补丁包中dex文件的信息</li>
<li>so_meta.txt      补丁包中so文件的信息</li>
<li>res_meta.txt     补丁包中资源文件的信息</li>
</ul>
<p>然后根据开发者配置的Tinker可补丁类型判断是否可以加载dex，res，so。然后分别分发给TinkerDexLoader、TinkerSoLoader、TinkerResourceLoader分别进行校验是否符合加载条件进而进行加载。</p>
<h2 id="加载补丁dex"><a href="#加载补丁dex" class="headerlink" title="加载补丁dex"></a>加载补丁dex</h2><p>在开始讲load dex之前，先说下Tinker的补丁方案，Tinker采用的是下发差分包，然后在手机端合成全量的dex文件进行加载。而在build.gradle配置中的tinkerPatch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dex.loader = [<span class="string">"com.tencent.tinker.loader.*"</span>,</div><div class="line"><span class="string">"tinker.sample.android.app.SampleApplication"</span>,</div><div class="line"><span class="string">"tinker.sample.android.app.BaseBuildInfo"</span></div><div class="line">]</div></pre></td></tr></table></figure>
<p>这个配置中的类不会出现在任何全量补丁dex里，也就是说在合成后，这些类还在老的dex文件中，比如在补丁前dex顺序是这样的：<code>oldDex1 -&gt; oldDex2 -&gt; oldDex3..</code>，那么假如修改了dex1中的文件，那么补丁顺序是这样的<code>newDex1 -&gt; oldDex1 -&gt; oldDex2...</code>其中合成后的newDex1中的类是oldDex1中除了dex.loader中标明的类之外的所有类，dex.loader中的类依然在oldDex1中。</p>
<p>由于Tinker的方案是基于Multidex实现的修改dexElements的顺序实现的，所以最终还是要修改classLoder中dexPathList中dexElements的顺序。Android中有两种ClassLoader用于加载dex文件，BootClassLoader、PathClassLoader和DexClassLoader都是继承自BaseDexClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span></span></div><div class="line">            String libraryPath, ClassLoader parent) &#123;</div><div class="line">        <span class="keyword">super</span>(parent);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.originalPath = dexPath;</div><div class="line">        <span class="keyword">this</span>.pathList =</div><div class="line">            <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">        Class clazz = pathList.findClass(name);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> clazz;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="comment">//DexPathList</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Element element : dexElements) &#123;</div><div class="line">            DexFile dex = element.dexFile;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</div><div class="line">                Class clazz = dex.loadClassBinaryName(name, definingContext);</div><div class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> clazz;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>最终在DexPathList的findClass中遍历dexElements，谁在前面用谁。而这个dexElements是在方法makeDexElements中生成的，我们的目的就是hook这个方法把dex插入到dexElements的前面。</p>
<p>继续加载流程，首先调用TinkerDexLoader的checkComplete校验dex_meta.xml文件中记载的dex补丁文件和经过opt优化过的文件是否存在，然后调用loadTinkerJars加载补丁dex。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/**</span></div><div class="line">     * Load tinker JARs and add them to</div><div class="line">     * the Application ClassLoader.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> application The application.</div><div class="line">     */</div><div class="line">    <span class="meta">@TargetApi</span>(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">loadTinkerJars</span><span class="params">(Application application, <span class="keyword">boolean</span> tinkerLoadVerifyFlag, String directory, Intent intentResult)</span> </span>&#123;</div><div class="line"></div><div class="line">        PathClassLoader classLoader = (PathClassLoader) TinkerDexLoader.class.getClassLoader();</div><div class="line"></div><div class="line">        String dexPath = directory + <span class="string">"/"</span> + DEX_PATH + <span class="string">"/"</span>;</div><div class="line">        File optimizeDir = <span class="keyword">new</span> File(directory + <span class="string">"/"</span> + DEX_OPTIMIZE_PATH);</div><div class="line"></div><div class="line">        ArrayList&lt;File&gt; legalFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isArtPlatForm = ShareTinkerInternals.isVmArt();</div><div class="line">        <span class="keyword">for</span> (ShareDexDiffPatchInfo info : dexList) &#123;</div><div class="line">            <span class="comment">//for dalvik, ignore art support dex</span></div><div class="line">            <span class="keyword">if</span> (isJustArtSupportDex(info)) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            String path = dexPath + info.realName;</div><div class="line">            File file = <span class="keyword">new</span> File(path);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (tinkerLoadVerifyFlag) &#123;</div><div class="line">                <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">                String checkMd5 = isArtPlatForm ? info.destMd5InArt : info.destMd5InDvm;</div><div class="line">                <span class="keyword">if</span> (!SharePatchFileUtil.verifyDexFileMd5(file, checkMd5)) &#123;</div><div class="line">                    <span class="comment">//it is good to delete the mismatch file</span></div><div class="line">                    ...</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            legalFiles.add(file);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            SystemClassLoaderAdder.installDexes(application, classLoader, optimizeDir, legalFiles);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            Log.e(TAG, <span class="string">"install dexes failed"</span>);</div><div class="line"><span class="comment">//            e.printStackTrace();</span></div><div class="line">            intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, e);</div><div class="line">            ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        Log.i(TAG, <span class="string">"after loaded classloader: "</span> + application.getClassLoader().toString());</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>根据传过来的tinkerLoadVerifyFlag选项控制是否每次加载都要验证dex的md5值，一般来说不需要，默认也是false，会节省加载时间。然后调用SystemClassLoaderAdder去加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SystemClassLoaderAdder</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installDexes</span><span class="params">(Application application, PathClassLoader loader, File dexOptDir, List&lt;File&gt; files)</span></span></div><div class="line">        <span class="keyword">throws</span> Throwable &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!files.isEmpty()) &#123;</div><div class="line">            ClassLoader classLoader = loader;</div><div class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span>) &#123;</div><div class="line">                classLoader = AndroidNClassLoader.inject(loader, application);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//because in dalvik, if inner class is not the same classloader with it wrapper class.</span></div><div class="line">            <span class="comment">//it won't fail at dex2opt</span></div><div class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</div><div class="line">                V23.install(classLoader, files, dexOptDir);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</div><div class="line">                V19.install(classLoader, files, dexOptDir);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</div><div class="line">                V14.install(classLoader, files, dexOptDir);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                V4.install(classLoader, files, dexOptDir);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!checkDexInstall()) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(ShareConstants.CHECK_DEX_INSTALL_FAIL);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>看到这里，如果你之前看过Multidex.install()方法的实现，就会感觉很相似。只不过热修复是把dex插到dexElements的前面，Multidex是把其余的dex插到后面。相同的就是都是分版本加载，我们分别来看，由于v14以下(Android4.0以前)太过古老，我们就不看了，从v14开始。</p>
<h3 id="v14"><a href="#v14" class="headerlink" title="v14"></a>v14</h3><p>14 &lt;= SDK &lt; 19<br>Android 4.0 &lt;= Android系统 &lt; Android 4.4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Installer for platform versions 14, 15, 16, 17 and 18.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V14</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span></span></div><div class="line">                                File optimizedDirectory)</div><div class="line">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</div><div class="line">        NoSuchFieldException, InvocationTargetException, NoSuchMethodException &#123;</div><div class="line">        Field pathListField = ShareReflectUtil.findField(loader, <span class="string">"pathList"</span>);</div><div class="line">        Object dexPathList = pathListField.get(loader);</div><div class="line">        ShareReflectUtil.expandFieldArray(dexPathList, <span class="string">"dexElements"</span>, makeDexElements(dexPathList,</div><div class="line">            <span class="keyword">new</span> ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object[] makeDexElements(</div><div class="line">        Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory)</div><div class="line">        <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException,</div><div class="line">        NoSuchMethodException &#123;</div><div class="line">        Method makeDexElements =</div><div class="line">            ShareReflectUtil.findMethod(dexPathList, <span class="string">"makeDexElements"</span>, ArrayList.class, File.class);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>反射找到classLoder中的pathList，然后反射调用pathList中的makeDexElements方法，穿进去的参数分别是补丁dexList和优化过的opt目录，在Tinker中是dex补丁目录的同级目录<code>odex/</code>。</p>
<p>其中有个ShareReflectUtil.expandFieldArray我们看下实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expandFieldArray</span><span class="params">(Object instance, String fieldName, Object[] extraElements)</span></span></div><div class="line">    <span class="keyword">throws</span> NoSuchFieldException, IllegalArgumentException, IllegalAccessException &#123;</div><div class="line">    Field jlrField = findField(instance, fieldName);</div><div class="line"></div><div class="line">    Object[] original = (Object[]) jlrField.get(instance);</div><div class="line">    Object[] combined = (Object[]) Array.newInstance(original.getClass().getComponentType(), original.length + extraElements.length);</div><div class="line"></div><div class="line">    <span class="comment">// <span class="doctag">NOTE:</span> changed to copy extraElements first, for patch load first</span></div><div class="line"></div><div class="line">    System.arraycopy(extraElements, <span class="number">0</span>, combined, <span class="number">0</span>, extraElements.length);</div><div class="line">    System.arraycopy(original, <span class="number">0</span>, combined, extraElements.length, original.length);</div><div class="line"></div><div class="line">    jlrField.set(instance, combined);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意传进来的值分别是pathList,”dexElements”和新生成的dexElements数组，找到pathList的原始oldDexElements，然后生成一个新的数组combined，长度是oldDexElements.length + newDexElements.length。然后将newDexElements拷贝到combined的前面，将oldDexElements拷贝的combined的剩余位置，我们称之为dex前置。</p>
<p>刚才我们说Tinker是将dex前置，Multidex是将dex后置，我们顺便看下Multidex.install()中expandFieldArray的实现吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Multidex.java</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expandFieldArray</span><span class="params">(Object instance, String fieldName,</span></span></div><div class="line">            Object[] extraElements) <span class="keyword">throws</span> NoSuchFieldException, IllegalArgumentException,</div><div class="line">            IllegalAccessException &#123;</div><div class="line">        Field jlrField = findField(instance, fieldName);</div><div class="line">        Object[] original = (Object[]) jlrField.get(instance);</div><div class="line">        Object[] combined = (Object[]) Array.newInstance(</div><div class="line">                original.getClass().getComponentType(), original.length + extraElements.length);</div><div class="line">        System.arraycopy(original, <span class="number">0</span>, combined, <span class="number">0</span>, original.length);</div><div class="line">        System.arraycopy(extraElements, <span class="number">0</span>, combined, original.length, extraElements.length);</div><div class="line">        jlrField.set(instance, combined);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>它是先把oldDexElements拷贝到了前面，在把newDexElements拷贝到了后面，我们称之为dex后置。</p>
<p>实际上，对于Multidex的项目，不论Tinker是否加载了补丁，都应该在ApplicationLike的onBaseContextAttached方法中执行<code>MultiDex.install(base);</code>。</p>
<h3 id="v19"><a href="#v19" class="headerlink" title="v19"></a>v19</h3><p>19 &lt;= SDK &lt; 23<br>Android 4.4 &lt;= Android系统 &lt; Android 6.0</p>
<p>跟v14的区别不大，只是在makeDexElements方法中多加了一个参数suppressedExceptions异常数组，另外在makeDexElements的catch异常中多加了一次重试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">                Log.e(TAG, <span class="string">"NoSuchMethodException: makeDexElements(ArrayList,File,ArrayList) failure"</span>);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    makeDexElements = ShareReflectUtil.findMethod(dexPathList, <span class="string">"makeDexElements"</span>, List.class, File.class, List.class);</div><div class="line">                &#125; <span class="keyword">catch</span> (NoSuchMethodException e1) &#123;</div><div class="line">                    Log.e(TAG, <span class="string">"NoSuchMethodException: makeDexElements(List,File,List) failure"</span>);</div><div class="line">                    <span class="keyword">throw</span> e1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>是因为Tinker发现线上有的Rom将改方法参数类型给改了，本来是<code>makeDexElements(ArrayList,File,ArrayList)</code>，给改成了<code>makeDexElements(List,File,List)</code>，做了个兼容处理。</p>
<h3 id="v23"><a href="#v23" class="headerlink" title="v23"></a>v23</h3><p>23 &lt;= SDK &lt; 24<br>Android 6.0 &lt;= Android系统 &lt; Android 7.0</p>
<p>Android6.0以后把makeDexElements给改了，改成了<code>makePathElements(List,File,List)</code>，如果找不到的话再找一下<code>makeDexElements(List,File,List)</code>。其余没啥区别。</p>
<h3 id="v24"><a href="#v24" class="headerlink" title="v24"></a>v24</h3><p>SDK &gt;=24<br>Android 系统 &gt;= Android7.0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span>) &#123;</div><div class="line">    classLoader = AndroidNClassLoader.inject(loader, application);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>哎，这个好像跟上面不太一样啊，这是为啥呢。<br><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286341&amp;idx=1&amp;sn=054d595af6e824cbe4edd79427fc2706&amp;scene=0" target="_blank" rel="external">Android N混合编译与对热补丁影响解析</a>中详细解释了混合编译对热不定的影响。我做下简单的总结。</p>
<p>我们知道，在Dalvik虚拟机中，总是在运行时通过JIT（Just-In—Time）把字节码文件编译成机器码文件再执行，这样跑起来程序就很慢，所在ART上，改为AOT（Ahead-Of—Time）提前编译，即在安装应用或OTA系统升级时提前把字节码编译成机器码，这样就可以直接执行了，提高了运行效率。但是AOT有个缺点就是每次执行的时间都太长了，并且占用的ROM空间又很大，所以在Android N上Google做了混合编译同时支持JIT和AOT。混合编译的作用简单来说，在应用运行时分析运行过的代码以及“热代码”，并将配置存储下来。在设备空闲与充电时，ART仅仅编译这份配置中的“热代码”。</p>
<p>简单来说，就是在应用安装和首次运行不做AOT编译，先让用户愉快的玩耍起来，然后把在运行中JIT解释执行的那部分代码收集起来，在手机空闲的时候通过dex2aot编译生成一份名为app image的base.art文件，然后在下次启动的时候一次性把app image加载进来到缓存，预先加载代替用时查找以提升应用的性能。</p>
<p>这种方式对热补丁的影响就是，app image中已经存在的类会被插入到ClassLoader的ClassTable，再次加载类时，直接从ClassTable中取而不会走DefineClass。假设base.art文件在补丁前已经存在，这里存在三种情况：</p>
<ol>
<li>补丁修改的类都不appimage中；这种情况是最理想的，此时补丁机制依然有效；</li>
<li>补丁修改的类部分在appimage中；这种情况我们只能更新一部分的类，此时是最危险的。一部分类是新的，一部分类是旧的，app可能会出现地址错乱而出现crash。</li>
<li>补丁修改的类全部在appimage中；这种情况只是造成补丁不生效，app并不会因此造成crash。</li>
</ol>
<p>Tinker的解决方案是，完全废弃掉PathClassloader，而采用一个新建Classloader来加载后续的所有类，即可达到将cache无用化的效果。基本原理我们清楚了，让我们来看下代码吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//AndroidNClassLoader.java</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AndroidNClassLoader <span class="title">inject</span><span class="params">(PathClassLoader originClassLoader, Application application)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        AndroidNClassLoader classLoader = createAndroidNClassLoader(originClassLoader);</div><div class="line">        reflectPackageInfoClassloader(application, classLoader);</div><div class="line">        <span class="keyword">return</span> classLoader;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AndroidNClassLoader <span class="title">createAndroidNClassLoader</span><span class="params">(PathClassLoader original)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//let all element ""</span></div><div class="line">        AndroidNClassLoader androidNClassLoader = <span class="keyword">new</span> AndroidNClassLoader(<span class="string">""</span>,  original);</div><div class="line">        Field originPathList = findField(original, <span class="string">"pathList"</span>);</div><div class="line">        Object originPathListObject = originPathList.get(original);</div><div class="line">        <span class="comment">//should reflect definingContext also</span></div><div class="line">        Field originClassloader = findField(originPathListObject, <span class="string">"definingContext"</span>);</div><div class="line">        originClassloader.set(originPathListObject, androidNClassLoader);</div><div class="line">        <span class="comment">//copy pathList</span></div><div class="line">        Field pathListField = findField(androidNClassLoader, <span class="string">"pathList"</span>);</div><div class="line">        <span class="comment">//just use PathClassloader's pathList</span></div><div class="line">        pathListField.set(androidNClassLoader, originPathListObject);</div><div class="line">        <span class="keyword">return</span> androidNClassLoader;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们按步骤进行：</p>
<ol>
<li>新建一个AndroidNClassLoader 它的parent是originPathClassLoader。注意，PathClassLoader的optimizedDirectory只能是null，这个后面还有用。</li>
<li>找到originPathClassLoader中的pathList 和 pathList中的类型为ClassLoader的definingContext。</li>
<li>替换definingContext为AndroidNClassLoader</li>
<li>将AndroidNClassLoader中的pathList替换为originPathClassLoader的pathList。</li>
</ol>
<p>有的同学可能会问，Android 的ClassLoader采用双亲委托模型，只有parent找不到的情况下才会去找AndroidNClassLoader，那我新建这个AndroidNClassLoader有什么用，最终还是会去originPathClassLoader中取找。其实不是这样的，我们已经将originPathClassLoader中pathList中的definingContext(是个ClassLoader)替换为了AndroidNClassLoader了。这个definingContext会在生成DexFile的时候传递进去，而ClassLoader的findClass()方法会调用pathList的findClass方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//DexPathList.java</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Element element : dexElements) &#123;</div><div class="line">            DexFile dex = element.dexFile;</div><div class="line">            <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</div><div class="line">                Class clazz = dex.loadClassBinaryName(name, definingContext);</div><div class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> clazz;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>最终还是调用的dexFile.loadClassBinaryName()方法，其中的第二个参数其实就已经是AndroidNClassLoader了。</p>
<p>还记得刚才说的AndroidNClassLder的optimizedDirectory是null吗</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//DexPathList.java</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files,</div><div class="line">            File optimizedDirectory) &#123;</div><div class="line">            ...</div><div class="line">            dex = loadDexFile(file, optimizedDirectory);</div><div class="line">            ....</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title">loadDexFile</span><span class="params">(File file, File optimizedDirectory)</span></span></div><div class="line">            <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DexFile(file);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            String optimizedPath = optimizedPathFor(file, optimizedDirectory);</div><div class="line">            <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>看到这里我们明白了，optimizedDirectory是用来缓存我们需要加载的dex文件的，并创建一个DexFile对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile对象。意思也就是说我不需要用缓存，不需要用app image加载。</p>
<p>接续往下走</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reflectPackageInfoClassloader</span><span class="params">(Application application, ClassLoader reflectClassLoader)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    String defBase = <span class="string">"mBase"</span>;</div><div class="line">    String defPackageInfo = <span class="string">"mPackageInfo"</span>;</div><div class="line">    String defClassLoader = <span class="string">"mClassLoader"</span>;</div><div class="line"></div><div class="line">    Context baseContext = (Context) findField(application, defBase).get(application);</div><div class="line">    Object basePackageInfo = findField(baseContext, defPackageInfo).get(baseContext);</div><div class="line">    Field classLoaderField = findField(basePackageInfo, defClassLoader);</div><div class="line">    Thread.currentThread().setContextClassLoader(reflectClassLoader);</div><div class="line">    classLoaderField.set(basePackageInfo, reflectClassLoader);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>作用是替换掉了mPackageInfo中的ClassLoader，mPackageInfo是LoadedApk的对象，代表了APK文件在内存中的表示，诸如Apk文件的代码和资源，甚至代码里面的Activity，Service等组件的信息我们都可以通过此对象获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ActivityThread.java</span></div><div class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</div><div class="line">activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</div><div class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());</div><div class="line">r.intent.setExtrasClassLoader(cl);</div></pre></td></tr></table></figure>
<p>到这里就完成了AndroidNClassLoader的创建与替换，接下来的加载过程使用了v23的加载流程，就不细说了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，整个dex加载流程就分析完了。我们看到Tinker在兼容性上做了充足的工作，整个加载流程虽然跟其他基于Multidex的热补丁框架差不多，但是在兼容性上做了更完备的处理。</p>
<h2 id="加载补丁资源"><a href="#加载补丁资源" class="headerlink" title="加载补丁资源"></a>加载补丁资源</h2><p>Tinker的资源更新采用的InstantRun的资源补丁方式，全量替换资源。由于App加载资源是依赖Context.getResources()方法返回的Resources对象，Resources 内部包装了 AssetManager，最终由 AssetManager 从 apk 文件中加载资源。我们要做的就是新建一个AssetManager()，hook掉其中的addAssetPath()方法，将我们的资源补丁目录传递进去，然后循环替换Resources对象中的AssetManager对象，达到资源替换的目的。看下代码实现。</p>
<p>首先依然先根据res_meta.xml文件中记载的信息检查文件(res/resources.apk)是否存在，实现在TinkerResourceLoader.checkComplete()方法，然后调用<code>TinkerResourcePatcher.isResourceCanPatch(context);</code>判断是否支持反射更新资源，看下具体的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">isResourceCanPatch</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="comment">// Create a new AssetManager instance and point it to the resources installed under /sdcard</span></div><div class="line">    AssetManager assets = context.getAssets();</div><div class="line">    <span class="comment">// Baidu os</span></div><div class="line">    <span class="keyword">if</span> (assets.getClass().getName().equals(<span class="string">"android.content.res.BaiduAssetManager"</span>)) &#123;</div><div class="line">        Class baiduAssetManager = Class.forName(<span class="string">"android.content.res.BaiduAssetManager"</span>);</div><div class="line">        newAssetManager = (AssetManager) baiduAssetManager.getConstructor().newInstance();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        newAssetManager = AssetManager.class.getConstructor().newInstance();</div><div class="line">    &#125;</div><div class="line">    addAssetPathMethod = AssetManager.class.getDeclaredMethod(<span class="string">"addAssetPath"</span>, String.class);</div><div class="line">    addAssetPathMethod.setAccessible(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Kitkat needs this method call, Lollipop doesn't. However, it doesn't seem to cause any harm</span></div><div class="line">    <span class="comment">// in L, so we do it unconditionally.</span></div><div class="line">    ensureStringBlocksMethod = AssetManager.class.getDeclaredMethod(<span class="string">"ensureStringBlocks"</span>);</div><div class="line">    ensureStringBlocksMethod.setAccessible(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Iterate over all known Resources objects</span></div><div class="line">    <span class="keyword">if</span> (SDK_INT &gt;= KITKAT) &#123;</div><div class="line">        <span class="comment">//pre-N</span></div><div class="line">        <span class="comment">// Find the singleton instance of ResourcesManager</span></div><div class="line">        Class&lt;?&gt; resourcesManagerClass = Class.forName(<span class="string">"android.app.ResourcesManager"</span>);</div><div class="line">        Method mGetInstance = resourcesManagerClass.getDeclaredMethod(<span class="string">"getInstance"</span>);</div><div class="line">        mGetInstance.setAccessible(<span class="keyword">true</span>);</div><div class="line">        Object resourcesManager = mGetInstance.invoke(<span class="keyword">null</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Field fMActiveResources = resourcesManagerClass.getDeclaredField(<span class="string">"mActiveResources"</span>);</div><div class="line">            fMActiveResources.setAccessible(<span class="keyword">true</span>);</div><div class="line">            ArrayMap&lt;?, WeakReference&lt;Resources&gt;&gt; arrayMap =</div><div class="line">                (ArrayMap&lt;?, WeakReference&lt;Resources&gt;&gt;) fMActiveResources.get(resourcesManager);</div><div class="line">            references = arrayMap.values();</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException ignore) &#123;</div><div class="line">            <span class="comment">// N moved the resources to mResourceReferences</span></div><div class="line">            Field mResourceReferences = resourcesManagerClass.getDeclaredField(<span class="string">"mResourceReferences"</span>);</div><div class="line">            mResourceReferences.setAccessible(<span class="keyword">true</span>);</div><div class="line">            <span class="comment">//noinspection unchecked</span></div><div class="line">            references = (Collection&lt;WeakReference&lt;Resources&gt;&gt;) mResourceReferences.get(resourcesManager);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Class&lt;?&gt; activityThread = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</div><div class="line">        Field fMActiveResources = activityThread.getDeclaredField(<span class="string">"mActiveResources"</span>);</div><div class="line">        fMActiveResources.setAccessible(<span class="keyword">true</span>);</div><div class="line">        Object thread = getActivityThread(context, activityThread);</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        HashMap&lt;?, WeakReference&lt;Resources&gt;&gt; map =</div><div class="line">            (HashMap&lt;?, WeakReference&lt;Resources&gt;&gt;) fMActiveResources.get(thread);</div><div class="line">        references = map.values();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// check resource</span></div><div class="line">    <span class="keyword">if</span> (references == <span class="keyword">null</span> || references.isEmpty()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"resource references is null or empty"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        assetsFiled = Resources.class.getDeclaredField(<span class="string">"mAssets"</span>);</div><div class="line">        assetsFiled.setAccessible(<span class="keyword">true</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</div><div class="line">        <span class="comment">// N moved the mAssets inside an mResourcesImpl field</span></div><div class="line">        resourcesImplFiled = Resources.class.getDeclaredField(<span class="string">"mResourcesImpl"</span>);</div><div class="line">        resourcesImplFiled.setAccessible(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>按照步骤来吧，首先新建一个AssetManager对象，其中对BaiduROM做了兼容(BaiduAssetManager)，拿到其中的addAssetPath方法的反射addAssetPathMethod，然后拿到ensureStringBlocks的反射，然后区分版本拿到Resources的集合。</p>
<ul>
<li>SDK &gt;= 19，从ResourcesManager中拿到mActiveResources变量，是个持有Resources的ArrayMap，赋值给references，Android N中该变量叫做mResourceReferences</li>
<li>SDK &lt; 19，从ActivityThread中获取mActiveResources，是个HashMap持有Resources，赋值给references</li>
</ul>
<p>如果references为空，说明该系统不支持资源补丁，throw 一个IllegalStateException被上层调用catch。</p>
<p>然后调用monkeyPatchExistingResources方法(这个方法的名字跟InstantRun的资源补丁方法名是一样的)，将补丁资源路径(res/resources.apk)传递进去，代码就不贴了，简单描述为反射调用新建的AssetManager的addAssetPath将路径穿进去，然后主动调用ensureStringBlocks方法确保资源的字符串索引创建出来；然后循环遍历持有Resources对象的references集合，依次替换其中的AssetManager为新建的AssetManager，最后调用Resources.updateConfiguration将Resources对象的配置信息更新到最新状态，完成整个资源替换的过程。</p>
<p>目前来看InstantRun的资源更新方式最简便而且兼容性也最好，市面上大多数的热补丁框架都采用这套方案。Tinker的这套方案虽然也采用全量的替换，但是在下发patch中依然采用差量资源的方式获取差分包，下发到手机后再合成全量的资源文件，有效的控制了补丁文件的大小。</p>
<h2 id="加载补丁so"><a href="#加载补丁so" class="headerlink" title="加载补丁so"></a>加载补丁so</h2><p>依然根据so_meta.txt中的补丁信息校验so文件是否都存在。然后将so补丁列表存放在结果中libs的字段。</p>
<p>so的更新方式跟dex和资源都不太一样，因为系统提供给了开发者自定义so目录的选项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(String pathName)</span> </span>&#123;</div><div class="line">        Runtime.getRuntime().load(pathName, VMStack.getCallingClassLoader());</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Tinker加载SO补丁提供了两个入口，分别是TinkerInstaller和TinkerApplicationHelper。他们两个的区别是TinkerInstaller只有在Tinker.install过之后才能使用,否则会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//TinkerInstaller</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">loadLibraryFromTinker</span><span class="params">(Context context, String relativePath, String libname)</span> <span class="keyword">throws</span> UnsatisfiedLinkError </span>&#123;</div><div class="line">        <span class="keyword">final</span> Tinker tinker = Tinker.with(context);</div><div class="line"></div><div class="line">        libname = libname.startsWith(<span class="string">"lib"</span>) ? libname : <span class="string">"lib"</span> + libname;</div><div class="line">        libname = libname.endsWith(<span class="string">".so"</span>) ? libname : libname + <span class="string">".so"</span>;</div><div class="line">        String relativeLibPath = relativePath + <span class="string">"/"</span> + libname;</div><div class="line"></div><div class="line">        <span class="comment">//TODO we should add cpu abi, and the real path later</span></div><div class="line">        <span class="keyword">if</span> (tinker.isEnabledForNativeLib() &amp;&amp; tinker.isTinkerLoaded()) &#123;</div><div class="line">            TinkerLoadResult loadResult = tinker.getTinkerLoadResultIfPresent();</div><div class="line">            <span class="keyword">if</span> (loadResult.libs != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">for</span> (String name : loadResult.libs.keySet()) &#123;</div><div class="line">                    <span class="keyword">if</span> (name.equals(relativeLibPath)) &#123;</div><div class="line">                        String patchLibraryPath = loadResult.libraryDirectory + <span class="string">"/"</span> + name;</div><div class="line">                        File library = <span class="keyword">new</span> File(patchLibraryPath);</div><div class="line">                        <span class="keyword">if</span> (library.exists()) &#123;</div><div class="line">                            <span class="comment">//whether we check md5 when load</span></div><div class="line">                            <span class="keyword">boolean</span> verifyMd5 = tinker.isTinkerLoadVerify();</div><div class="line">                            <span class="keyword">if</span> (verifyMd5 &amp;&amp; !SharePatchFileUtil.verifyFileMd5(library, loadResult.libs.get(name))) &#123;</div><div class="line">                                tinker.getLoadReporter().onLoadFileMd5Mismatch(library, ShareConstants.TYPE_LIBRARY);</div><div class="line">                            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                System.load(patchLibraryPath);</div><div class="line">                                TinkerLog.i(TAG, <span class="string">"loadLibraryFromTinker success:"</span> + patchLibraryPath);</div><div class="line">                                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>简单来说就是遍历检查的结果列表libs，找到要加载的类，调用System.load方法进行加载。</p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>在集成Tinker的过程中，遇到了一个问题(环境是Dalvik，ART没问题)，在前面我们提到了dex.loader的配置，我把项目中用于下载补丁文件的工具类A加到了其中，然后下发补丁报错，出现Class ref in pre-verified class resolved to unexpected  implementation的crash。Qzone的那套热补丁为了消除这个错误采用插庄的方式来规避，Tinker采用全量dex的方式来规避该问题，那为什么还会出现呢。</p>
<p>根据log找到了报错点是在工具类A中的一个直接引用类B的方法中报错。错误原因在加载补丁dex一节其实已经提到一些，我们引用过来，这个配置(dex.loader)中的类不会出现在任何全量补丁dex里，也就是说在合成后，这些类还在老的dex文件中，比如在补丁前dex顺序是这样的：<code>oldDex1 -&gt; oldDex2 -&gt; oldDex3..</code>，那么假如修改了dex1中的文件，那么补丁顺序是这样的<code>newDex1 -&gt; oldDex1 -&gt; oldDex2...</code>其中合成后的newDex1中的类是oldDex1中除了dex.loader中标明的类之外的所有类，dex.loader中的类依然在oldDex1中。<br>也就是说A类是在dex.loader配置中的，补丁后，A依然在oldDex1中，而A的直接引用类B却出现在了newDex1中，并且在之前A类已经被打上了preverify标志，所在A再去newDex1中加载B的话就会报该错误。</p>
<p>那有的同学可能会问了，TinkerApplication也在oldDex1中的，而我们的ApplicationLike在补丁后也出现在了newDex1中，TinkerApplication反射调用ApplicationLike的生命周期方法为什么没有出现crash呢？还记得文章前面的有一个反射么，我们说了要注意后面会讲到，就是在这里用到的。</p>
<p>校验preverify的方法，正常的类加载会走到这里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ClassObject* dvmResolveClass(<span class="keyword">const</span> ClassObject* referrer, u4 classIdx,</div><div class="line">    bool fromUnverifiedConstant)</div><div class="line">&#123;</div><div class="line">....</div><div class="line">       <span class="keyword">if</span> (!fromUnverifiedConstant &amp;&amp;</div><div class="line">            IS_CLASS_FLAG_SET(referrer, CLASS_ISPREVERIFIED))</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而反射走了完全不同的路径，不会走到dvmResolveClass方法，也就不会报错了。关于这个方法，我们下篇文章会详细讲解。反射最直接的目的也是为了隔离开这两个类，也就是隔离开了Tinker组件和app。如图</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/ref.png" alt=""></p>
<p>通过反射，将Tinker组建和App隔离开，并且先后顺序是先Tinker后App，这样可以防止App中的代码提前加载，确保App中所有的代码都可以具有被热修复的能力包括ApplicationLike。</p>
<p>然后又有同学问了，为啥Dalvik有问题，ART没问题呢？那是因为在ART虚拟机原生支持从APK文件加载多个dex文件。在应用安装时执行dex2oat扫描 classes(..N).dex文件，并将它们编译成单个oat文件，供 Android设备执，也就不存在MultiDex的问题了。</p>
<p>这个问题的<a href="https://github.com/Tencent/tinker/issues/124" target="_blank" rel="external">issue</a></p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>到这里，Tinker的基本补丁加载流程就分析完了，本文只对补丁加载流程加以分析，对dexDiff差分以及补丁加载没有做说明，如果你对这部分感兴趣可以参考这篇文章<a href="https://www.zybuluo.com/dodola/note/554061" target="_blank" rel="external">Tinker Dexdiff算法解析</a>。另外ART下的内联影响和OTA升级没有做过多说明，Tinker官方已经有相关文章。</p>
<p>我们简单对Tinker做下总结。<br>优点：</p>
<ul>
<li>支持类、资源、so修复</li>
<li>兼容性处理的很好，全平台支持</li>
<li>由于不用插庄，所以性能损耗很小</li>
<li>完善的开发文档和官方技术支持</li>
<li>gradle支持，再自己定义下可以一键打补丁包</li>
<li>dexDiff算法使得补丁文件较小</li>
<li>扩展性良好，代码中处处为开发者留出开放接口，简直业界良心</li>
<li>支持多次补丁</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持及时生效，下发补丁需要重启生效，MultiDex方案决定的</li>
<li>占用ROM空间较大，这点空间在如今的手机大ROM下也不算个事</li>
<li>对加固支持不太好</li>
</ul>
<p>总结下来Tinker是一种基于单ClassLoader加载多dex方案的热补丁框架，兼容性做的比较好，功能强大。如果你正在考虑接入热补丁，那么强烈推荐你使用Tinker，地精修补匠，带你无限刷新！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286384&amp;idx=1&amp;sn=f1aff31d6a567674759be476bcd12549&amp;scene=4#wechat_redirect" target="_blank" rel="external">微信Tinker的一切都在这里，包括源码(一)</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286341&amp;idx=1&amp;sn=054d595af6e824cbe4edd79427fc2706&amp;scene=0" target="_blank" rel="external">Android N混合编译与对热补丁影响解析</a><br><a href="https://www.zybuluo.com/dodola/note/554061" target="_blank" rel="external">Tinker Dexdiff算法解析</a><br><a href="http://w4lle.github.io/2016/05/02/%E4%BB%8EInstant%20run%E8%B0%88Android%E6%9B%BF%E6%8D%A2Application%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">从Instant run谈Android替换Application和动态加载机制</a><br><a href="https://segmentfault.com/a/1190000004062880" target="_blank" rel="external">Android动态加载基础 ClassLoader工作机制</a><br><a href="http://blog.csdn.net/luoshengyang/article/details/8791064" target="_blank" rel="external">Android应用程序资源管理器（Asset Manager）的创建过程分析</a></p>
<p>本文链接： <a href="http://w4lle.com/2016/12/16/tinker/">http://w4lle.com/2016/12/16/tinker/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tinker系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://w4lle.github.io/2016/12/16/tinker/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android热补丁之Tinker原理解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://w4lle.github.io/2017/01/05/one-key-for-tinker/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一键接入Tinker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://w4lle.github.io/2017/01/22/gradle-modules/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gradle模块化配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文是第一篇。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文分析版本  &lt;a href=&quot;https://github.com/Tencent/tinker/tree/93ecc9351367badc02a91fac25764bee50e6e6a6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;93ecc9351367badc02a91fac25764bee50e6e6a6&lt;/a&gt;&lt;br&gt;项目地址： &lt;a href=&quot;https://github.com/Tencent/tinker/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Tinker&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在今年的MDCC大会上，微信开发团队宣布正式开源Tinker，在这之前微信团队已经发出过一些Tinker的相关文章，说实话在开源之前我们还是相当期待Tinker开源的，一方面是因为之前使用的热补丁一直存在一些兼容性问题，另一方面也好奇Tinker的实现方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
      <category term="热补丁" scheme="http://w4lle.com/tags/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>AndroidStudio 常用快捷键</title>
    <link href="http://w4lle.com/2016/12/14/AndroidStudio-shotcurts-md/"/>
    <id>http://w4lle.com/2016/12/14/AndroidStudio-shotcurts-md/</id>
    <published>2016-12-14T10:47:01.000Z</published>
    <updated>2017-01-06T01:51:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>整理了下常用的快捷键<br>因为我用AndroidStudio的vim插件，所以在编辑这块没有整理太多。<br>需要的同学可以自己学些下。</p>
<p>熟记这些快捷键 + vim = 基本不用鼠标 = 提升效率50%</p>
<a id="more"></a>
<h1 id="AS-常用快捷键"><a href="#AS-常用快捷键" class="headerlink" title="AS 常用快捷键"></a>AS 常用快捷键</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul>
<li>cmd + o                  打开class文件</li>
<li>cmd + shift + o          打开任意文件</li>
<li>cmd + alt + o            打开变量所在文件</li>
<li>shift + shift            打开任意位置文件</li>
<li>cmd + e                  最近使用文件</li>
<li>cmd + shift + e          最近修改文件</li>
<li>cmd + u                  打开父类</li>
</ul>
<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><ul>
<li>cmd + number             打开工具面板</li>
<li>shift + esc              关闭当前工具面板</li>
<li>cmd + shift + F12        关闭所有面板</li>
<li>esc                      焦点切换回编辑器</li>
<li>F12                      重新打开上次所在工具面板</li>
<li>alt + F12                打开terminal</li>
<li>ctrl + tab               在最近打开tab间切换</li>
<li>ctrl + h                 继承结构</li>
<li>ctrl + alt + h           方法调用路径</li>
</ul>
<h3 id="导航（二）"><a href="#导航（二）" class="headerlink" title="导航（二）"></a>导航（二）</h3><ul>
<li>cmd + shift + h          方法结构            </li>
<li>alt + F1                 在Finder中打开</li>
<li>cmd + []                 光标历史跳转</li>
<li>cmd + ,                  打开设置</li>
<li>cmd + down               打开项目设置</li>
<li>cmd + l                  跳转到指定行</li>
<li>F2                       跳转到下一个报错的位置</li>
</ul>
<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><ul>
<li>cmd + shift + enter      语句补全</li>
<li>alt + enter              智能纠错</li>
<li>tab/enter                代码补全</li>
<li>!                        取反补全</li>
<li>cmd + j                  模板方法</li>
<li>.                        后缀补全</li>
<li>cmd + p                  查看方法参数</li>
<li>cmd + shift + up/down    上下移动代码</li>
<li>cmd + /                  注释一行</li>
<li>cmd + alt + /            注释多行</li>
</ul>
<h3 id="编辑（二）"><a href="#编辑（二）" class="headerlink" title="编辑（二）"></a>编辑（二）</h3><ul>
<li>cmd + alt + t            Surround with</li>
<li>shift + j                合并下一行代码为一行</li>
<li>cmd + alt + l            格式化代码</li>
<li>cmd + n                  生成代码</li>
<li>ctrl + space             唤出自动补全</li>
<li>cmd + F12                当前类内容结构</li>
<li>hold alt                 块操作</li>
<li>cmd + y                  方法预览</li>
<li>ctrl + shift + q         上下文信息</li>
</ul>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><ul>
<li>ctrl + o                 重写方法</li>
<li>ctrl + i                 实现方法</li>
<li>cmd + alt + m            抽取方法</li>
</ul>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul>
<li>shift + F10                 run</li>
<li>cmd + F9                    make</li>
</ul>
<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><ul>
<li>F8                          下一步</li>
<li>F7                          进入</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul>
<li>cmd + f                       </li>
<li>cmd + shift + f               全局搜索</li>
<li>cmd + alt + F7                预览方法调用</li>
<li>alt + F7                      方法调用</li>
</ul>
<h2 id="万能键"><a href="#万能键" class="headerlink" title="万能键"></a>万能键</h2><ul>
<li>cmd + shift + a </li>
</ul>
<p>ppt:</p>
<p><a href="http://w4lle.github.io/sliders/androidstudio-shortcurts/index.html" target="_blank" rel="external">http://w4lle.github.io/sliders/androidstudio-shortcurts/index.html</a></p>
<p>本文链接： <a href="http://w4lle.com/2016/12/14/AndroidStudio-shotcurts-md/">http://w4lle.com/2016/12/14/AndroidStudio-shotcurts-md/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;快捷键&quot;&gt;&lt;a href=&quot;#快捷键&quot; class=&quot;headerlink&quot; title=&quot;快捷键&quot;&gt;&lt;/a&gt;快捷键&lt;/h1&gt;&lt;p&gt;整理了下常用的快捷键&lt;br&gt;因为我用AndroidStudio的vim插件，所以在编辑这块没有整理太多。&lt;br&gt;需要的同学可以自己学些下。&lt;/p&gt;
&lt;p&gt;熟记这些快捷键 + vim = 基本不用鼠标 = 提升效率50%&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp3 源码浅析</title>
    <link href="http://w4lle.com/2016/12/06/OkHttp/"/>
    <id>http://w4lle.com/2016/12/06/OkHttp/</id>
    <published>2016-12-06T08:20:52.000Z</published>
    <updated>2017-01-06T01:53:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前的底层网络库基本就是Apache HttpClient和HttpURLConnection。由于HttClient比较难用，官方在Android2.3以后就不建议用了，并且在Android5.0以后废弃了HttpClient，在Android6.0更是删除了HttpClient。</p>
<p>HttpURLConnection是一种多用途、轻量极的HTTP客户端，使用它来进行HTTP操作可以适用于大多数的应用程序，但是在Android 2.2版本之前存在一些bug，所以官方建议在Android2.3以后替代HttpClient，Volley就是按版本分区使用这两个网络库。</p>
<p>然而随着开源届扛把子Square的崛起，OkHttp的开源，这两个网络库只能被淹没在历史洪流中。Android4.4以后HttpURLConnection的底层已经替换成OkHttp实现。OkHttp配合同样是Square开源的Retrofit，网络请求变得更简便，功能更强大。</p>
<h1 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h1><p>OkHttp是一个现代，快速，高效的网络库，OkHttp 库的设计和实现的首要目标是高效。</p>
<ul>
<li>支持 HTTP/2和SPDY，这使得对同一个主机发出的所有请求都可以共享相同的套接字连接；</li>
<li>如果 HTTP/2和SPDY不可用，OkHttp会使用连接池来复用连接以提高效率。</li>
<li>支持Gzip降低传输内容的大小</li>
<li>支持Http缓存</li>
<li>会从很多常用的连接问题中自动恢复。如果服务器配置了多个IP地址，OkHttp 会自动重试一个主机的多个 IP 地址。</li>
<li>使用Okio来大大简化数据的访问与存储，提高性能</li>
</ul>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>简单的异步请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line">    Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">            .url(url)</div><div class="line">            .build();</div><div class="line"></div><div class="line">    client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Request request, IOException e)</span>  </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            System.out.println(response.body().string());</div><div class="line">        &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>使用非常的简答，发送请求，拿到异步结果。</p>
<h2 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a>OkHttpClient</h2><p>跟下源码，OkHttpClient.newCall实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Call</span>.<span class="title">Factory</span></span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    Dispatcher dispatcher;</div><div class="line">    Proxy proxy;</div><div class="line">    List&lt;Protocol&gt; protocols;</div><div class="line">    List&lt;ConnectionSpec&gt; connectionSpecs;</div><div class="line">    <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">final</span> List&lt;Interceptor&gt; networkInterceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    ProxySelector proxySelector;</div><div class="line">    CookieJar cookieJar;</div><div class="line">    Cache cache;</div><div class="line">    InternalCache internalCache;</div><div class="line">    SocketFactory socketFactory;</div><div class="line">    SSLSocketFactory sslSocketFactory;</div><div class="line">    CertificateChainCleaner certificateChainCleaner;</div><div class="line">    HostnameVerifier hostnameVerifier;</div><div class="line">    CertificatePinner certificatePinner;</div><div class="line">    Authenticator proxyAuthenticator;</div><div class="line">    Authenticator authenticator;</div><div class="line">    ConnectionPool connectionPool;</div><div class="line">    Dns dns;</div><div class="line">    <span class="keyword">boolean</span> followSslRedirects;</div><div class="line">    <span class="keyword">boolean</span> followRedirects;</div><div class="line">    <span class="keyword">boolean</span> retryOnConnectionFailure;</div><div class="line">    <span class="keyword">int</span> connectTimeout;</div><div class="line">    <span class="keyword">int</span> readTimeout;</div><div class="line">    <span class="keyword">int</span> writeTimeout;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    ...</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RealCall(<span class="keyword">this</span>, request);</div><div class="line">    ...</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OkHttpClient通过Builder实例化，实现了Call.Factory接口创建了一个RealCall的实例，而RealCall是Call接口的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Call</span> </span>&#123;</div><div class="line">  <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</div><div class="line">  <span class="function">Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isExecuted</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span></span>;</div><div class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</div><div class="line">    <span class="function">Call <span class="title">newCall</span><span class="params">(Request request)</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="RealCall"><a href="#RealCall" class="headerlink" title="RealCall"></a>RealCall</h2><p>RealCall中封装了OKHttpClient和Request</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">RealCall</span><span class="params">(OkHttpClient client, Request originalRequest)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.client = client;</div><div class="line">    <span class="keyword">this</span>.originalRequest = originalRequest;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</div><div class="line">    enqueue(responseCallback, <span class="keyword">false</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</div><div class="line">      executed = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback, forWebSocket));</div><div class="line">  &#125;</div><div class="line">  </div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callback responseCallback;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> forWebSocket;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AsyncCall</span><span class="params">(Callback responseCallback, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>(<span class="string">"OkHttp %s"</span>, redactedUrl().toString());</div><div class="line">      <span class="keyword">this</span>.responseCallback = responseCallback;</div><div class="line">      <span class="keyword">this</span>.forWebSocket = forWebSocket;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        Response response = getResponseWithInterceptorChain(forWebSocket);</div><div class="line">        <span class="keyword">if</span> (canceled) &#123;</div><div class="line">          signalledCallback = <span class="keyword">true</span>;</div><div class="line">          responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          signalledCallback = <span class="keyword">true</span>;</div><div class="line">          responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        <span class="keyword">if</span> (signalledCallback) &#123;</div><div class="line">          <span class="comment">// Do not signal the callback twice!</span></div><div class="line">          Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">//注意这一句代码</span></div><div class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>调用enqueue封装成AsyncCall交给OKHttpClient的dispatcher线程池执行。</p>
<h2 id="Dispatcher线程池"><a href="#Dispatcher线程池" class="headerlink" title="Dispatcher线程池"></a>Dispatcher线程池</h2><p>OkHttp的dispatcher参数是直接new出来的。先看下enqueue方法，将AsyncCall当做参数传递进来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</div><div class="line">  <span class="comment">/** 最大并发请求数为64 */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequests = <span class="number">64</span>;</div><div class="line">  <span class="comment">/** 每个主机最大请求数为5 */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequestsPerHost = <span class="number">5</span>;</div><div class="line"></div><div class="line">  <span class="comment">/** 线程池 */</span></div><div class="line">  <span class="keyword">private</span> ExecutorService executorService;</div><div class="line"></div><div class="line">  <span class="comment">/** 准备执行的请求 */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line"></div><div class="line">  <span class="comment">/** 正在执行的异步请求，包含已经取消但未执行完的请求 */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line"></div><div class="line">  <span class="comment">/** 正在执行的同步请求，包含已经取消单未执行完的请求 */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">      runningAsyncCalls.add(call);</div><div class="line">      executorService().execute(call);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      readyAsyncCalls.add(call);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</div><div class="line">      executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</div><div class="line">          <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> executorService;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造一个线程池ExecutorService：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">executorService = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">    <span class="number">0</span>, <span class="comment">//corePoolSize 最小并发线程数,如果是0的话，空闲一段时间后所有线程将全部被销毁。</span></div><div class="line">    Integer.MAX_VALUE, <span class="comment">//maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理</span></div><div class="line">    <span class="number">60</span>, <span class="comment">//keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间</span></div><div class="line">    TimeUnit.SECONDS,<span class="comment">//单位秒</span></div><div class="line">    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),<span class="comment">//工作队列,先进先出        Util.threadFactory("OkHttp Dispatcher", false));//单个线程的工厂</span></div></pre></td></tr></table></figure>
<p>构建了一个最大线程数为Integer.MAX_VALUE的线程池，也就是说，是个不设最大上限的线程池（其实有限制64个），有多少任务添加进来就新建多少线程，以保证I/O任务中高阻塞低占用的过程中，不会长时间卡在阻塞上。当工作完成后，线程池会在60s内相继关闭所有线程。</p>
<p>还记得刚才在AsyncCall.execute() finally中的内容吗</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">finally &#123;</div><div class="line">    client.dispatcher().finished(this);</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">  </div><div class="line">  /** Used by &#123;@code AsyncCall#run&#125; to signal completion. */</div><div class="line">  synchronized void finished(AsyncCall call) &#123;</div><div class="line">    if (!runningAsyncCalls.remove(call)) throw new AssertionError(&quot;AsyncCall wasn&apos;t running!&quot;);</div><div class="line">    promoteCalls();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line"></div><div class="line">  //Dispatcher.java</div><div class="line">  private void promoteCalls() &#123;</div><div class="line">  //超过阈值 返回</div><div class="line">    if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.</div><div class="line">    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.</div><div class="line"></div><div class="line">    for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</div><div class="line">      AsyncCall call = i.next();</div><div class="line"></div><div class="line">      if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">        i.remove();</div><div class="line">        runningAsyncCalls.add(call);</div><div class="line">        executorService().execute(call);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>当AsyncCall执行完成后，调用Disptcher的finish()方法，调用promoteCalls()方法，如果超过阈值，继续等待，否则取出缓存区的任务执行，顺序是先进先出。</p>
<p>Dispatcher线程池总结</p>
<ul>
<li>调度线程池Disptcher实现了高并发，低阻塞的实现</li>
<li>采用Deque作为缓存，先进先出的顺序执行</li>
<li>任务在try/finally中调用了finished函数，控制任务队列的执行顺序，而不是采用锁，减少了编码复杂性提高性能</li>
</ul>
<h2 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h2><p>调度基本整明白了，AsyncCall 中的execute具体内容还没有分析，主要就一行代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    ...</div><div class="line">    Response response = getResponseWithInterceptorChain(forWebSocket);</div><div class="line">    ...</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Response <span class="title">getResponseWithInterceptorChain</span><span class="params">(<span class="keyword">boolean</span>     forWebSocket)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">Interceptor.Chain chain = <span class="keyword">new</span>         ApplicationInterceptorChain(<span class="number">0</span>, originalRequest, forWebSocket);</div><div class="line"><span class="keyword">return</span> chain.proceed(originalRequest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从方法名字基本可以猜到是干嘛的，调用<code>chain.proceed(originalRequest);</code>将request传递进来，从拦截器链里拿到返回结果。那么拦截器Interceptor是干嘛的，Chain是干嘛的呢？继续往下看ApplicationInterceptorChain</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationInterceptorChain</span> <span class="keyword">implements</span> <span class="title">Interceptor</span>.<span class="title">Chain</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Request request;</div><div class="line"></div><div class="line">    ApplicationInterceptorChain(<span class="keyword">int</span> index, Request request, <span class="keyword">boolean</span> forWebSocket) &#123;</div><div class="line">      <span class="keyword">this</span>.index = index;</div><div class="line">      <span class="keyword">this</span>.request = request;</div><div class="line">      <span class="keyword">this</span>.forWebSocket = forWebSocket;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Connection <span class="title">connection</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Request <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> request;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">      <span class="comment">// If there's another interceptor in the chain, call that.</span></div><div class="line">      <span class="keyword">if</span> (index &lt; client.interceptors().size()) &#123;</div><div class="line">        Interceptor.Chain chain = <span class="keyword">new</span> ApplicationInterceptorChain(index + <span class="number">1</span>, request, forWebSocket);</div><div class="line">        Interceptor interceptor = client.interceptors().get(index);</div><div class="line">        Response interceptedResponse = interceptor.intercept(chain);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (interceptedResponse == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"application interceptor "</span> + interceptor</div><div class="line">              + <span class="string">" returned null"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> interceptedResponse;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// No more interceptors. Do HTTP.</span></div><div class="line">      <span class="keyword">return</span> getResponse(request, forWebSocket);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>ApplicationInterceptorChain实现了Interceptor.Chain接口，持有Request的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">  <span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Chain</span> </span>&#123;</div><div class="line">    <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">    <span class="function">Connection <span class="title">connection</span><span class="params">()</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>proceed方法中判断index（此时为0）是否小于client.interceptors(List<interceptor> )的大小，如果小于也就是说client.interceptors还有Interceptor，那么就再封装一个ApplicationInterceptorChain，只不过index + 1，然后取出第index个Interceptor将chain传递进去。传递进去干嘛呢？我们看一个用法，以实际项目为例</interceptor></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">HttpLoggingInterceptor interceptor = <span class="keyword">new</span> HttpLoggingInterceptor(<span class="keyword">new</span> RetrofitLogger());</div><div class="line">        interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);</div><div class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</div><div class="line">        .addInterceptor(interceptor)</div><div class="line">        .retryOnConnectionFailure(<span class="keyword">true</span>)</div><div class="line">        .connectTimeout(<span class="number">15</span>, TimeUnit.SECONDS)</div><div class="line">        .addInterceptor(getCommonParameterInterceptor())</div><div class="line">        .addNetworkInterceptor(getTokenInterceptor())</div><div class="line">        .build();</div><div class="line">        </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Interceptor <span class="title">getCommonParameterInterceptor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interceptor() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            Request originalRequest = chain.request();</div><div class="line">            Request request = originalRequest;</div><div class="line">            <span class="keyword">if</span> (!originalRequest.method().equalsIgnoreCase(<span class="string">"POST"</span>)) &#123;</div><div class="line">                HttpUrl modifiedUrl = originalRequest.url().newBuilder()</div><div class="line">                        .addQueryParameter(<span class="string">"version_code"</span>, String.valueOf(AppUtils.getVersionCode()))</div><div class="line">                        .addQueryParameter(<span class="string">"app_key"</span>, <span class="string">"nicepro"</span>)</div><div class="line">                        .addQueryParameter(<span class="string">"app_device"</span>, <span class="string">"Android"</span>)</div><div class="line">                        .addQueryParameter(<span class="string">"app_version"</span>, AppUtils.getVersionName())</div><div class="line">                        .addQueryParameter(<span class="string">"token"</span>, AccountUtils.getToken())</div><div class="line">                        .build();</div><div class="line">                request = originalRequest.newBuilder().url(modifiedUrl).build();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> chain.proceed(request);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Interceptor <span class="title">getTokenInterceptor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Interceptor() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            Request originalRequest = chain.request();</div><div class="line">            Request authorised = originalRequest.newBuilder()</div><div class="line">                    .header(<span class="string">"app-key"</span>, <span class="string">"nicepro"</span>)</div><div class="line">                    .header(<span class="string">"app-device"</span>, <span class="string">"Android"</span>)</div><div class="line">                    .header(<span class="string">"app-version"</span>, AppUtils.getVersionName())</div><div class="line">                    .header(<span class="string">"os"</span>, AppUtils.getOs())</div><div class="line">                    .header(<span class="string">"os-version"</span>, AppUtils.getAndroidVersion() + <span class="string">""</span>)</div><div class="line">                    .header(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>)</div><div class="line">                    .header(<span class="string">"User-Agent"</span>, <span class="string">"Android/retrofit"</span>)</div><div class="line">                    .header(<span class="string">"token"</span>, AccountUtils.getToken())</div><div class="line">                    .build();</div><div class="line">            <span class="keyword">return</span> chain.proceed(authorised);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到每个Interceptor的intercept方法中做了一些操作后，最后都会调用<code>chain.proceed(request)</code>方法，而这个chain就是每次prceed方法中生成的ApplicationInterceptorChain，用index+1的方式递归调用OkHttClient中的Interceptors，进行拦截操作，比如可以用来监控log，修改请求，修改结果，供开发者自定义参数添加等等，然后最终调用的还是最初的index=0的那个chain的proceed方法中的<code>getResponse(request, forWebSocket);</code>。</p>
<p>可以说OkHttp是用chain串联起拦截器，而每个拦截器都有能力返回Response，返回Response即终止整个调用链，这种设计模式称为<a href="https://zh.wikipedia.org/wiki/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">责任链模式</a>。这种模式为OkHttp提供了强大的装配能力，极大的提高了OkHttp的扩展性和可维护性。</p>
<p>在Android系统中最典型的责任链模式就是View的Touch传递机制，一层一层传递直到被消费。</p>
<p>官方的一张图就能很好的解释Interceptor<br><img src="https://raw.githubusercontent.com/wiki/square/okhttp/interceptors@2x.png" alt=""><br>整个流程很清晰。这种设计真是太棒了，值得学习！</p>
<h2 id="连接池复用"><a href="#连接池复用" class="headerlink" title="连接池复用"></a>连接池复用</h2><p>我们知道进行一次tcp网络请求，一般要三次握手连接，四次握手断开连接。一次完整的http请求过程见下图。</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/http.jpg" alt=""></p>
<p>如果请求重复的地址，那么重复的连接和断开连接就成了延长整个时间的的重要因素，特别是在复杂的网络环境下，每次请求传输数据的大小将不再是请求速度的决定性因素。</p>
<p>http有一种<code>keepalive connections</code>的机制，可以在传输后仍然保持连接，当客户端需要再次获取数据时，直接使用刚刚空闲下来的连接而不需要再次握手。</p>
<p>Okhttp支持5个并发KeepAlive，默认链路生命为5分钟(链路空闲后，保持存活的时间)，关于OkHttp连接池复用详细请看这篇文章 <a href="http://www.jianshu.com/p/92a61357164b" target="_blank" rel="external">OkHttp3源码分析[复用连接池]</a>。</p>
<h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><p>对比上一张图的一次完整的Http请求，在复杂的天朝网络环境下，相信大多数开发者都碰到过很奇怪的网络问题，比如运营商动态插入辣鸡html代码嵌入广告，比如运营商缓存请求数据导致用户请求到的数据不是最新的问题，比如某些运营商只支持<code>put\post</code>请求，而不支持<code>delete</code>请求，比如运营商。。。这些问题大部分都跟DNS相关。</p>
<p>为了解决DNS劫持的问题，我们在薄荷app上做了很多优化工作，比如使用HTTP DNS（我们使用的DNSPod）代替系统自带的libc库去查询运营商的DNS服务器，直接拿到IP地址进行IP直连，其中又做了一些缓存和选择最优IP的一些操作。解决掉了很大一部分用户反馈的网络问题。</p>
<p>而在OkHttp中，可以直接配置DNS，默认是系统自带的<code>Dns.SYSTEM</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Try each address for best behavior in mixed IPv4/IPv6 environments.</span></div><div class="line">List&lt;InetAddress&gt; addresses = address.dns().lookup(socketHost);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = addresses.size(); i &lt; size; i++) &#123;</div><div class="line">  InetAddress inetAddress = addresses.get(i);</div><div class="line">  inetSocketAddresses.add(<span class="keyword">new</span> InetSocketAddress(inetAddress, socketPort));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意结果是数组，即一个域名可能会有多个IP，如果一个IP不通，会自动重连下一个IP。</p>
<p>开发者就可以新建一个Dns类复写<code>lookup</code>方法通过HTTP DNS请求IP地址，其中新建一个<code>HttpDNSClient</code>来请求DNS，插入拦截器来配置缓存时间，容错处理等等，然后在构建OkHttpClient时加入<code>dns</code>方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">client = <span class="keyword">new</span> OkHttpClient.Builder().addNetworkInterceptor(getLogger())</div><div class="line">        .dispatcher(getDispatcher())</div><div class="line">        <span class="comment">//配置DNS查询实现</span></div><div class="line">        .dns(HTTP_DNS)</div><div class="line">        .build();</div></pre></td></tr></table></figure>
<p>这样的全局HTTP DNS解析真是足够简单高效，并且完全是无侵入性的，丝毫不影响正常的网络请求。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文基本讲了下OkHttp3的大概流程，Interceptor的基本原理，DNS的可选配置等。涉及到socket和Okio流相关的都没有讲到，有兴趣的读者可以在参考文章自行搜索。总结来说，OkHttp基本可以满足日常开发的需求，并且性能足够强大，配合Retrofit + Rxjava更是效率翻倍。如果你在开发新的项目，强烈建议你扔掉Volley，拥抱Retrofit。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.jianshu.com/p/aad5aacd79bf" target="_blank" rel="external">OkHttp3源码分析[综述]</a></li>
<li><a href="http://www.jianshu.com/p/9803a6efb672" target="_blank" rel="external">OkHttp3应用[HTTP DNS的实现]</a></li>
<li><a href="https://gold.xitu.io/post/581311cabf22ec0068826aff" target="_blank" rel="external">从OKHttp框架看代码设计</a></li>
<li><a href="http://blog.piasy.com/2016/07/11/Understand-OkHttp/" target="_blank" rel="external">拆轮子系列：拆 OkHttp</a></li>
<li><a href="http://blog.csdn.net/liudong8510/article/details/7908093" target="_blank" rel="external">一次完整的Http请求过程</a></li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2016/12/06/OkHttp/">http://w4lle.com/2016/12/06/OkHttp/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;之前的底层网络库基本就是Apache HttpClient和HttpURLConnection。由于HttClient比较难用，官方在And
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit Multipart多文件上传</title>
    <link href="http://w4lle.com/2016/11/28/retrofit-multipart/"/>
    <id>http://w4lle.com/2016/11/28/retrofit-multipart/</id>
    <published>2016-11-28T01:03:43.000Z</published>
    <updated>2017-01-06T01:53:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>新项目的网络库已经由Volley切到了Retrofit，配合<code>Rxjava + Dagger2 + CleanArchitecture</code> ，有效的将项目解耦和，各个层次职责更清晰。依赖注入和注解、动态代理极大的简化了网络请求，开发更高效。</p>
<p>项目中经常会有上传文件的需求，特别是上传图片。上传图片通常有两种方式：</p>
<ul>
<li>bitmap通过Base64转为String，这种方式对于客户端最友好，但是对于服务端要复杂些</li>
<li>multipart/form-data 方式</li>
</ul>
<a id="more"></a>
<h1 id="multipart-form-data-是什么"><a href="#multipart-form-data-是什么" class="headerlink" title="multipart/form-data 是什么"></a>multipart/form-data 是什么</h1><p>http协议将请求分为3个部分：状态行，请求头，请求体。<br>而RESTFul风格请求更multipart又有些不同，具体的：</p>
<ol>
<li><code>multipart/form-data</code>的基础方法是post，也就是说是由post方法来组合实现的。</li>
<li><code>multipart/form-data</code>与post方法的不同之处：请求头，请求体。</li>
<li><code>multipart/form-data</code>的请求头必须包含一个特殊的头信息：Content-Type，且其值也必须规定为multipart/form-data，同时还需要规定一个内容分割符用于分割请求体中的多个post的内容，如文件内容和文本内容自然需要分割开来，不然接收方就无法正常解析和还原这个文件。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Content-Type: multipart/form-data; boundary=$&#123;bound&#125;</div></pre></td></tr></table></figure>
<p>其中${bound}是定义的分隔符，用于分割各项内容(文件,key-value对)。post格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">--$&#123;bound&#125;</div><div class="line">Content-Disposition: form-data; name=<span class="string">"Filename"</span></div><div class="line"> </div><div class="line">HTTP.pdf</div><div class="line">--$&#123;bound&#125;</div><div class="line">Content-Disposition: form-data; name=<span class="string">"file000"</span>; filename=<span class="string">"HTTP协议详解.pdf"</span></div><div class="line">Content-Type: application/octet-stream</div><div class="line"> </div><div class="line">%PDF-<span class="number">1.5</span></div><div class="line">file content</div><div class="line">%%EOF</div><div class="line"> </div><div class="line">--$&#123;bound&#125;</div><div class="line">Content-Disposition: form-data; name=<span class="string">"Upload"</span></div><div class="line"> </div><div class="line">Submit Query</div><div class="line">--$&#123;bound&#125;--</div></pre></td></tr></table></figure>
<p>${bound}是Content-Type里boundary的值</p>
<h1 id="Volley-multipart"><a href="#Volley-multipart" class="headerlink" title="Volley multipart"></a>Volley multipart</h1><p>在之前的项目中使用Volley，由于Volley的高度可扩展性实现起来比较方便，封装一个<a href="https://gist.github.com/w4lle/aecfecc5285c6d8e85eeff80685cadbb" target="_blank" rel="external">MultipartRequest</a>即可。主要的这行代码更改Content-Type的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBodyContentType</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"multipart/form-data;charset=utf-8;boundary="</span> + boundary ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Retrofit-multipart"><a href="#Retrofit-multipart" class="headerlink" title="Retrofit multipart"></a>Retrofit multipart</h1><p>由于Retrofit是一个网络库的封装，具体的网络请求默认是使用OkHttp，Retrofit对于multipart的支持最终也会转换成OkHttp的实现。</p>
<p>在Retrofit中实现一个multipart上传：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Multipart</span></div><div class="line"><span class="meta">@POST</span>(<span class="string">"upload"</span>)</div><div class="line"><span class="function">Call&lt;ResponseBody&gt; <span class="title">uploadFile</span><span class="params">(</span></span></div><div class="line">    @Part(<span class="string">"description"</span>) RequestBody description,</div><div class="line">    @Part MultipartBody.Part file);</div></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>@retrofit2.http.Multipart</code>注解: 标记一个请求是multipart/form-data类型,需要和@retrofit2.http.POST一同使用，参数可以是<code>MultipartBody.Part</code>或<code>RequestBody</code>。</li>
<li><code>@retrofit2.http.Part</code>注解: 代表Multipart里的一项数据,即用${bound}分隔的内容块。</li>
</ul>
<p>可以很方便的上传一个文件和一个参数。但是这样就有一个问题，如果我有一个实体类想要一起上传怎么办，总不能再uploadFile方法里定义很多<code>@Part(&quot;description&quot;) RequestBody description</code>这种参数吧，如果我有多张图片要一起上传呢？</p>
<h1 id="文件和参数一起提交"><a href="#文件和参数一起提交" class="headerlink" title="文件和参数一起提交"></a>文件和参数一起提交</h1><p>可以使用@PartMap()注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    <span class="meta">@Multipart</span></div><div class="line">    <span class="meta">@POST</span>(<span class="string">"upload"</span>)</div><div class="line">    <span class="function">Call&lt;ResponseBody&gt; <span class="title">uploadFileWithPartMap</span><span class="params">(</span></span></div><div class="line">            @PartMap() Map&lt;String, RequestBody&gt; partMap,</div><div class="line">            @Part MultipartBody.Part file);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>@PartMap注解代表参数的一个集合。这样使用起来就很方便，对于多个参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, String&gt; partMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    MultiPartUtil.putRequestBodyMap(partMap, <span class="string">"service_code"</span>, certiValue[checkedItem]);</div><div class="line">    MultiPartUtil.putRequestBodyMap(partMap, <span class="string">"good_at"</span>, goodAt);</div><div class="line">    MultiPartUtil.putRequestBodyMap(partMap, <span class="string">"introduction"</span>, des);</div><div class="line">    MultiPartUtil.putRequestBodyMap(partMap, <span class="string">"integrity"</span>, <span class="string">"certificate"</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MULTIPART_FORM_DATA = <span class="string">"multipart/form-data"</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putRequestBodyMap</span><span class="params">(Map map, String key, String value)</span> </span>&#123;</div><div class="line">        putRequestBodyMap(map, key, createPartFromString(value));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@NonNull</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestBody <span class="title">createPartFromString</span><span class="params">(String descriptionString)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (descriptionString == <span class="keyword">null</span>) &#123;</div><div class="line">            descriptionString = <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> RequestBody.create(</div><div class="line">                MediaType.parse(MULTIPART_FORM_DATA), descriptionString);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putRequestBodyMap</span><span class="params">(Map map, String key, RequestBody body)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(key) &amp;&amp; body != <span class="keyword">null</span>) &#123;</div><div class="line">            map.put(key, body);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>构造了<code>Content-Type</code>为<code>multipart/form-data</code>的RequestBody（正常情况下应该为 <code>application/json; charset=utf-8</code>）,同样的构造File part</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> MultipartBody.<span class="function">Part <span class="title">prepareFilePart</span><span class="params">(String partName, String fileUri)</span> </span>&#123;</div><div class="line"><span class="comment">//压缩</span></div><div class="line">    File file = ViewUtils.compressImageToFile(fileUri, <span class="keyword">new</span> File(FileUtils.getImageCache(BaseApplication.getContext()), partName + <span class="string">".png"</span>));</div><div class="line">    <span class="keyword">if</span> (file != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 为file建立RequestBody实例</span></div><div class="line">        RequestBody requestFile =</div><div class="line">        RequestBody.create(MediaType.parse(MULTIPART_FORM_DATA), file);</div><div class="line">        <span class="comment">// MultipartBody.Part借助文件名完成最终的上传</span></div><div class="line">        <span class="keyword">return</span> MultipartBody.Part.createFormData(partName, file.getName(), requestFile);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就基本符合需求，那么如果有多张图片呢？总不能一个参数一个参数写吧。<br>其实也很简单，由于<code>@Part MultipartBody.Part file</code>类型一致，那么我们就可以使用可变参数列表。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">    <span class="meta">@Multipart</span></div><div class="line">    <span class="meta">@POST</span>(<span class="string">"upload"</span>)</div><div class="line">    <span class="function">Observable&lt;JsonObject&gt; <span class="title">authCertification</span><span class="params">(@PartMap Map&lt;String, RequestBody&gt; partMap, @Part MultipartBody.Part... files)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">api.authCertification(partMap, avatarPart,</div><div class="line">                idFrontPart, idBackPart, authOnePart, authTwoPart, authThreePart)</div></pre></td></tr></table></figure>
<p>可以传任意多个文件。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://futurestud.io/tutorials/retrofit-2-passing-multiple-parts-along-a-file-with-partmap" target="_blank" rel="external">Retrofit 2 — Passing Multiple Parts Along a File with @PartMap</a></li>
<li><a href="http://www.chenkaihua.com/2016/04/02/retrofit2-upload-multipart-files/" target="_blank" rel="external">Retrofit2 multpart多文件上传详解</a></li>
<li><a href="https://my.oschina.net/cnlw/blog/168466" target="_blank" rel="external">HTTP协议之multipart/form-data请求分析</a></li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2016/11/28/retrofit-multipart/">http://w4lle.com/2016/11/28/retrofit-multipart/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;新项目的网络库已经由Volley切到了Retrofit，配合&lt;code&gt;Rxjava + Dagger2 + CleanArchitecture&lt;/code&gt; ，有效的将项目解耦和，各个层次职责更清晰。依赖注入和注解、动态代理极大的简化了网络请求，开发更高效。&lt;/p&gt;
&lt;p&gt;项目中经常会有上传文件的需求，特别是上传图片。上传图片通常有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bitmap通过Base64转为String，这种方式对于客户端最友好，但是对于服务端要复杂些&lt;/li&gt;
&lt;li&gt;multipart/form-data 方式&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Material主题</title>
    <link href="http://w4lle.com/2016/11/17/hexo-theme-material/"/>
    <id>http://w4lle.com/2016/11/17/hexo-theme-material/</id>
    <published>2016-11-17T02:41:20.000Z</published>
    <updated>2016-11-28T14:24:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h1><p>最近把博客主题换成了<a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="external">Material</a>，该主题刚刚上线，效果还不错。</p>
<p>需要把以前的配置迁移一下，包括留言之类的。</p>
<h1 id="多说评论"><a href="#多说评论" class="headerlink" title="多说评论"></a>多说评论</h1><p>由于之前用的NexT主题，多说后台每篇文章的thread-key是根据NexT主题来的，现在Material主题的多说配置文件如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div id="comments"&gt;</div><div class="line">    &lt;!-- 多说评论框 start --&gt;</div><div class="line">        &lt;div class="ds-thread" data-thread-key="&lt;% if(theme.comment.duoshuo_thread_key == "id")&#123; %&gt;&lt;%= page.id %&gt;&lt;% &#125; else &#123; %&gt;&lt;%= page.path %&gt;&lt;% &#125; %&gt;" data-url="&lt;%= config.url+ config.root + url_for(path) %&gt;"&gt;&lt;/div&gt;</div><div class="line">    &lt;!-- 多说评论框 end --&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>duoshuo_thread_key配成了page.title，就导致我们找不到多说后台的数据。</p>
<p>所以要找到NexT主题相关多说的配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd themes/next/layout</div><div class="line">grep -ri <span class="string">"thread-key"</span> .<span class="comment">/*</span></div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./_macro/post.swig:                  &lt;span class="post-comments-count ds-thread-count" data-thread-key="&#123;&#123; post.path &#125;&#125;" itemprop="commentsCount"&gt;&lt;/span&gt;</div><div class="line">./_partials/comments.swig:      &lt;div class="ds-thread" data-thread-key="&#123;&#123; page.path &#125;&#125;"</div><div class="line">./_partials/share/duoshuo_share.swig:&lt;div class="ds-share flat" data-thread-key="&#123;&#123; page.path &#125;&#125;"</div></pre></td></tr></table></figure>
<p>可以看到NexT配置的是page.path。那么我们找到Material主题的thread-key替换下就好了。主要就是两个地方:</p>
<ul>
<li>./layout/_widget/duoshuo.ejs 文章评论内容</li>
<li>./layout/_partial/Paradox-post_entry.ejs 首页显示评论数</li>
</ul>
<p>都修改下就能正常显示以前的评论了。</p>
<h1 id="每日一图"><a href="#每日一图" class="headerlink" title="每日一图"></a>每日一图</h1><p>Material主题首页有个每日图片，默认是写死的。我们可以改为动态的，使用了bing的每日图片，是一位开发者抓取的然后提供的一个api，地址：<a href="https://i-meto.com/bing-api/" target="_blank" rel="external">必应美图 API</a></p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./_partial/daily_pic.ejs</div><div class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"mdl-card__media mdl-color-text--grey-50"</span> style=<span class="string">"background-image:url(https://api.i-meto.com/bing)"</span>&gt;</div></pre></td></tr></table></figure>
<h1 id="backgroud"><a href="#backgroud" class="headerlink" title="backgroud"></a>backgroud</h1><p>同上背景图也可以设置成bing的图片。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">config_css.ejs</div><div class="line">&lt;% if(theme.background.bing.enable == true)&#123; %&gt;</div><div class="line">	&lt;style&gt;</div><div class="line">		body&#123;</div><div class="line">            background-image: url(https://api.i-meto.com/bing?&lt;%= theme.background.bing.parameter %&gt;);</div><div class="line">        &#125;</div><div class="line">	&lt;/style&gt;</div></pre></td></tr></table></figure>
<p>config配置文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># Background Settings</div><div class="line"># bing available parameter:</div><div class="line">#     new | color= | type=</div><div class="line">#         color available value: black, blue, brown, green, multi, orange, pink, purple, red, white, yellow</div><div class="line">#         type available value: A (animal), C (culture), N (nature), S (space), T (travel)</div><div class="line">background:</div><div class="line">    purecolor: "#F5F5F5"</div><div class="line">    bgimg: blur</div><div class="line">    bing:</div><div class="line">        parameter: color=white</div><div class="line">        enable: true</div></pre></td></tr></table></figure>
<h1 id="不算子统计"><a href="#不算子统计" class="headerlink" title="不算子统计"></a>不算子统计</h1><p>站点统计<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">footer.ejs</div><div class="line">		&lt;div&gt;</div><div class="line">		&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;</div><div class="line">		&lt;div&gt;</div><div class="line">		本站总访问量 &lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt; &amp;nbsp&amp;nbsp&amp;nbsp</div><div class="line">		你是第&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;个来到的小伙伴</div><div class="line">		&lt;/div&gt;</div><div class="line">		&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h1 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h1><p>有两种方式设置：</p>
<ol>
<li>写死固定大小</li>
<li>more标签<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">以上是摘要</div><div class="line">&lt;!--more--&gt;</div><div class="line">以下是余下全文</div></pre></td></tr></table></figure>
</li>
</ol>
<p>推荐第二种</p>
<p>本文链接： <a href="http://w4lle.com/2016/11/17/hexo-theme-material/">http://w4lle.com/2016/11/17/hexo-theme-material/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Material&quot;&gt;&lt;a href=&quot;#Material&quot; class=&quot;headerlink&quot; title=&quot;Material&quot;&gt;&lt;/a&gt;Material&lt;/h1&gt;&lt;p&gt;最近把博客主题换成了&lt;a href=&quot;https://github.com/viosey/h
    
    </summary>
    
    
      <category term="Hexo" scheme="http://w4lle.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>AsyncTask解析</title>
    <link href="http://w4lle.com/2016/07/29/AsyncTask/"/>
    <id>http://w4lle.com/2016/07/29/AsyncTask/</id>
    <published>2016-07-29T07:44:19.000Z</published>
    <updated>2016-07-31T11:12:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AsyncTask用法"><a href="#AsyncTask用法" class="headerlink" title="AsyncTask用法"></a>AsyncTask用法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SaveImageTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Bitmap</span>, <span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</div><div class="line">        Helper.showToast(<span class="string">"正在分享，请稍等..."</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(Bitmap... params)</span> </span>&#123;</div><div class="line">        <span class="comment">//耗时操作</span></div><div class="line">        <span class="keyword">return</span> String; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onPostExecute(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用</span></div><div class="line"><span class="keyword">new</span> SaveImageTask().execute(loadedImage);</div></pre></td></tr></table></figure>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>AsyncTask类总共600行左右，大概看下内部实现。初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span>&lt;<span class="title">Params</span>, <span class="title">Result</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Result</span>&gt; </span>&#123;</div><div class="line">    Params[] mParams;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">            <span class="comment">//noinspection unchecked</span></div><div class="line">            Result result = doInBackground(mParams);</div><div class="line">            Binder.flushPendingCommands();</div><div class="line">            <span class="keyword">return</span> postResult(result);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                postResultIfNotInvoked(get());</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                android.util.Log.w(LOG_TAG, e);</div><div class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</div><div class="line">                        e.getCause());</div><div class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化了两个变量，一个Callable mWorker，一个FutureTask mFuture，FutureTask实现了Runnable和Future。将mWorker作为参数传递给了mFuture的构造方法，关于FutureTask和Callable，简单的来说就是Future里面封装了Callable，执行Future实际上执行的是Callable的call方法，Future的get()可以从Callable拿到执行的结果。Callable的Call()会去执行抽象方法doInBackground(mParams);并把传进来的mParams带过去，doInBackground需要我们自己实现，去做一些耗时的操作。然后拿到结果执行postResult(result)方法，这个待会再说。继续往下看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">FutureTask的run方法</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//构造方法里的Callable参数</span></div><div class="line">            Callable&lt;V&gt; c = callable;</div><div class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</div><div class="line">                V result;</div><div class="line">                <span class="keyword">boolean</span> ran;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    result = c.call();</div><div class="line">                    ran = <span class="keyword">true</span>;</div><div class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">                    result = <span class="keyword">null</span>;</div><div class="line">                    ran = <span class="keyword">false</span>;</div><div class="line">                    setException(ex);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (ran)</div><div class="line">                    set(result);<span class="comment">//可以通过get()拿到结果</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>执行AsyncTask的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></div><div class="line">        Params... params) &#123;</div><div class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</div><div class="line">        <span class="keyword">switch</span> (mStatus) &#123;</div><div class="line">            <span class="keyword">case</span> RUNNING:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task is already running."</span>);</div><div class="line">            <span class="keyword">case</span> FINISHED:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task has already been executed "</span></div><div class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mStatus = Status.RUNNING;</div><div class="line"></div><div class="line">    onPreExecute();</div><div class="line"></div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个任务在完成前只能执行一次，然后执行onPreExecute();的抽象方法，在使用的AsyncTask中实现做一些准备操作，然后将传进来的params参数付给mWorker的mParams，还记得mWorker吗，是一个Callable。exec.execute(mFuture);实际上被调用的是mWorker的call()。这里有个默认的Executor sDefaultExecutor，看下实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</div><div class="line">    Runnable mActive;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</div><div class="line">        mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    r.run();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    scheduleNext();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</div><div class="line">            scheduleNext();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>mTasks是一个先进先出的队列存储Runnable对象，offer方法加到队尾，poll()从队头取。第一次mActive肯定是null，所以走到scheduleNext取出一个用THREAD_POOL_EXECUTOR去执行。下一次再调用execute()，这是mActive不为空，所以就不会执行scheduleNext()，但是由于有try finally的存在，所以下一次scheduleNext();是在本次run方法执行完，也就是说要等待本次耗时操作执行完才可以进行下一次耗时操作。也对应了SerialExecutor这个名字，串行执行。实际的Executor是THREAD_POOL_EXECUTOR，看下实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = CPU_COUNT + <span class="number">1</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncTask #"</span> + mCount.getAndIncrement());</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =</div><div class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">128</span>);</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR</div><div class="line">        = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</div><div class="line">                TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div></pre></td></tr></table></figure>
<p>定义了一个线程池，同时运行线程数CPU数+1，线程池总大小CPU数 * 2 + 1，在之前的版本这两个数字分别是5和128。虽然定义了可以同时运行那么多线程，但是由于SerialExecutor的存在，它会强制串行并发，所以实际上只有一个线程在跑，所以也就不存在任务数超过线程池总大小会蹦的问题了。SerialExecutor是AsyncTask提供给开发者的一种默认实现，我们也可以通过<code>public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,Params... params)</code>方法传进去一个自己定义的线程池，这样就可以并行并发了。</p>
<p>刚才说到最终的执行时在mWorker的call()去执行具体的耗时操作，执行完了调用postResult()方法，看下实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就很明了了，通过Handler把result结果发出去。看下Handler的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(Looper.getMainLooper());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</div><div class="line">                <span class="comment">// There is only one result</span></div><div class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>InternalHandler是一个主线程上的Handler，也就是发消息到主线程，刚才发过来的Result就被发送的主线程了，最后调用AsyncTask的finish方法，看下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">        onCancelled(result);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        onPostExecute(result);</div><div class="line">    &#125;</div><div class="line">    mStatus = Status.FINISHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果取消了执行onCancelled(result)回调，否则执行onPostExecute(result)。并把状态置为FINISHED。整个流程也就走完了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文分析了AsyncTask的原理，一句话概括，AsyncTask封装了线程池和Handler，线程池跑耗时任务、Handler向主线程发消息。如果不是很多任务的话就用HandlerThread来做就行了；任务多并且不是那么耗时的可以考虑用用AsyncTask，不过还是建议自己写线程池。</p>
<p>本文链接： <a href="http://w4lle.com/2016/07/29/AsyncTask/">http://w4lle.com/2016/07/29/AsyncTask/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AsyncTask用法&quot;&gt;&lt;a href=&quot;#AsyncTask用法&quot; class=&quot;headerlink&quot; title=&quot;AsyncTask用法&quot;&gt;&lt;/a&gt;AsyncTask用法&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android进程保活之绑定系统服务</title>
    <link href="http://w4lle.com/2016/07/24/Android%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%E4%B9%8B%E7%BB%91%E5%AE%9A%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"/>
    <id>http://w4lle.com/2016/07/24/Android进程保活之绑定系统服务/</id>
    <published>2016-07-24T12:25:32.000Z</published>
    <updated>2017-01-06T01:51:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程保活"><a href="#进程保活" class="headerlink" title="进程保活"></a>进程保活</h1><p>有些业务需要service在后台持续的运行，所以就要有后台保活机制，包括lowMemory防杀和自启。</p>
<h2 id="防杀机制"><a href="#防杀机制" class="headerlink" title="防杀机制"></a>防杀机制</h2><p>基本就是提高进程优先级，保证在低内存时进程不被有限杀死，常用的方法就是利用系统bug提高进程优先级，灰色保活手段。</p>
<h2 id="后台自启"><a href="#后台自启" class="headerlink" title="后台自启"></a>后台自启</h2><p>大概包括</p>
<ul>
<li>Receiver拉起</li>
<li>AlarmManager拉起</li>
<li>双进程互相守护</li>
<li>利用推送SDK拉起进程</li>
</ul>
<p>以上说的这几种是常用的方法，对于原生和没有深度定制的ROM有一定作用，但是对于像小米、魅族等这类深度定制的系统来说效果不是很好。</p>
<h2 id="绑定系统服务"><a href="#绑定系统服务" class="headerlink" title="绑定系统服务"></a>绑定系统服务</h2><p>系统提供一些系统级的Service，比如AccessibilityService辅助服务、NotificationListenerService用于监听通知消息。这篇文章主要讲下怎样利用NotificationListenerService用于监听通知消息实现进程保活。</p>
<p>首先，如果想使用系统service，必须要用户手动点开权限。我们可以添加一个设置的入口直接跳到系统设置通知权限的界面，显示提示用户需要开启权限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goNLPermission</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.settings.ACTION_NOTIFICATION_LISTENER_SETTINGS"</span>);</div><div class="line">        context.startActivity(intent);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>界面就不截图了，然后我们app中要有一个权限的状态检查用于提示用户是否开启了通知显示权。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 检查通知使用权</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkNotificationPermission</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    String pkg = context.getPackageName();</div><div class="line">    String flat = Settings.Secure.getString(context.getContentResolver(), <span class="string">"enabled_notification_listeners"</span>);</div><div class="line">    <span class="keyword">boolean</span> enabled = flat != <span class="keyword">null</span> &amp;&amp; flat.contains(pkg);</div><div class="line">    <span class="keyword">return</span> enabled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注册，声明运行在com.package.pedometer进程中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;service</div><div class="line">    android:name=".service.MyListenerService"</div><div class="line">    android:permission="android.permission.BIND_NOTIFICATION_LISTENER_SERVICE"</div><div class="line">    android:process=":pedometer"&gt;</div><div class="line">    &lt;intent-filter&gt;</div><div class="line">        &lt;action android:name="android.service.notification.NotificationListenerService"/&gt;</div><div class="line">    &lt;/intent-filter&gt;</div><div class="line">&lt;/service&gt;</div></pre></td></tr></table></figure>
<p>然后需要继承NotificationListenerService实现两个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 监听系统通知，需要用户手动开启权限，那么该进程可以不死</div><div class="line"> */</div><div class="line"><span class="meta">@TargetApi</span>(Build.VERSION_CODES.JELLY_BEAN_MR2)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListenerService</span> <span class="keyword">extends</span> <span class="title">NotificationListenerService</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNotificationPosted</span><span class="params">(StatusBarNotification sbn)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNotificationRemoved</span><span class="params">(StatusBarNotification sbn)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法中什么都不用实现，MyListenerService所在的进程就拥有了跟NotificationListenerService一样的权限。可以试下手动强制停止进程会发现怎么都结束不掉，强制停止的按钮一直可以点击。可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell ps | grep ***</div></pre></td></tr></table></figure></p>
<p>命令查看进程是否存活。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat /proc/<span class="number">12869</span>/oom_adj</div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>
<p>查看进程的oom_adj的值为0，那么我们知道在灰色保活手段上基本就是提高oom_adj的值，越小越不容易被杀死，这种方法一步到位。</p>
<p>那么怎么应用到我们自己的service中呢？很简单，将service跟MyListenerService运行在同一个进程就可以了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;service</div><div class="line">    android:name=".service.StepCounterService"</div><div class="line">    android:exported="true"</div><div class="line">    android:process=":pedometer"&gt;</div><div class="line">&lt;/service&gt;</div></pre></td></tr></table></figure>
<p>这样基本就可以保证service所在的进程不被杀死了。当然，如果ROM厂商在系统级别拦截掉了，这种方法也会无效了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果要用这种方法进程保活，那么你的app肯定是有显示通知栏的通知，不然用户谁这么傻去给你开这么权限呢。其次，显示通知栏消息就是前台进程了，用户始终可以看到，再配合service自启的几种方法，基本就可以保证我们的进程不死了。当然，这种方法也不能说绝对管用，在深度定制面前，一切都是渣渣。验证下来，魅族基本都好用，小米4c不太好用，小米其他机型没有测试。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://blog.csdn.net/aigestudio/article/details/51348408" target="_blank" rel="external">论Android应用进程长存的可行性</a><br><a href="http://www.jianshu.com/p/63aafe3c12af#" target="_blank" rel="external">关于 Android 进程保活，你所需要知道的一切</a></p>
<p>本文链接： <a href="http://w4lle.com/2016/07/24/Android进程保活之绑定系统服务/">http://w4lle.com/2016/07/24/Android进程保活之绑定系统服务/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程保活&quot;&gt;&lt;a href=&quot;#进程保活&quot; class=&quot;headerlink&quot; title=&quot;进程保活&quot;&gt;&lt;/a&gt;进程保活&lt;/h1&gt;&lt;p&gt;有些业务需要service在后台持续的运行，所以就要有后台保活机制，包括lowMemory防杀和自启。&lt;/p&gt;
&lt;h2 id
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://w4lle.com/2016/07/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://w4lle.com/2016/07/03/快速排序/</id>
    <published>2016-07-03T12:55:44.000Z</published>
    <updated>2017-01-06T01:56:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Wikipedia: 快速排序是由东尼霍尔所发展的一种排序算法。在平均状况下，排序n个项目要Ο(n log n)次比较。 在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log )算法更快， 因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
</blockquote>
<h1 id="快排的思路"><a href="#快排的思路" class="headerlink" title="快排的思路"></a>快排的思路</h1><p>快速排序采用了分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。<br>该方法的基本思想是：</p>
<ol>
<li>选取一个基准元素（pivot）</li>
<li>分区过程，比pivot小的放到pivot左边，比pivot大的放到pivot右边</li>
<li>对pivot左边的序列和右边的序列分别递归的执行步骤1和步骤2</li>
</ol>
<p>虽然是采用分治法，但是分治法不能完全概括这个算法，因为我每次看完算法会很清楚，但是过段时间就忘了。然后看到了非常新颖的名字：“挖坑排序”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//快速排序</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (l &lt; r)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> i = l, j = r;</div><div class="line">        <span class="comment">//将数组中的最低位值取出，相当于挖了第一个坑</span></div><div class="line">        <span class="keyword">int</span> x = s[l];</div><div class="line">        <span class="keyword">while</span> (i &lt; j)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; s[j] &gt;= x) &#123;</div><div class="line">            <span class="comment">//从右向左找第一个小于x的数</span></div><div class="line">				j--;  </div><div class="line">			&#125;</div><div class="line">            <span class="keyword">if</span>(i &lt; j) &#123;</div><div class="line">            <span class="comment">//将s[j]的数挖坑填之前的坑</span></div><div class="line">				s[i++] = s[j];</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; s[i] &lt; x) &#123;</div><div class="line">            <span class="comment">// 从左向右找第一个大于等于x的数</span></div><div class="line">				i++;  </div><div class="line">			&#125;</div><div class="line">            <span class="keyword">if</span>(i &lt; j) &#123;</div><div class="line">            <span class="comment">//挖坑，填之前的坑</span></div><div class="line">				s[j--] = s[i];</div><div class="line">			&#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//填最后一个坑</span></div><div class="line">        s[i] = x;</div><div class="line">        quickSort(s, l, i - <span class="number">1</span>); <span class="comment">// 递归调用 </span></div><div class="line">        quickSort(s, i + <span class="number">1</span>, r);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对挖坑填数进行总结</p>
<ol>
<li>i =L; j = R; 将基准数挖出形成第一个坑a[i]。</li>
<li>j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</li>
<li>i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</li>
<li>再重复执行2，3二步，直到i==j，将基准数填入a[i]中。</li>
</ol>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>平均情况下快速排序的时间复杂度是O(n\lgn)O(n\lgn)，最坏情况是O(n2)O(n2)。</p>
<h2 id="最坏时间复杂度"><a href="#最坏时间复杂度" class="headerlink" title="最坏时间复杂度"></a>最坏时间复杂度</h2><p>当划分产生的两个子问题分别包含 n-1 和 0个元素时，最坏情况发生。因此，快速排序必须做n-1次划分，第i次划分开始时区间长度为n-i+1，所需的比较次数为n-i(1≤i≤n-1)，故总的比较次数达到最大值：<br><code>Cmax = n(n-1)/2=O(n^2)</code></p>
<h2 id="最好时间复杂度"><a href="#最好时间复杂度" class="headerlink" title="最好时间复杂度"></a>最好时间复杂度</h2><p>当划分产生的两个子问题分别包含⌊n/2⌋⌊n/2⌋和⌈n/2⌉−1⌈n/2⌉−1个元素时，最好情况发生。用递归树来分析最好情况下的比较次数更简单。因为每次划分后左、右子区间长度大致相等，故递归树的高度为O(lgn)，而递归树每一层上各结点所对应的划分过程中所需要的关键字比较次数总和不超过n，故整个排序过程所需要的关键字比较总次数C(n)=O(nlgn)。</p>
<p>因为快速排序的记录移动次数不大于比较的次数，所以快速排序的最坏时间复杂度应为0(n2)，最好时间复杂度为O(nlgn)。事实上只要划分是常数比例的，算法的运行时间总是O(nlgn)。 假设按照 9:1 划分，每层代价最多为 cn，递归深度为 log(10/9, n)=O(lgn)，故排序的总代价为O(nlgn)。平均情况下，比如一次坏的划分接着一次好的划分，坏的划分那一项可以合并到好的划分里，统计上来讲平均情况下的时间复杂度仍然是O(nlgn)。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>在当前无序区中选取划分的基准关键字是决定算法性能的关键。</p>
<ol>
<li>“三者取中”规则，即在当前区间里，将该区间首、尾和中间位置上的关键字比较，取三者之中值所对应的记录作为基准</li>
<li>取位于low和high之间的随机数k(low≤k≤high)，用R[k]作为基准， 随机化的快速排序与一般的快速排序算法差别很小。但随机化后，算法的性能大大地提高了，尤其是对初始有序的文件，一般不可能导致最坏情况的发生。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://blog.csdn.net/morewindows/article/details/6684558" target="_blank" rel="external">白话经典算法系列之六 快速排序 快速搞定</a><br><a href="http://harttle.com/2015/09/27/quick-sort.html" target="_blank" rel="external">快速排序的时间和空间复杂度</a><br><a href="http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.3.2.4.htm" target="_blank" rel="external">快速排序算法分析</a></p>
<p>本文链接： <a href="http://w4lle.com/2016/07/03/快速排序/">http://w4lle.com/2016/07/03/快速排序/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Wikipedia: 快速排序是由东尼霍尔所发展的一种排序算法。在平均状况下，排序n个项目要Ο(n log n)次比较。 在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log )算法更快， 因为它的内
    
    </summary>
    
    
      <category term="其他" scheme="http://w4lle.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Android计步</title>
    <link href="http://w4lle.com/2016/06/26/step-counter/"/>
    <id>http://w4lle.com/2016/06/26/step-counter/</id>
    <published>2016-06-26T02:35:39.000Z</published>
    <updated>2016-06-26T12:17:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计步越来越成为人们的强需求，一般有手环计步，手表计步，手机计步等实现，这篇文章讨论下手机上实现计步的两种方案。</p>
<h1 id="加速度传感器（gsensor）"><a href="#加速度传感器（gsensor）" class="headerlink" title="加速度传感器（gsensor）"></a>加速度传感器（gsensor）</h1><p>人在走路时，加速度传感器会形成一个类似正弦波形图，因此可以根据检测波峰波谷记步。见下图：</p>
<p><img src="http://www.analog.com/library/analogDialogue/archives/44-06/AD44_06_FIG_03.jpg" alt=""></p>
<p>可以分为几步进行：</p>
<ol>
<li>特征选取，由于手机在不同放置条件下三轴传感器会有不同的数据表现，所以 可以取三轴的平方和。</li>
<li>滤波，由于得到的数据存在一定的噪音，我们需要过滤掉这些噪音得到比 较平滑的数据，一般有中值滤波和低通滤波。</li>
<li>计步监测，我们一般采用判断峰谷值来决定是否是一次计步。</li>
<li>动态阈值，采用判断峰谷值来记步需要动态的计算阈值，符合阈值标准才能算一次计步。</li>
<li>步数矫正，人的步伐速度在200-2000ms之间，通过记录记步的时间戳，矫正步数。步伐间隔<200ms和>2000ms，认为是无效步数。</200ms和></li>
</ol>
<p>使用gsensor来计步可能会存在以下问题：</p>
<ul>
<li>续航问题，由于要不停的监测gsensor变化和计算，就会导致手机不会进入休眠状态，一直保持CPU的唤醒，这对于手机的续航可能会带来一定的影响。</li>
<li>精度问题，计步算法需要不断的产品迭代，并且要有较好的步数矫正机制，短时间内不能做到优秀的计步功能。</li>
<li>后台service保活问题，要保证后台可以实时统计步数需要后台服务一直运行，包括低内存防杀机制、自启机制等。</li>
<li>对于一些锁屏自动关闭sensor的定制系统来说不可用。</li>
</ul>
<h1 id="计步传感器（step-sensor）"><a href="#计步传感器（step-sensor）" class="headerlink" title="计步传感器（step-sensor）"></a>计步传感器（step-sensor）</h1><p>相对于使用加速度传感器获取数据和计算实现计步的方式，通过计步传感器sensor监测或者读取计步数对于终端的续航能力有了很大的提高。</p>
<p>在Android4.4（KITKAT）系统API提供了两种硬件计步传感器的支持，因为是硬件所以需要厂商支持。可以通过以下方式查看你的手机是否支持</p>
<ul>
<li><p>adb shell pm list features<br>如果有以下两项说明支持</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">feature:android.hardware.sensor.stepcounter</div><div class="line">feature:android.hardware.sensor.stepdetector</div></pre></td></tr></table></figure>
</li>
<li><p>代码检测Android4.4后更高并且有sensor支持</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isKitkatWithStepSensor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// BEGIN_INCLUDE(iskitkatsensor)</span></div><div class="line">    <span class="comment">// Require at least Android KitKat</span></div><div class="line">    <span class="keyword">int</span> currentApiVersion = android.os.Build.VERSION.SDK_INT;</div><div class="line">    <span class="comment">// Check that the device supports the step counter and detector sensors</span></div><div class="line">    PackageManager packageManager = getActivity().getPackageManager();</div><div class="line">    <span class="keyword">return</span> currentApiVersion &gt;= android.os.Build.VERSION_CODES.KITKAT</div><div class="line">            &amp;&amp; packageManager.hasSystemFeature(PackageManager.FEATURE_SENSOR_STEP_COUNTER)</div><div class="line">            &amp;&amp; packageManager.hasSystemFeature(PackageManager.FEATURE_SENSOR_STEP_DETECTOR);</div><div class="line">    <span class="comment">// END_INCLUDE(iskitkatsensor)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在使用前需要声明权限</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;uses-feature android:name=<span class="string">"android.hardware.sensor.stepcounter"</span> /&gt;</div><div class="line">&lt;uses-feature android:name=<span class="string">"android.hardware.sensor.stepdetector"</span> /&gt;</div></pre></td></tr></table></figure>
<ol>
<li><p>TYPE_STEP_COUNTER<br>API的解释说返回从开机被激活后统计的步数，当重启手机后该数据归零，该传感器是一个硬件传感器所以它是低功耗的。为了能持续的计步，请不要反注册事件，就算手机处于休眠状态它依然会计步。当激活的时候依然会上报步数。该sensor适合在长时间的计步需求。</p>
</li>
<li><p>TYPE_STEP_DETECTOR<br>翻译过来就是走路检测，API文档也确实是这样说的，该sensor只用来监监测走步，每次返回数字1.0。如果需要长事件的计步请使用TYPE_STEP_COUNTER。</p>
</li>
</ol>
<p>用法比较简单，实现比较方便，由于我们需要长时间的计步，所以一般我们采用<code>TYPE_STEP_COUNTER</code>。<br>优点：</p>
<ul>
<li>精度相对来说精确。</li>
<li>低功耗，对手机续航基本没有影响。</li>
<li>不需要后台服务持续唤醒，所以不需要后台保活。</li>
<li>实现简单。</li>
</ul>
<p>缺点：</p>
<ul>
<li>手机必须要Android4.4及以上版本，并且内置计步sensor硬件</li>
<li>并不像iOS的M7协处理器记录每天各个时段的计步数据，step counter sensor记录从开机以来所有的步数，每日计步数需要自己维护。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结来说，如果用g-sensor来实现计步会保证良好的兼容性，排除锁屏自动关闭sensor的定制系统除外，基本所有的Android手机都可以使用，但是需要一定时间的算法调试和后台保活机制的健全保证，开发周期较长；如果项目需求开发周期较短，并且没有强制性的全机型兼容，那么可以考虑使用step-sensor，优点比较明显，而且使用协处理器代替纯软件计算实现计步监测已经是大势所趋。另外以上两种方案都需要开机自启权限。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.wujiame.com/blog/2013/12/27/pedometer/" target="_blank" rel="external">如何在手机上实现高精度及自适应多种场景的计步器算法</a><br><a href="https://github.com/johnjohndoe/Android-Developers-Samples/tree/master/BatchStepSensor" target="_blank" rel="external">Android-Developers-Samples-BatchStepSensor</a><br><a href="http://www.analog.com/library/analogDialogue/china/archives/44-06/pedometer.html" target="_blank" rel="external">利用3轴数字加速度计实现功能全面的计步器设计</a></p>
<p>本文链接： <a href="http://w4lle.com/2016/06/26/step-counter/">http://w4lle.com/2016/06/26/step-counter/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;计步越来越成为人们的强需求，一般有手环计步，手表计步，手机计步等实现，这篇文章讨论下手机上实现计步的两种方案。&lt;/p&gt;
&lt;h1 id=&quot;加速
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
  </entry>
  
</feed>
