<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>w4lle&#39;s Notes</title>
  <subtitle>Eeeee... va?</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://w4lle.com/"/>
  <updated>2021-02-02T10:50:43.382Z</updated>
  <id>http://w4lle.com/</id>
  
  <author>
    <name>w4lle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter UI 渲染浅析（七）Composite</title>
    <link href="http://w4lle.com/2021/02/02/flutter-ui-composite/"/>
    <id>http://w4lle.com/2021/02/02/flutter-ui-composite/</id>
    <published>2021-02-02T06:13:18.000Z</published>
    <updated>2021-02-02T10:50:43.382Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章的第七篇，本篇文章继续分析下Composite合成过程。</p>
<a id="more"></a>
<p>其实叫合成不太准备，应该叫做提交合成。</p>
<p>前面的文章分析完了<code>flushLayout</code>，继续分析下 <code>RendererBinding.drawFrame()</code> 剩余部分。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/binding.dart</span></div><div class="line">	<span class="meta">@protected</span></div><div class="line">  <span class="keyword">void</span> drawFrame() &#123;</div><div class="line">    <span class="keyword">assert</span>(renderView != <span class="keyword">null</span>);</div><div class="line">    pipelineOwner.flushLayout();</div><div class="line">    pipelineOwner.flushCompositingBits();</div><div class="line">    pipelineOwner.flushPaint();</div><div class="line">    <span class="keyword">if</span> (sendFramesToEngine) &#123;</div><div class="line">      renderView.compositeFrame(); <span class="comment">// this sends the bits to the GPU</span></div><div class="line">      pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></div><div class="line">      _firstFrameSent = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h1 id="1、compositeFrame-合成阶段"><a href="#1、compositeFrame-合成阶段" class="headerlink" title="1、compositeFrame 合成阶段"></a>1、compositeFrame 合成阶段</h1><p>照例还是分为两部分，标脏&amp;数据处理。</p>
<h2 id="1-1、markNeedsAddToScene-标脏"><a href="#1-1、markNeedsAddToScene-标脏" class="headerlink" title="1.1、markNeedsAddToScene 标脏"></a>1.1、markNeedsAddToScene 标脏</h2><p>在上篇文章中，LayerTree构建过程中以及stopRecording时，会触发标脏方法<code>markNeedsAddToScene();</code></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/layer.dart</span></div><div class="line">	<span class="keyword">void</span> markNeedsAddToScene() &#123;</div><div class="line">    <span class="comment">// Already marked. Short-circuit.</span></div><div class="line">    <span class="keyword">if</span> (_needsAddToScene) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    _needsAddToScene = <span class="keyword">true</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>该方法用来标脏该Layer状态已经发生改变，需要调用addToScene将其发送到Flutter Engine。</p>
<h2 id="1-2、compositeFrame"><a href="#1-2、compositeFrame" class="headerlink" title="1.2、compositeFrame"></a>1.2、compositeFrame</h2><p>drawFrame方法接着调用renderView.compositeFrame方法，看下实现。</p>
<p>其中的RenderView对象作为RenderObject的根节点，其layer类型为TransformLayer。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/view.dart RenderView</span></div><div class="line">	<span class="keyword">void</span> compositeFrame() &#123;</div><div class="line">    <span class="comment">//记录 Compositing</span></div><div class="line">    Timeline.startSync(<span class="string">'Compositing'</span>, arguments: timelineArgumentsIndicatingLandmarkEvent);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">final</span> ui.SceneBuilder builder = ui.SceneBuilder();</div><div class="line">      <span class="keyword">final</span> ui.Scene scene = layer.buildScene(builder);</div><div class="line">      <span class="keyword">if</span> (automaticSystemUiAdjustment)</div><div class="line">        _updateSystemChrome();</div><div class="line">      _window.render(scene);</div><div class="line">      <span class="comment">//清理</span></div><div class="line">      scene.dispose();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="comment">//结束记录</span></div><div class="line">      Timeline.finishSync();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>构建SceneBuilder对象，它的实现在Flutter Engine</li>
<li>依赖Layer和SceneBuilder对象，通过layer.buildScene得到Scene对象</li>
<li>将Scene对象通过window对象发送给Flutter Engine</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ui.Scene buildScene(ui.SceneBuilder builder) &#123;</div><div class="line">  <span class="comment">// 深度优先遍历，更新子树标脏</span></div><div class="line">  updateSubtreeNeedsAddToScene();</div><div class="line">  <span class="comment">// 遍历LayerTree，构建 EngineLayerTree </span></div><div class="line">  addToScene(builder);</div><div class="line">  <span class="comment">// 清除标脏</span></div><div class="line">  _needsAddToScene = <span class="keyword">false</span>;</div><div class="line">  <span class="comment">//生成 Scene</span></div><div class="line">  <span class="keyword">final</span> ui.Scene scene = builder.build();</div><div class="line">  <span class="keyword">return</span> scene;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先深度优先遍历，更新子树标脏，逻辑是当前节点Layer被标脏为 <code>_needsAddToScene</code>，那么其祖先节点都会被标脏为<code>_needsAddToScene</code>。</p>
<p>然后调用<code>addToScene(builder)</code> 遍历LayerTree，构建 EngineLayerTree </p>
<h1 id="2、构建Engine-LayerTree-amp-Scene"><a href="#2、构建Engine-LayerTree-amp-Scene" class="headerlink" title="2、构建Engine LayerTree &amp; Scene"></a>2、构建Engine LayerTree &amp; Scene</h1><p>按照深度优先遍历LayerTree，构建出Flutter Engine 层的EngineLayerTree</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/layer.dart  ContainerLayer</span></div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> addToScene(ui.SceneBuilder builder, [ Offset layerOffset = Offset.zero ]) &#123;</div><div class="line">    addChildrenToScene(builder, layerOffset);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">void</span> addChildrenToScene(ui.SceneBuilder builder, [ Offset childOffset = Offset.zero ]) &#123;</div><div class="line">    Layer child = firstChild;</div><div class="line">    <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (childOffset == Offset.zero) &#123;</div><div class="line">        <span class="comment">//偏移值没变，尝试复用缓存</span></div><div class="line">        child._addToSceneWithRetainedRendering(builder);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//上传Layer到Flutter Engine，生成EngineLayer，需要具体Layer重写该方法</span></div><div class="line">        child.addToScene(builder, childOffset);</div><div class="line">      &#125;</div><div class="line">      child = child.nextSibling;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">void</span> _addToSceneWithRetainedRendering(ui.SceneBuilder builder) &#123;</div><div class="line">    <span class="keyword">if</span> (!_needsAddToScene &amp;&amp; _engineLayer != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// _needsAddToScene为false，并且上次生成的_engineLayer不空</span></div><div class="line">      <span class="comment">// 复用_engineLayer，不再重新上传</span></div><div class="line">      builder.addRetained(_engineLayer);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    addToScene(builder);</div><div class="line">    _needsAddToScene = <span class="keyword">false</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果偏移值没变，尝试复用缓存</li>
<li>上传Layer到Flutter Engine，生成EngineLayer，需要具体Layer重写该方法</li>
</ul>
<p>还是以ClipRectLayer为例</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@override</span></div><div class="line"><span class="keyword">void</span> addToScene(ui.SceneBuilder builder, [ Offset layerOffset = Offset.zero ]) &#123;</div><div class="line">  <span class="keyword">final</span> Rect shiftedClipRect = layerOffset == Offset.zero ? clipRect : 					clipRect.shift(layerOffset);</div><div class="line">  <span class="comment">//通过SceneBuilder上传ClipLayer，构建出EngineLayer，并把EngineLayer缓存下来</span></div><div class="line">  engineLayer = builder.pushClipRect(</div><div class="line">    shiftedClipRect,</div><div class="line">    clipBehavior: clipBehavior,</div><div class="line">    oldLayer: _engineLayer <span class="keyword">as</span> ui.ClipRectEngineLayer,</div><div class="line">  );</div><div class="line">...</div><div class="line">  <span class="comment">//继续遍历子树</span></div><div class="line">  addChildrenToScene(builder, layerOffset);</div><div class="line">  <span class="comment">// 结束裁剪效果</span></div><div class="line">  builder.pop();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过SceneBuilder上传ClipLayer，构建出EngineLayer，并把EngineLayer缓存下来，在下次调用addToScene时，尝试复用EngineLayer，通过 builder.addRetained(_engineLayer) 实现复用。</p>
<p>SceneBuilder、Scene、EngineLayer的实现都在Flutter Engine层。</p>
<p>先看下SceneBuilder的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/ui/compositing/scene_builder.cc</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_EACH_BINDING(V)                         \</span></div><div class="line">  V(SceneBuilder, pushOffset)                       \</div><div class="line">  V(SceneBuilder, pushTransform)                    \</div><div class="line">  V(SceneBuilder, pushClipRect)                     \</div><div class="line">  V(SceneBuilder, pushClipRRect)                    \</div><div class="line">  V(SceneBuilder, pushClipPath)                     \</div><div class="line">  V(SceneBuilder, pushOpacity)                      \</div><div class="line">  V(SceneBuilder, pushColorFilter)                  \</div><div class="line">  V(SceneBuilder, pushImageFilter)                  \</div><div class="line">  V(SceneBuilder, pushBackdropFilter)               \</div><div class="line">  V(SceneBuilder, pushShaderMask)                   \</div><div class="line">  V(SceneBuilder, pushPhysicalShape)                \</div><div class="line">  V(SceneBuilder, pop)                              \</div><div class="line">  V(SceneBuilder, addPlatformView)                  \</div><div class="line">  V(SceneBuilder, addRetained)                      \</div><div class="line">  V(SceneBuilder, addPicture)                       \</div><div class="line">  V(SceneBuilder, addTexture)                       \</div><div class="line">  V(SceneBuilder, addPerformanceOverlay)            \</div><div class="line">  V(SceneBuilder, setRasterizerTracingThreshold)    \</div><div class="line">  V(SceneBuilder, setCheckerboardOffscreenLayers)   \</div><div class="line">  V(SceneBuilder, setCheckerboardRasterCacheImages) \</div><div class="line">  V(SceneBuilder, build)</div><div class="line"><span class="comment">//通过ffi绑定Dart方法</span></div><div class="line">FOR_EACH_BINDING(DART_NATIVE_CALLBACK)</div><div class="line">SceneBuilder::SceneBuilder() &#123;</div><div class="line">  <span class="comment">// 添加一个根节点</span></div><div class="line">  PushLayer(<span class="built_in">std</span>::make_shared&lt;flutter::ContainerLayer&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过ffi绑定Dart方法，并且添加一个根节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/ui/compositing/scene_builder.cc</span></div><div class="line"><span class="keyword">void</span> SceneBuilder::pushClipRect(Dart_Handle layer_handle,</div><div class="line">                                <span class="keyword">double</span> left,</div><div class="line">                                <span class="keyword">double</span> right,</div><div class="line">                                <span class="keyword">double</span> top,</div><div class="line">                                <span class="keyword">double</span> bottom,</div><div class="line">                                <span class="keyword">int</span> clipBehavior) &#123;</div><div class="line">  <span class="comment">//构造SkRect对象</span></div><div class="line">  SkRect clipRect = SkRect::MakeLTRB(left, top, right, bottom);</div><div class="line">  <span class="comment">//裁剪类型</span></div><div class="line">  flutter::Clip clip_behavior = <span class="keyword">static_cast</span>&lt;flutter::Clip&gt;(clipBehavior);</div><div class="line">  <span class="comment">// 构造ClipRectLayer</span></div><div class="line">  <span class="keyword">auto</span> layer =</div><div class="line">      <span class="built_in">std</span>::make_shared&lt;flutter::ClipRectLayer&gt;(clipRect, clip_behavior);</div><div class="line">  <span class="comment">//</span></div><div class="line">  PushLayer(layer);</div><div class="line">  <span class="comment">//包装成EngineLayer，返回给Dart缓存</span></div><div class="line">  EngineLayer::MakeRetained(layer_handle, layer);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> SceneBuilder::PushLayer(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ContainerLayer&gt; layer) &#123;</div><div class="line">  AddLayer(layer);</div><div class="line">  <span class="comment">//vector 队列维护layer层级，用于生成LayerTree</span></div><div class="line">  layer_stack_.push_back(<span class="built_in">std</span>::move(layer));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> SceneBuilder::AddLayer(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Layer&gt; layer) &#123;</div><div class="line">  <span class="keyword">if</span> (!layer_stack_.empty()) &#123;</div><div class="line">    <span class="comment">//拿到最后一个ContainerLayer引用，将layer添加到它的后面，形成LayerTree    </span></div><div class="line">    layer_stack_.back()-&gt;Add(<span class="built_in">std</span>::move(layer));</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> SceneBuilder::PopLayer() &#123;</div><div class="line">  <span class="keyword">if</span> (layer_stack_.size() &gt; <span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">//当前layer的子树全部添加到LayerTree中，出队列</span></div><div class="line">    layer_stack_.pop_back();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> SceneBuilder::build(Dart_Handle scene_handle) &#123;]</div><div class="line">	<span class="comment">//通过LayerTree，构造Scene对象，返回给Dart</span></div><div class="line">  Scene::create(scene_handle, layer_stack_[<span class="number">0</span>], rasterizer_tracing_threshold_,</div><div class="line">                checkerboard_raster_cache_images_,</div><div class="line">                checkerboard_offscreen_layers_);</div><div class="line">  ClearDartWrapper();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Dart Framework中的Layer 类型和C++ Engine中的flow::Layer类型是一一对应的，在这里做了从Dart Framework LayerTree到C++ Engine LayerTree 的转换。</p>
<p>通过Scene，将Dart Framework中的LayerTree依次遍历，映射生成C++ Engine Layer，并构建Engine LayerTree，存储在Scene对象中。</p>
<p>其中通过vector队列维护layer层级，来达到Engine LayerTree与Framework LayerTree层级一一对应。</p>
<p>Flow模块是一个基于Skia的简单合成器，运行在Raster(GPU)线程，并向Skia上传绘制指令信息。这里不展开。</p>
<h1 id="3、Window-render"><a href="#3、Window-render" class="headerlink" title="3、Window.render"></a>3、Window.render</h1><p>接着调用_window.render(scene)，实现在Flutter Engine，通过Window、Engine，最终调用到<code>Animator::Render</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// flutter/shell/common/animator.cc</span></div><div class="line"><span class="keyword">void</span> Animator::Render(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;flutter::LayerTree&gt; layer_tree) &#123;</div><div class="line">  last_layer_tree_size_ = layer_tree-&gt;frame_size();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (layer_tree) &#123;</div><div class="line">    <span class="comment">// 开始时间、目标时间记录在LayerTree</span></div><div class="line">    <span class="comment">// LayerTree是Scene中的对象，包含Engine LayerTree</span></div><div class="line">    layer_tree-&gt;RecordBuildTime(last_frame_begin_time_,</div><div class="line">                                last_frame_target_time_);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 当前任务完成，LayerTree结果写入LayerTreePipeline，</span></div><div class="line">  <span class="keyword">bool</span> result = producer_continuation_.Complete(<span class="built_in">std</span>::move(layer_tree));</div><div class="line">  <span class="comment">//Raster线程，光栅化和合成</span></div><div class="line">  delegate_.OnAnimatorDraw(layer_tree_pipeline_, last_frame_target_time_);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>记录build时间，CPU 过程从VYSNC触发的时间点，即doFrame的触发时间点开始，到Animator::Render结束</li>
<li>当前任务完成，LayerTree结果写入LayerTreePipeline，继续接收<code>ScheduleFrame</code> -&gt; <code>Animator::RequestFrame()</code> 触发开始绘制，具体细节参考《Flutter UI 渲染浅析（二）VSync 注册》</li>
<li>转到Raster线程，进行光栅化和合成操作</li>
</ul>
<p>LayerTreePipeline是Engine层的渲染管线，用来调度渲染任务。</p>
<p>LayerTreePipeline构建深度为 2 的 <code>Pipeline</code> 对象，可以持有 <code>flutter::LayerTree</code> 对象。</p>
<p>Pipeline 持有两个信号量 <code>empty_</code> 和 <code>available_</code>，用来控制管线任务调度。</p>
<p>整个 Pipeline 管线的流程为：</p>
<ul>
<li><code>Animator::RequestFrame()</code>方法触发绘制开始<code>_empty</code> -1，开始生成 <code>flutter::LayerTree</code>，运行在 UIThread</li>
<li>当 UIThread 准备好 Engine <code>flutter::LayerTree</code>， <code>available_</code> +1</li>
<li>当 <code>available_</code> &gt; 0 时，触发 Raster Thread 工作，拿到 <code>flutter:LayerTree</code> 进行光栅化合成</li>
<li>当 RasterThread 处理完成， <code>_empty</code> + 1，下次 <code>Animator::RequestFrame()</code> 可以正常开始处理生成 <code>flutter::LayerTree</code> 工作</li>
<li>当 <code>_empty</code> 为 0 时，管线任务已满，忽略本次 <code>Animator::RequestFrame()</code> 请求，直到下一次 VSync 信号到来</li>
</ul>
<p>通过两个信号量来管理管线的调度，这种调度机制可以确保 RasterThread 不至于过载（2个任务），同时也可以避免 UIThread 不必要的资源消耗。</p>
<p>所以，也就明白了文章开头提到的为什么叫提交合成，而不叫合成。Composite 只是将Dart Framework LayerTree通过C++ Engine，映射成 Engine LayerTree，提交给Raster Thread处理，而<strong>并非真正的合成</strong>。</p>
<p>然后执行Semantic语义更新，pipelineOwnerflushSemantics()，跟渲染关系不大，这里略过。</p>
<p>到这里 <code>RendererBinding.drawFrame()</code>方法全部执行完成，接下来转到Raster线程，进行光栅化和合成上屏的操作。</p>
<p>Raster线程也是跑在CPU上的，为了避免歧义，官方将其名称从 GPU Thread 更改为了 Raster Thread。</p>
<p>执行完 <code>RendererBinding.drawFrame()</code>方法后，继续回到 <code>WidgetsBinding.drawFrame()</code> 中。详见《Flutter UI 渲染浅析（四）Build》</p>
<p>最后执行<code>WidgetsBinding.drawFrame()</code>方法中的buildOwner.finalizeTree()方法，卸载未激活状态的 Element 节点（未激活状态的节点在一个绘制帧周期内，是有可能被重新激活的——在Element.rebuild阶段，如果没有重新激活，那么就卸载掉）。</p>
<h1 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h1><p>至此，<code>_persistentCallbacks</code> 回调执行结束，整个绘制流程也就结束了。</p>
<p>本系列文章从Flutter App启动作为入口，了解了7 个主要的 Binding 类及其作用。</p>
<p>从Widget setState()为切入点，分析了Dart Framework和C++ Engine之间的交互过程。</p>
<p>从ScheduleFrame触发绘制注册Vsync信号，到Vsync信号到来回调Dart Framework，进而触发Animate、Build、Layout、Paint一系列绘制操作。</p>
<p>最终在Dart Framework生成含有层级关系以及绘制指令的Layer Tree，将其映射到C++ Engine生成Engine LayerTree。</p>
<p>最后提交给Raster 线程合成上屏。</p>
<p>整个过程由Engine LayerTreePipeline渲染管线调度管控，周而复始地将Widget内容绘制到屏幕上。</p>
<p>本系列文章事无巨细的分析了上述的关键流程及其实现代码，涵盖Dart Framework和C++ Engine。</p>
<p>总结下来，Dart Framework中的Widget、Element、RenderObject、Binding这些东西的存在，都是为了最后生成Layer Tree用，如果没有这些，能不能直接进行绘制呢？</p>
<p>当然是可以的，官方就提供了这样的demo</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span> <span class="keyword">as</span> math;</div><div class="line"><span class="keyword">import</span> <span class="string">'dart:typed_data'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'dart:ui'</span> <span class="keyword">as</span> ui;</div><div class="line"></div><div class="line">ui.Picture paint(ui.Rect paintBounds) &#123;</div><div class="line">  <span class="comment">// First we create a PictureRecorder to record the commands we're going to</span></div><div class="line">  <span class="comment">// feed in the canvas. The PictureRecorder will eventually produce a Picture,</span></div><div class="line">  <span class="comment">// which is an immutable record of those commands.</span></div><div class="line">  <span class="keyword">final</span> ui.PictureRecorder recorder = ui.PictureRecorder();</div><div class="line"></div><div class="line">  <span class="comment">// Next, we create a canvas from the recorder. The canvas is an interface</span></div><div class="line">  <span class="comment">// which can receive drawing commands. The canvas interface is modeled after</span></div><div class="line">  <span class="comment">// the SkCanvas interface from Skia. The paintBounds establishes a "cull rect"</span></div><div class="line">  <span class="comment">// for the canvas, which lets the implementation discard any commands that</span></div><div class="line">  <span class="comment">// are entirely outside this rectangle.</span></div><div class="line">  <span class="keyword">final</span> ui.Canvas canvas = ui.Canvas(recorder, paintBounds);</div><div class="line"></div><div class="line">  <span class="keyword">final</span> ui.Paint paint = ui.Paint();</div><div class="line">  canvas.drawPaint(ui.Paint()..color = <span class="keyword">const</span> ui.Color(<span class="number">0xFFFFFFFF</span>));</div><div class="line"></div><div class="line">  <span class="keyword">final</span> ui.Size size = paintBounds.size;</div><div class="line">  <span class="keyword">final</span> ui.Offset mid = size.center(ui.Offset.zero);</div><div class="line">  <span class="keyword">final</span> <span class="built_in">double</span> radius = size.shortestSide / <span class="number">2.0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">final</span> <span class="built_in">double</span> devicePixelRatio = ui.<span class="built_in">window</span>.devicePixelRatio;</div><div class="line">  <span class="keyword">final</span> ui.Size logicalSize = ui.<span class="built_in">window</span>.physicalSize / devicePixelRatio;</div><div class="line"></div><div class="line">  <span class="comment">// Saves a copy of current transform onto the save stack</span></div><div class="line">  canvas.save();</div><div class="line"></div><div class="line">  <span class="comment">// Note that transforms that occur after this point apply only to the</span></div><div class="line">  <span class="comment">// yellow-bluish rectangle</span></div><div class="line"></div><div class="line">  <span class="comment">// This line will cause the transform to shift entirely outside the paint</span></div><div class="line">  <span class="comment">// boundaries, which will cause the canvas interface to discard its</span></div><div class="line">  <span class="comment">// commands. Comment it out to see it on screen.</span></div><div class="line">  canvas.translate(-mid.dx / <span class="number">2.0</span>, logicalSize.height * <span class="number">2.0</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Clips the current transform</span></div><div class="line">  canvas.clipRect(</div><div class="line">    ui.Rect.fromLTRB(<span class="number">0</span>, radius + <span class="number">50</span>, logicalSize.width, logicalSize.height),</div><div class="line">    clipOp: ui.ClipOp.difference,</div><div class="line">  );</div><div class="line"></div><div class="line">  <span class="comment">// Shifts the coordinate space of and rotates the current transform</span></div><div class="line">  canvas.translate(mid.dx, mid.dy);</div><div class="line">  canvas.rotate(math.pi/<span class="number">4</span>);</div><div class="line"></div><div class="line">  <span class="keyword">final</span> ui.Gradient yellowBlue = ui.Gradient.linear(</div><div class="line">    ui.Offset(-radius, -radius),</div><div class="line">    <span class="keyword">const</span> ui.Offset(<span class="number">0.0</span>, <span class="number">0.0</span>),</div><div class="line">    &lt;ui.Color&gt;[<span class="keyword">const</span> ui.Color(<span class="number">0xFFFFFF00</span>), <span class="keyword">const</span> ui.Color(<span class="number">0xFF0000FF</span>)],</div><div class="line">  );</div><div class="line"></div><div class="line">  <span class="comment">// Draws a yellow-bluish rectangle</span></div><div class="line">  canvas.drawRect(</div><div class="line">    ui.Rect.fromLTRB(-radius, -radius, radius, radius),</div><div class="line">    ui.Paint()..shader = yellowBlue,</div><div class="line">  );</div><div class="line"></div><div class="line">  <span class="comment">// Note that transforms that occur after this point apply only to the</span></div><div class="line">  <span class="comment">// yellow circle</span></div><div class="line"></div><div class="line">  <span class="comment">// Scale x and y by 0.5.</span></div><div class="line">  <span class="keyword">final</span> Float64List scaleMatrix = Float64List.fromList(&lt;<span class="built_in">double</span>&gt;[</div><div class="line">      <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</div><div class="line">      <span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</div><div class="line">      <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>,</div><div class="line">      <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>,</div><div class="line">  ]);</div><div class="line">  canvas.transform(scaleMatrix);</div><div class="line"></div><div class="line">  <span class="comment">// Sets paint to transparent yellow</span></div><div class="line">  paint.color = <span class="keyword">const</span> ui.Color.fromARGB(<span class="number">128</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Draws a transparent yellow circle</span></div><div class="line">  canvas.drawCircle(ui.Offset.zero, radius, paint);</div><div class="line"></div><div class="line">  <span class="comment">// Restores the transform from before `save` was called</span></div><div class="line">  canvas.restore();</div><div class="line"></div><div class="line">  <span class="comment">// Sets paint to transparent red</span></div><div class="line">  paint.color = <span class="keyword">const</span> ui.Color.fromARGB(<span class="number">128</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Note that this circle is drawn on top of the previous layer that contains</span></div><div class="line">  <span class="comment">// the rectangle and smaller circle</span></div><div class="line">  canvas.drawCircle(<span class="keyword">const</span> ui.Offset(<span class="number">150.0</span>, <span class="number">300.0</span>), radius, paint);</div><div class="line"></div><div class="line">  <span class="comment">// When we're done issuing painting commands, we end the recording an receive</span></div><div class="line">  <span class="comment">// a Picture, which is an immutable record of the commands we've issued. You</span></div><div class="line">  <span class="comment">// can draw a Picture into another canvas or include it as part of a</span></div><div class="line">  <span class="comment">// composited scene.</span></div><div class="line">  <span class="keyword">return</span> recorder.endRecording();</div><div class="line">&#125;</div><div class="line"></div><div class="line">ui.Scene composite(ui.Picture picture, ui.Rect paintBounds) &#123;</div><div class="line">  <span class="keyword">final</span> <span class="built_in">double</span> devicePixelRatio = ui.<span class="built_in">window</span>.devicePixelRatio;</div><div class="line">  <span class="keyword">final</span> Float64List deviceTransform = Float64List(<span class="number">16</span>)</div><div class="line">    ..[<span class="number">0</span>] = devicePixelRatio</div><div class="line">    ..[<span class="number">5</span>] = devicePixelRatio</div><div class="line">    ..[<span class="number">10</span>] = <span class="number">1.0</span></div><div class="line">    ..[<span class="number">15</span>] = <span class="number">1.0</span>;</div><div class="line">  <span class="keyword">final</span> ui.SceneBuilder sceneBuilder = ui.SceneBuilder()</div><div class="line">    ..pushTransform(deviceTransform)</div><div class="line">    ..addPicture(ui.Offset.zero, picture)</div><div class="line">    ..pop();</div><div class="line">  <span class="keyword">return</span> sceneBuilder.build();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> beginFrame(<span class="built_in">Duration</span> timeStamp) &#123;</div><div class="line">  <span class="keyword">final</span> ui.Rect paintBounds = ui.Offset.zero &amp; (ui.<span class="built_in">window</span>.physicalSize / ui.<span class="built_in">window</span>.devicePixelRatio);</div><div class="line">  <span class="keyword">final</span> ui.Picture picture = paint(paintBounds);</div><div class="line">  <span class="keyword">final</span> ui.Scene scene = composite(picture, paintBounds);</div><div class="line">  ui.<span class="built_in">window</span>.render(scene);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> main() &#123;</div><div class="line">  ui.<span class="built_in">window</span>.onBeginFrame = beginFrame;</div><div class="line">  ui.<span class="built_in">window</span>.scheduleFrame();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码，直接在dart:ui.window对象中注册了onBeginFrame() 回调，抛弃了Dart Framework中Widget、Element、RenderObject、Binding这些东西，直接构建Canvas对象进行绘制，绘制完成后生成Layer Tree，提交给C++ Engine。</p>
<p><a href="https://codepen.io/w4lle/pen/ZEOPZEe" target="_blank" rel="external">代码运行结果可以在这里看到。</a></p>
<p> Dart Framework的将这些绘制操作进行封装，可以达到更高的开发效率和渲染性能。</p>
<p>通过Canvas&amp;Scene，开发者不需要关系LayerTree如何提交给Engine；</p>
<p>通过LayerTree&amp;Engine LayerTree，在Composite阶段可以进行缓存复用，没变化的Layer层级可以不用多次提交；</p>
<p>通过RenderTree，开发者可以自由扩展控件的布局和绘制；</p>
<p>通过ElementTree，开发者可以不需要关心如何刷新界面，数据可以直接驱动UI刷新，这一层也是实现hot reload的基础；</p>
<p>通过WidgetTree，开发者可以开发更现代化的声明式UI应用。</p>
<p>最后引用本系列文章开篇中的一张图做个总结。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter_rendering_pipeline.png" alt=""></p>
<p>本文链接： <a href="http://w4lle.com/2021/02/02/flutter-ui-composite/">http://w4lle.com/2021/02/02/flutter-ui-composite/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;系列文章的第七篇，本篇文章继续分析下Composite合成过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://w4lle.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter UI 渲染浅析（六）Paint</title>
    <link href="http://w4lle.com/2021/02/01/flutter-ui-paint/"/>
    <id>http://w4lle.com/2021/02/01/flutter-ui-paint/</id>
    <published>2021-02-01T07:02:20.000Z</published>
    <updated>2021-02-02T10:35:42.447Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章的第六篇，本篇文章继续分析下Paint绘制过程及Layer Tree。</p>
<a id="more"></a>
<p>前面的文章分析完了<code>flushLayout</code>，继续分析下 <code>RendererBinding.drawFrame()</code> 剩余部分。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/binding.dart</span></div><div class="line">	<span class="meta">@protected</span></div><div class="line">  <span class="keyword">void</span> drawFrame() &#123;</div><div class="line">    <span class="keyword">assert</span>(renderView != <span class="keyword">null</span>);</div><div class="line">    pipelineOwner.flushLayout();</div><div class="line">    pipelineOwner.flushCompositingBits();</div><div class="line">    pipelineOwner.flushPaint();</div><div class="line">    <span class="keyword">if</span> (sendFramesToEngine) &#123;</div><div class="line">      renderView.compositeFrame(); <span class="comment">// this sends the bits to the GPU</span></div><div class="line">      pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></div><div class="line">      _firstFrameSent = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h1 id="1、flushCompositingBits-标记合成阶段"><a href="#1、flushCompositingBits-标记合成阶段" class="headerlink" title="1、flushCompositingBits 标记合成阶段"></a>1、flushCompositingBits 标记合成阶段</h1><p>照例分为两部分，标脏&amp;数据处理。</p>
<h2 id="1-1、markNeedsCompositingBitsUpdate-标脏"><a href="#1-1、markNeedsCompositingBitsUpdate-标脏" class="headerlink" title="1.1、markNeedsCompositingBitsUpdate 标脏"></a>1.1、markNeedsCompositingBitsUpdate 标脏</h2><p>当RenderObject获取新的子节点或重新挂载时时，会触发adoptChild</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/object.dart</span></div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> adoptChild(RenderObject child) &#123;</div><div class="line">    <span class="keyword">assert</span>(_debugCanPerformMutations);</div><div class="line">    <span class="keyword">assert</span>(child != <span class="keyword">null</span>);</div><div class="line">    setupParentData(child);</div><div class="line">    markNeedsLayout();</div><div class="line">    markNeedsCompositingBitsUpdate();</div><div class="line">    markNeedsSemanticsUpdate();</div><div class="line">    <span class="keyword">super</span>.adoptChild(child);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>其中的markNeedsCompositingBitsUpdate</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/object.dart</span></div><div class="line">  <span class="keyword">void</span> markNeedsCompositingBitsUpdate() &#123;</div><div class="line">    <span class="keyword">if</span> (_needsCompositingBitsUpdate)</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    _needsCompositingBitsUpdate = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderObject) &#123;</div><div class="line">      <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent <span class="keyword">as</span> RenderObject;</div><div class="line">      <span class="keyword">if</span> (parent._needsCompositingBitsUpdate)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      <span class="comment">//向上寻找第一个isRepaintBoundary为true的节点</span></div><div class="line">      <span class="keyword">if</span> (!isRepaintBoundary &amp;&amp; !parent.isRepaintBoundary) &#123;</div><div class="line">        parent.markNeedsCompositingBitsUpdate();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>)</div><div class="line">      owner._nodesNeedingCompositingBitsUpdate.add(<span class="keyword">this</span>);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>做了几件事情：</p>
<ul>
<li>标记_needsCompositingBitsUpdate为true</li>
<li>加入到pipelineOwner的_nodesNeedingCompositingBitsUpdate列表中</li>
<li>向上寻找第一个isRepaintBoundary为true的节点，递归结束</li>
</ul>
<p>所以就是把所有不是isRepaintBoundary的RenderObject都加入到了_nodesNeedingCompositingBitsUpdate列表中。</p>
<h2 id="1-2、flushCompositingBits"><a href="#1-2、flushCompositingBits" class="headerlink" title="1.2、flushCompositingBits"></a>1.2、flushCompositingBits</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/binding.dart</span></div><div class="line">  <span class="keyword">void</span> flushCompositingBits() &#123;</div><div class="line">    <span class="keyword">if</span> (!kReleaseMode) &#123;</div><div class="line">      <span class="comment">//记录 Compositing bits</span></div><div class="line">      Timeline.startSync(<span class="string">'Compositing bits'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//广度优先</span></div><div class="line">    _nodesNeedingCompositingBitsUpdate.sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> RenderObject node <span class="keyword">in</span> _nodesNeedingCompositingBitsUpdate) &#123;</div><div class="line">      <span class="keyword">if</span> (node._needsCompositingBitsUpdate &amp;&amp; node.owner == <span class="keyword">this</span>)</div><div class="line">        node._updateCompositingBits();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//清除列表</span></div><div class="line">    _nodesNeedingCompositingBitsUpdate.clear();</div><div class="line">    <span class="keyword">if</span> (!kReleaseMode) &#123;</div><div class="line">      <span class="comment">//结束记录</span></div><div class="line">      Timeline.finishSync();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>顺序遍历 _nodesNeedingCompositingBitsUpdate列表，即先遍历父节点，调用RenderObject的 _updateCompositingBits 方法。</p>
<p>过程记录在TimeLine的Compositing bits阶段，运行在UI线程。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/object.dart</span></div><div class="line">  <span class="keyword">void</span> _updateCompositingBits() &#123;</div><div class="line">    <span class="keyword">if</span> (!_needsCompositingBitsUpdate)</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> oldNeedsCompositing = _needsCompositing;</div><div class="line">    _needsCompositing = <span class="keyword">false</span>;</div><div class="line">  	<span class="comment">//递归子节点  </span></div><div class="line">    visitChildren((RenderObject child) &#123;</div><div class="line">      child._updateCompositingBits();</div><div class="line">      <span class="keyword">if</span> (child.needsCompositing)</div><div class="line">        _needsCompositing = <span class="keyword">true</span>;</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//如果是isRepaintBoundary，标记_needsCompositing为true</span></div><div class="line">    <span class="keyword">if</span> (isRepaintBoundary || alwaysNeedsCompositing)</div><div class="line">      _needsCompositing = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (oldNeedsCompositing != _needsCompositing)</div><div class="line">      markNeedsPaint();</div><div class="line">    _needsCompositingBitsUpdate = <span class="keyword">false</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>递归遍历子节点：</p>
<ul>
<li>找到isRepaintBoundary为true的节点，标记_needsCompositing为true</li>
<li>isRepaintBoundary为true节点的所有父节点，都标记_needsCompositing为true</li>
</ul>
<p>这些标记在flushPaint过程中会用到。</p>
<h1 id="2、isRepaintBoundary"><a href="#2、isRepaintBoundary" class="headerlink" title="2、isRepaintBoundary"></a>2、isRepaintBoundary</h1><p>那么isRepaintBoundary是哪里来的？</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/object.dart</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> <span class="keyword">extends</span> <span class="title">AbstractNode</span> <span class="title">with</span> <span class="title">DiagnosticableTreeMixin</span> <span class="keyword">implements</span> <span class="title">HitTestTarget</span> </span>&#123;</div><div class="line">  <span class="comment">/// Initializes internal fields for subclasses.</span></div><div class="line">  RenderObject() &#123;</div><div class="line">    _needsCompositing = isRepaintBoundary || alwaysNeedsCompositing;</div><div class="line">  &#125;</div><div class="line">	...</div><div class="line">  <span class="comment">//默认false</span></div><div class="line">	<span class="built_in">bool</span> <span class="keyword">get</span> isRepaintBoundary =&gt; <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>isRepaintBoundary可以被重写，Dart Framework有以下这些RenderObject重写了该值并返回了true，其中包含根节点RenderView和RenderRepaintBoundary。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20210201153630.png" alt=""></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderRepaintBoundary</span> <span class="keyword">extends</span> <span class="title">RenderProxyBox</span> </span>&#123;</div><div class="line">  <span class="comment">/// Creates a repaint boundary around [child].</span></div><div class="line">  RenderRepaintBoundary(&#123; RenderBox child &#125;) : <span class="keyword">super</span>(child);</div><div class="line"></div><div class="line">  <span class="meta">@override</span></div><div class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> isRepaintBoundary =&gt; <span class="keyword">true</span>;</div><div class="line">  ..</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderView</span> <span class="keyword">extends</span> <span class="title">RenderObject</span> <span class="title">with</span> <span class="title">RenderObjectWithChildMixin</span>&lt;<span class="title">RenderBox</span>&gt; </span>&#123;</div><div class="line">  RenderView(&#123;</div><div class="line">    RenderBox child,</div><div class="line">    <span class="meta">@required</span> ViewConfiguration configuration,</div><div class="line">    <span class="meta">@required</span> ui.Window <span class="built_in">window</span>,</div><div class="line">  &#125;) : <span class="keyword">assert</span>(configuration != <span class="keyword">null</span>),</div><div class="line">       _configuration = configuration,</div><div class="line">       _window = <span class="built_in">window</span> &#123;</div><div class="line">    <span class="keyword">this</span>.child = child;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@override</span></div><div class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> isRepaintBoundary =&gt; <span class="keyword">true</span>;</div><div class="line">  </div><div class="line">  <span class="comment">//RendererBinding的initInstances方法调用该初始化方法</span></div><div class="line">  <span class="keyword">void</span> prepareInitialFrame() &#123;</div><div class="line">    scheduleInitialLayout();</div><div class="line">    scheduleInitialPaint(_updateMatricesAndCreateNewRootLayer());</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  TransformLayer _updateMatricesAndCreateNewRootLayer() &#123;</div><div class="line">    _rootTransform = configuration.toMatrix();</div><div class="line">    <span class="comment">//RenderView的Layer类型为TransformLayer，它是OffsetLayer的子类</span></div><div class="line">    <span class="keyword">final</span> TransformLayer rootLayer = TransformLayer(transform: _rootTransform);</div><div class="line">    rootLayer.attach(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> rootLayer;</div><div class="line">  &#125;</div><div class="line">  ..</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以除了根节点RenderView外，所有位置在上图中之上的RenderObject节点，都会被标记为_needsCompositing需要合成。</p>
<p>另外，RenderRepaintBoundary对应的Widget是RepaintBoundary，该Widget允许开发者指定图层的绘制层级，也就是绘制边界，用于提高绘制性能。</p>
<h1 id="3、flushPaint-绘制阶段"><a href="#3、flushPaint-绘制阶段" class="headerlink" title="3、flushPaint 绘制阶段"></a>3、flushPaint 绘制阶段</h1><p>该阶段主要处理RenderObject的绘制过程。</p>
<p>照例分为两步，标脏&amp;数据处理。</p>
<p>先看一下上文中频繁被调用的markNeedsPaint方法</p>
<h2 id="3-1、markNeedsPaint-标记"><a href="#3-1、markNeedsPaint-标记" class="headerlink" title="3.1、markNeedsPaint 标记"></a>3.1、markNeedsPaint 标记</h2><p>上面layout阶段用到了markNeedsPaint()方法</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/object.dart</span></div><div class="line">	<span class="keyword">void</span> markNeedsPaint() &#123;</div><div class="line">    <span class="keyword">if</span> (_needsPaint)</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    _needsPaint = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">//如果是isRepaintBoundary，加入到_nodesNeedingPaint列表中</span></div><div class="line">    <span class="keyword">if</span> (isRepaintBoundary) &#123;</div><div class="line">      ...</div><div class="line">      <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</div><div class="line">        owner._nodesNeedingPaint.add(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">//发起更新请求</span></div><div class="line">        owner.requestVisualUpdate();</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderObject) &#123;</div><div class="line">      <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent <span class="keyword">as</span> RenderObject;</div><div class="line">      parent.markNeedsPaint();</div><div class="line">      <span class="keyword">assert</span>(parent == <span class="keyword">this</span>.parent);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      ...</div><div class="line">      <span class="keyword">if</span> (owner != <span class="keyword">null</span>)</div><div class="line">        owner.requestVisualUpdate();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>做了几件事情：</p>
<ul>
<li>如果是isRepaintBoundary，加入到pipelineOwner的_nodesNeedingPaint列表中，并且发起绘制请求，注册VSYNC信号回调，结束流程</li>
<li>否则向上遍历</li>
<li>如果都不满足，那么只绘制自己，触发绘制frame</li>
</ul>
<p>isRepaintBoundary可以理解为是否需要独立绘制，如果为true，那么就独立绘制，false就和父节点一起绘制。</p>
<p>下文会详细说明。</p>
<p>通过上面的分析，也就是说只有isRepaintBoundary为true的RenderObject才会被加入到pipelineOwner的_nodesNeedingPaint列表中。</p>
<p>当向上找到isRepaintBoundary时，触发该节点的子树独立绘制流程，流程结束。</p>
<h2 id="3-2、flushPaint"><a href="#3-2、flushPaint" class="headerlink" title="3.2、flushPaint"></a>3.2、flushPaint</h2><p>处理_nodesNeedingPaint脏节点。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> flushPaint() &#123;</div><div class="line">  <span class="keyword">if</span> (!kReleaseMode) &#123;</div><div class="line">    <span class="comment">//记录Paint过程</span></div><div class="line">    Timeline.startSync(<span class="string">'Paint'</span>, arguments: timelineArgumentsIndicatingLandmarkEvent);</div><div class="line">  &#125;</div><div class="line">...</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingPaint;</div><div class="line">    <span class="comment">//清空列表</span></div><div class="line">    _nodesNeedingPaint = &lt;RenderObject&gt;[];</div><div class="line">    <span class="comment">// 深度优先逆序遍历节点</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; b.depth - a.depth)) &#123;</div><div class="line">      <span class="keyword">if</span> (node._needsPaint &amp;&amp; node.owner == <span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (node._layer.attached) &#123;</div><div class="line">          PaintingContext.repaintCompositedChild(node);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          node._skippedPaintingOnLayer();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!kReleaseMode) &#123;</div><div class="line">      <span class="comment">//结束记录</span></div><div class="line">      Timeline.finishSync();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行在UI线程，TimeLine记录Paint过程。</p>
<p>从叶子节点逆序遍历 _nodesNeedingPaint列表。</p>
<p>注意这里只有isRepaintBoundary为true的RenderObject才会被加入到pipelineOwner的 _nodesNeedingPaint列表中。</p>
<p><strong>也就是说从下到上寻找绘制边界，然后从绘制边界向下绘制。</strong></p>
<p>继续这个过程直到_nodesNeedingPaint列表为空。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/object.dart</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintingContext</span> <span class="keyword">extends</span> <span class="title">ClipContext</span> </span>&#123;</div><div class="line">  <span class="comment">//通常只会被 PaintingContext.repaintCompositedChild 和pushLayer 调用</span></div><div class="line">  <span class="meta">@protected</span></div><div class="line">  PaintingContext(<span class="keyword">this</span>._containerLayer, <span class="keyword">this</span>.estimatedBounds)</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="keyword">void</span> repaintCompositedChild(RenderObject child, &#123; <span class="built_in">bool</span> debugAlsoPaintedParent = <span class="keyword">false</span> &#125;) &#123;</div><div class="line">    _repaintCompositedChild(</div><div class="line">      child,</div><div class="line">      debugAlsoPaintedParent: debugAlsoPaintedParent,</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _repaintCompositedChild(</div><div class="line">    RenderObject child, &#123;</div><div class="line">    <span class="built_in">bool</span> debugAlsoPaintedParent = <span class="keyword">false</span>,</div><div class="line">    PaintingContext childContext,</div><div class="line">  &#125;) &#123;</div><div class="line">    OffsetLayer childLayer = child._layer <span class="keyword">as</span> OffsetLayer;</div><div class="line">    <span class="keyword">if</span> (childLayer == <span class="keyword">null</span>) &#123;</div><div class="line">     	<span class="comment">//RenderObject的默认Layer类型是OffsetLayer，记录坐标相对偏移值</span></div><div class="line">      child._layer = childLayer = OffsetLayer();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      childLayer.removeAllChildren();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//构建一个新的PaintingContext</span></div><div class="line">    childContext ??= PaintingContext(child._layer, child.paintBounds);</div><div class="line">    <span class="comment">//开始绘制，默认Offset偏移量是0</span></div><div class="line">    child._paintWithContext(childContext, Offset.zero);</div><div class="line">    <span class="comment">//</span></div><div class="line">    childContext.stopRecordingIfNeeded();</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PaintingContext作为canvas的持有者，作为参数传递给RenderObject，这样RenderObject对象通过context.canvas可以取到Canvas对象，可以调用canvas相关API实现绘制操作。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/object.dart RenderObject</span></div><div class="line">	<span class="keyword">void</span> _paintWithContext(PaintingContext context, Offset offset) &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">//_needsPaint置为false，当遍历到更高节点向下绘制时起到隔离作用</span></div><div class="line">    _needsPaint = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      paint(context, offset);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123; &#125;</div></pre></td></tr></table></figure>
<p>首先把<code>_needsPaint</code>置为false，当遍历到更高节点向下绘制时起到隔离作用，后面详细讲。</p>
<p>RenderObject的paint()方法是一个抽象方法，需要子类去实现。</p>
<p>如果一个RenderObject含有子节点，那么除了自身可能需要绘制外，还需要遍历子节点进行绘制。</p>
<p>以RenderStack为例看下实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/stack.dart RenderStack</span></div><div class="line">  <span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;</div><div class="line">    ...</div><div class="line">    paintStack(context, offset);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@protected</span></div><div class="line">  <span class="keyword">void</span> paintStack(PaintingContext context, Offset offset) &#123;</div><div class="line">    defaultPaint(context, offset);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">void</span> defaultPaint(PaintingContext context, Offset offset) &#123;</div><div class="line">    ChildType child = firstChild;</div><div class="line">    <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">final</span> ParentDataType childParentData = child.parentData <span class="keyword">as</span> ParentDataType;</div><div class="line">      context.paintChild(child, childParentData.offset + offset);</div><div class="line">      child = childParentData.nextSibling;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>由于RenderStack本身没有内容需要绘制，所以直接遍历子节点调用context.paintChild方法绘制子节点。</p>
<p>同时将Layout阶段子节点存储的位置和大小信息parentData取出来，加上自身偏移传递给子节点，parentData是layout阶段计算出的位置信息。</p>
<p>所以通过 <code>paint()-&gt; paintChild() -&gt; paint() -&gt;stopRecordingIfNeeded()</code> …调用栈完成<strong>局部树</strong>的刷新。</p>
<p>为什么说是<strong>局部树</strong> ？因为有<code>isRepaintBoundary</code>的存在，每个局部树代表一个<strong>图层</strong>，下面详细分析。</p>
<h1 id="4、LayerTree"><a href="#4、LayerTree" class="headerlink" title="4、LayerTree"></a>4、LayerTree</h1><h2 id="4-1、RepaintBoundary-绘制边界"><a href="#4-1、RepaintBoundary-绘制边界" class="headerlink" title="4.1、RepaintBoundary 绘制边界"></a>4.1、RepaintBoundary 绘制边界</h2><p>当_nodesNeedingPaint列表中，深度优先的节点绘制完成后，调用childContext.stopRecordingIfNeeded()方法完成当前局部树的绘制，并记录在Flutter Engine对应Layer的Picture对象中（这块后面再分析）。</p>
<p>然后继续遍历_nodesNeedingPaint中的节点。</p>
<p>由于是深度优先，所以后续被遍历到的节点，可能是已完成绘制节点的祖先节点，那么再去paintChild，会不会再次触发已完成绘制节点的绘制动作？</p>
<p>答案是不会，因为有<code>isRepaintBoundary</code>的存在。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/object.dart PaintingContext</span></div><div class="line">	<span class="keyword">void</span> paintChild(RenderObject child, Offset offset) &#123;</div><div class="line">    <span class="keyword">if</span> (child.isRepaintBoundary) &#123;</div><div class="line">      <span class="comment">//结束绘制，记录到Picture</span></div><div class="line">      stopRecordingIfNeeded();</div><div class="line">      <span class="comment">//合成子Layer</span></div><div class="line">      _compositeChild(child, offset);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//使用相同PaintingContext绘制子节点</span></div><div class="line">      child._paintWithContext(<span class="keyword">this</span>, offset);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">void</span> _compositeChild(RenderObject child, Offset offset) &#123;</div><div class="line">    <span class="comment">// 如果需要绘制，为子节点新建一个layer并绘制</span></div><div class="line">    <span class="keyword">if</span> (child._needsPaint) &#123;</div><div class="line">      repaintCompositedChild(child, debugAlsoPaintedParent: <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> OffsetLayer childOffsetLayer = child._layer <span class="keyword">as</span> OffsetLayer;</div><div class="line">    childOffsetLayer.offset = offset;</div><div class="line">    appendLayer(child._layer);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>当<code>isRepaintBoundary</code>为false时，正常遍历子节点绘制。</p>
<p>比如首次绘制第一帧时，从根节点RenderView开始从上到下遍历绘制。</p>
<p>当子节点记录为<code>isRepaintBoundary</code>（即之前已经绘制完成的子节点）时，调用<code>_compositeChild</code>方法。</p>
<p>此时<code>child._needsPaint</code>实际上已经为false。</p>
<p>所以直接调用<code>appendLayer()</code>方法合并子节点所在的Layer图层，添加到当前节点所在Layer的子节点，生成一颗<code>LayerTree</code>，同时触发 <code>markNeedsAddToScene()</code>标脏方法，用于合成阶段的标脏操作，下篇文章会详细介绍。</p>
<p>所以，markNeedsPaint() 从叶子节点向上遍历寻找绘制边界，触发局部绘制。</p>
<p><strong>flushPaint()深度优先逆序遍历，找到绘制边界把当前节点作为祖先节点，从上到下绘制局部树。</strong>最后绘制RenderView根节点（如果需要）。</p>
<p>每个<code>isRepaintBoundary</code>为true的RendeObject，都会生成一个新的图层，其所有的子节点都会被绘制在这个新的图层中。</p>
<p>Flutter 使用Layer图层来记录一个层次上所有的RenderObject的绘制过程，每个图层独立刷新，互不影响。</p>
<p>Layer 是上篇文章中提到的<code>AbstractNode</code>的子类，它是实现Tree的基类，RenderObject也是其子类。</p>
<p>Layer和RenderObject存在 1:N的对应关系。</p>
<p>所以，也就是说RepaintBoundary Widget可以控制刷新范围，这也是为什么使用RepaintBoundary Widget可以提高绘制性能的真正原因。</p>
<h2 id="4-2、PaintingContext-amp-Canvas-绘制"><a href="#4-2、PaintingContext-amp-Canvas-绘制" class="headerlink" title="4.2、PaintingContext &amp; Canvas 绘制"></a>4.2、PaintingContext &amp; Canvas 绘制</h2><p>具体绘制时，通过PaintingContext获取Canvas，调用Canvas的API接口执行具体的绘制操作，看下Canvas对象的获取逻辑</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/object.dart PaintingContext</span></div><div class="line"> <span class="meta">@override</span></div><div class="line">	<span class="comment">//初始化</span></div><div class="line">  Canvas <span class="keyword">get</span> canvas &#123;</div><div class="line">    <span class="keyword">if</span> (_canvas == <span class="keyword">null</span>)</div><div class="line">      _startRecording();</div><div class="line">    <span class="keyword">return</span> _canvas;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">	<span class="comment">//开始绘制</span></div><div class="line">  <span class="keyword">void</span> _startRecording() &#123;</div><div class="line">    <span class="comment">//isRecording的判断标准是canvas是否为空</span></div><div class="line">    <span class="keyword">assert</span>(!_isRecording);</div><div class="line">    <span class="comment">//构造一个PictureLayer对象，绑定绘制区域</span></div><div class="line">    _currentLayer = PictureLayer(estimatedBounds);</div><div class="line">    <span class="comment">//构造一个PictureRecorder对象，用于记录绘制指令</span></div><div class="line">    _recorder = ui.PictureRecorder();</div><div class="line">    <span class="comment">//构造一个Canvas，依赖PictureRecorder对象</span></div><div class="line">    _canvas = Canvas(_recorder);</div><div class="line">    <span class="comment">//将PictureLayer添加到当前图层的LayerTree中</span></div><div class="line">    _containerLayer.append(_currentLayer);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@protected</span></div><div class="line">  <span class="meta">@mustCallSuper</span></div><div class="line">	<span class="comment">//结束绘制</span></div><div class="line">  <span class="keyword">void</span> stopRecordingIfNeeded() &#123;</div><div class="line">    <span class="keyword">if</span> (!_isRecording)</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">assert</span>(() &#123;</div><div class="line">      <span class="comment">//使用debugRepaintRainbowEnabled显示重绘区域</span></div><div class="line">      <span class="keyword">if</span> (debugRepaintRainbowEnabled) &#123;</div><div class="line">        <span class="keyword">final</span> Paint paint = Paint()</div><div class="line">          ..style = PaintingStyle.stroke</div><div class="line">          ..strokeWidth = <span class="number">6.0</span></div><div class="line">          ..color = debugCurrentRepaintColor.toColor();</div><div class="line">        canvas.drawRect(estimatedBounds.deflate(<span class="number">3.0</span>), paint);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//使用debugPaintLayerBordersEnabled显示当前Layer边界</span></div><div class="line">      <span class="keyword">if</span> (debugPaintLayerBordersEnabled) &#123;</div><div class="line">        <span class="keyword">final</span> Paint paint = Paint()</div><div class="line">          ..style = PaintingStyle.stroke</div><div class="line">          ..strokeWidth = <span class="number">1.0</span></div><div class="line">          ..color = <span class="keyword">const</span> Color(<span class="number">0xFFFF9800</span>);</div><div class="line">        canvas.drawRect(estimatedBounds, paint);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;());</div><div class="line">    <span class="comment">//绘制指令记录在picture对象</span></div><div class="line">    _currentLayer.picture = _recorder.endRecording();</div><div class="line">    <span class="comment">//释放PictureLayer对象</span></div><div class="line">    _currentLayer = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">//释放PictureRecorder对象</span></div><div class="line">    _recorder = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">//释放Canvas对象</span></div><div class="line">    _canvas = <span class="keyword">null</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>做了几件事情：</p>
<ol>
<li>初始化</li>
</ol>
<p>当Layer图层中的RenderObject要使用Canvas对象进行绘制时，初始化一个PictureLayer对象，添加到当前LayerTree中。</p>
<p>初始化一个PictureRecorder对象，绑定到Canvas对象上。</p>
<p>PicutreRecorder实际上是Flutter Engine中的PictureRecorder对象的代理。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//lib/ui/painting/picture_recorder.cc</span></div><div class="line"><span class="comment">//构造入口</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> PictureRecorder_constructor(Dart_NativeArguments args) &#123;</div><div class="line">  UIDartState::ThrowIfUIOperationsProhibited();</div><div class="line">  DartCallConstructor(&amp;PictureRecorder::Create, args);</div><div class="line">&#125;</div><div class="line"></div><div class="line">IMPLEMENT_WRAPPERTYPEINFO(ui, PictureRecorder);</div><div class="line"></div><div class="line">#define FOR_EACH_BINDING(V)       \</div><div class="line">  V(PictureRecorder, isRecording) \</div><div class="line">  V(PictureRecorder, endRecording)</div><div class="line"><span class="comment">//注册Native方法</span></div><div class="line">FOR_EACH_BINDING(DART_NATIVE_CALLBACK)</div><div class="line"><span class="comment">//注册构造方法</span></div><div class="line"><span class="keyword">void</span> PictureRecorder::RegisterNatives(tonic::DartLibraryNatives* natives) &#123;</div><div class="line">  natives-&gt;Register(</div><div class="line">      &#123;&#123;<span class="string">"PictureRecorder_constructor"</span>, PictureRecorder_constructor, <span class="number">1</span>, <span class="keyword">true</span>&#125;,</div><div class="line">       FOR_EACH_BINDING(DART_REGISTER_NATIVE)&#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">//构造方法</span></div><div class="line">fml::RefPtr&lt;PictureRecorder&gt; PictureRecorder::Create() &#123;</div><div class="line">  <span class="keyword">return</span> fml::MakeRefCounted&lt;PictureRecorder&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">bool</span> PictureRecorder::isRecording() &#123;</div><div class="line">  <span class="keyword">return</span> canvas_ &amp;&amp; canvas_-&gt;IsRecording();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//通过SkPictureRecorder构造SkCanvas，picture_recorder_是SkPictureRecorder对象</span></div><div class="line">SkCanvas* PictureRecorder::BeginRecording(SkRect bounds) &#123;</div><div class="line">  <span class="keyword">return</span> picture_recorder_.beginRecording(bounds, &amp;rtree_factory_);</div><div class="line">&#125;</div><div class="line"></div><div class="line">fml::RefPtr&lt;Picture&gt; PictureRecorder::endRecording(Dart_Handle dart_picture) &#123;</div><div class="line">  <span class="comment">//构造SkPicture对象</span></div><div class="line">  fml::RefPtr&lt;Picture&gt; picture =</div><div class="line">      Picture::Create(dart_picture,</div><div class="line">                      UIDartState::CreateGPUObject(</div><div class="line">                          picture_recorder_.finishRecordingAsPicture()),</div><div class="line">                      canvas_-&gt;external_allocation_size());</div><div class="line">	<span class="comment">//清理工作</span></div><div class="line">  canvas_-&gt;Clear();</div><div class="line">  canvas_-&gt;ClearDartWrapper();</div><div class="line">  canvas_ = nullptr;</div><div class="line">  ClearDartWrapper();</div><div class="line">  <span class="keyword">return</span> picture;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样的，Dart Framework的Canvas对象实际上是Flutter Engine中Canvas对象的代理。</p>
<p>Flutter Engine中的Canvas：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/ui/painting/canvas.cc</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Canvas_constructor</span><span class="params">(Dart_NativeArguments args)</span> </span>&#123;</div><div class="line">  UIDartState::ThrowIfUIOperationsProhibited();</div><div class="line">  DartCallConstructor(&amp;Canvas::Create, args);</div><div class="line">&#125;</div><div class="line"></div><div class="line">IMPLEMENT_WRAPPERTYPEINFO(ui, Canvas);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_EACH_BINDING(V)         \</span></div><div class="line">  V(Canvas, save)                   \</div><div class="line">  V(Canvas, saveLayerWithoutBounds) \</div><div class="line">  V(Canvas, saveLayer)              \</div><div class="line">  V(Canvas, restore)                \</div><div class="line">  V(Canvas, getSaveCount)           \</div><div class="line">  V(Canvas, translate)              \</div><div class="line">  V(Canvas, scale)                  \</div><div class="line">  V(Canvas, rotate)                 \</div><div class="line">  V(Canvas, skew)                   \</div><div class="line">  V(Canvas, transform)              \</div><div class="line">  V(Canvas, clipRect)               \</div><div class="line">  V(Canvas, clipRRect)              \</div><div class="line">  V(Canvas, clipPath)               \</div><div class="line">  V(Canvas, drawColor)              \</div><div class="line">  V(Canvas, drawLine)               \</div><div class="line">  V(Canvas, drawPaint)              \</div><div class="line">  V(Canvas, drawRect)               \</div><div class="line">  V(Canvas, drawRRect)              \</div><div class="line">  V(Canvas, drawDRRect)             \</div><div class="line">  V(Canvas, drawOval)               \</div><div class="line">  V(Canvas, drawCircle)             \</div><div class="line">  V(Canvas, drawArc)                \</div><div class="line">  V(Canvas, drawPath)               \</div><div class="line">  V(Canvas, drawImage)              \</div><div class="line">  V(Canvas, drawImageRect)          \</div><div class="line">  V(Canvas, drawImageNine)          \</div><div class="line">  V(Canvas, drawPicture)            \</div><div class="line">  V(Canvas, drawPoints)             \</div><div class="line">  V(Canvas, drawVertices)           \</div><div class="line">  V(Canvas, drawAtlas)              \</div><div class="line">  V(Canvas, drawShadow)</div><div class="line">  ...</div><div class="line"></div><div class="line"><span class="comment">//注册Canvas API方法</span></div><div class="line">FOR_EACH_BINDING(DART_NATIVE_CALLBACK)</div><div class="line"></div><div class="line"><span class="comment">//注册Native构造方法</span></div><div class="line"><span class="keyword">void</span> Canvas::RegisterNatives(tonic::DartLibraryNatives* natives) &#123;</div><div class="line">  natives-&gt;Register(&#123;&#123;<span class="string">"Canvas_constructor"</span>, Canvas_constructor, <span class="number">6</span>, <span class="literal">true</span>&#125;,</div><div class="line">                     FOR_EACH_BINDING(DART_REGISTER_NATIVE)&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">fml::RefPtr&lt;Canvas&gt; Canvas::Create(PictureRecorder* recorder,</div><div class="line">                                   <span class="keyword">double</span> left,</div><div class="line">                                   <span class="keyword">double</span> top,</div><div class="line">                                   <span class="keyword">double</span> right,</div><div class="line">                                   <span class="keyword">double</span> bottom) &#123;</div><div class="line">  ...</div><div class="line">  <span class="comment">//通过PictureRecoder的begin方法，构造SkCanvas对象</span></div><div class="line">  fml::RefPtr&lt;Canvas&gt; canvas = fml::MakeRefCounted&lt;Canvas&gt;(</div><div class="line">      recorder-&gt;BeginRecording(SkRect::MakeLTRB(left, top, right, bottom)));</div><div class="line">  recorder-&gt;set_canvas(canvas);</div><div class="line">  <span class="keyword">return</span> canvas;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Canvas::Canvas(SkCanvas* canvas) : canvas_(canvas) &#123;&#125;</div></pre></td></tr></table></figure>
<p>实际上Flutter Engine中的对象都是Skia引擎的代理对象，最终实现绘制的是Skia引擎中的SkCanvas对象。</p>
<p>所有的Dart Framework层的Canvas绘制操作，都会通过Flutter Engine层的Canvas代理类，最终调用到SkCanvas去实际绘制。</p>
<ol>
<li>绘制</li>
</ol>
<p>当使用Canvas对象绘制时，绘制的指令都会被记录在Flutter Engine 的SkPictureRecorder对象中。</p>
<ol>
<li>结束绘制</li>
</ol>
<p>当结束当前Layer图层的绘制流程时，调用_recorder.endRecording()获取一个SkPicture对象，SkPicture对象包含了所有的绘制指令，并写入PictureLayer中。</p>
<p>至此所有的Layer图层绘制完成，形成一颗含有所有绘制操作记录的LayerTree。</p>
<p>并且，在当前LayerTree中，每个用到Canvas绘制的Layer图层的同层级中，总是有<strong>一个或多个</strong>PictureLayer，用来记录绘制信息。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/layer.dart PictureLayer</span></div><div class="line">	<span class="keyword">set</span> picture(ui.Picture picture) &#123;</div><div class="line">    markNeedsAddToScene();</div><div class="line">    _picture = picture;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>最后调用markNeedsAddToScene()标记该Layer的_needsAddToScene为true，为接下来的renderView.compositeFrame()做准备。</p>
<h2 id="4-3、-needsCompositing-的作用"><a href="#4-3、-needsCompositing-的作用" class="headerlink" title="4.3、_needsCompositing 的作用"></a>4.3、_needsCompositing 的作用</h2><p>在markNeedsCompositingBitsUpdate()标记阶段，记录了RenderObject的_needsCompositing是否需要合成的标志位。</p>
<p>其原理是，当一个RenderObject节点是isRepaintBoundary || alwaysNeedsCompositing，那么它及其所有的祖先节点都会被标记为_needsCompositing。</p>
<p>这个标志位的作用在PaintingContext中的pushXXX特殊绘制相关方法中会用到，用于标识是否需要新建一个Layer图层来实现一些特定的图形效果，比如裁剪，变换等。</p>
<p>以pushClipRect裁剪方法为例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/object.dart PaintingContext</span></div><div class="line">	ClipRectLayer pushClipRect(<span class="built_in">bool</span> needsCompositing, Offset offset, Rect clipRect, PaintingContextCallback painter, &#123; Clip clipBehavior = Clip.hardEdge, ClipRectLayer oldLayer &#125;) &#123;</div><div class="line">    <span class="keyword">final</span> Rect offsetClipRect = clipRect.shift(offset);</div><div class="line">    <span class="comment">//需要合成</span></div><div class="line">    <span class="keyword">if</span> (needsCompositing) &#123;</div><div class="line">      <span class="comment">//新建一个ClipRectLayer图层，会被重复使用</span></div><div class="line">      <span class="keyword">final</span> ClipRectLayer layer = oldLayer ?? ClipRectLayer();</div><div class="line">      <span class="comment">//Layer裁剪范围和裁剪信息</span></div><div class="line">      layer</div><div class="line">        ..clipRect = offsetClipRect</div><div class="line">        ..clipBehavior = clipBehavior;</div><div class="line">      <span class="comment">//将新建的Layer 添加到LayerTree，并在其上进行绘制</span></div><div class="line">      pushLayer(layer, painter, offset, childPaintBounds: offsetClipRect);</div><div class="line">      <span class="keyword">return</span> layer;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//直接在原有Canvas上裁剪、绘制</span></div><div class="line">      clipRectAndPaint(offsetClipRect, clipBehavior, offsetClipRect, () =&gt; painter(<span class="keyword">this</span>, offset));</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">void</span> pushLayer(ContainerLayer childLayer, PaintingContextCallback painter, Offset offset, &#123; Rect childPaintBounds &#125;) &#123;</div><div class="line">    <span class="comment">//图层如果被复用，清空</span></div><div class="line">    <span class="keyword">if</span> (childLayer.hasChildren) &#123;</div><div class="line">      childLayer.removeAllChildren();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//结束当前PaintingContext绘制，记录到PictureLayer中的SkPicture</span></div><div class="line">    stopRecordingIfNeeded();</div><div class="line">    <span class="comment">//将新Layer添加到LLayerTree    appendLayer(childLayer);</span></div><div class="line">    <span class="comment">//为childLayer新建PaintingContext，持有独立Canvas</span></div><div class="line">    <span class="keyword">final</span> PaintingContext childContext = createChildContext(childLayer, childPaintBounds ?? estimatedBounds);</div><div class="line">    <span class="comment">//开始绘制</span></div><div class="line">    painter(childContext, offset);</div><div class="line">    <span class="comment">//绘制完成，childLayer绘制操作记录到PictureLayer中的SkPicture</span></div><div class="line">    childContext.stopRecordingIfNeeded();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>如果被标记为合成，那么就新建一个Layer，设置裁剪信息，并绑定到新的PaintingContext上，持有独立的Canvas，进行特殊效果绘制。</p>
<p>使用方是RenderClipRect.paint()</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/proxy_box.dart RenderClipRect</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderClipRect</span> <span class="keyword">extends</span> <span class="title">_RenderCustomClip</span>&lt;<span class="title">Rect</span>&gt; </span>&#123;</div><div class="line">  <span class="comment">/// Creates a rectangular clip.</span></div><div class="line">  <span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;</div><div class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</div><div class="line">      _updateClip();</div><div class="line">      <span class="comment">//调用pushClipRect方法</span></div><div class="line">      layer = context.pushClipRect(</div><div class="line">        needsCompositing,<span class="comment">//在markNeedsCompositingBitsUpdate被标记</span></div><div class="line">        offset,</div><div class="line">        _clip,</div><div class="line">        <span class="keyword">super</span>.paint,</div><div class="line">        clipBehavior: clipBehavior,</div><div class="line">        oldLayer: layer <span class="keyword">as</span> ClipRectLayer,</div><div class="line">      );</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      layer = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><strong>思考一下为什么子节点在独立图层上绘制，这些特殊绘制操作也需要在独立图层上绘制？</strong></p>
<p>先看下不独立绘制，直接在原有Canvas上裁剪、绘制的实现</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/clip.dart ClipContext</span></div><div class="line">	<span class="keyword">void</span> clipRectAndPaint(Rect rect, Clip clipBehavior, Rect bounds, <span class="keyword">void</span> painter()) &#123;</div><div class="line">    _clipAndPaint((<span class="built_in">bool</span> doAntiAias) =&gt; canvas.clipRect(rect, doAntiAlias: doAntiAias), clipBehavior, bounds, painter);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">void</span> _clipAndPaint(<span class="keyword">void</span> canvasClipCall(<span class="built_in">bool</span> doAntiAlias), Clip clipBehavior, Rect bounds, <span class="keyword">void</span> painter()) &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="keyword">case</span> hardEdge:</div><div class="line">    		<span class="comment">//保存状态</span></div><div class="line">    		canvas.save();</div><div class="line">    		<span class="comment">//裁剪操作</span></div><div class="line">    		canvasClipCall(<span class="keyword">false</span>);</div><div class="line">    		<span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> Clip.antiAliasWithSaveLayer:</div><div class="line">        canvasClipCall(<span class="keyword">true</span>);</div><div class="line">        canvas.saveLayer(bounds, Paint());</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    ...</div><div class="line">    <span class="comment">//绘制</span></div><div class="line">    painter();</div><div class="line">    <span class="comment">//恢复状态</span></div><div class="line">    canvas.restore();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里就明白了，在子节点没有独立绘制情况下，裁剪操作需要做到在不影响子节点绘制的情况下，借助canvas的<code>save()</code>和<code>restore()</code>方法来实现。</p>
<p>并且在一些场景下会触发<strong>saveLayer，也就是离屏渲染，这个操作对性能影响巨大</strong>。</p>
<p>而在子节点在独立图层绘制的情况下，特殊效果绘制也就在新建的独立图层上绘制就好了，不用再<code>save()</code>和<code>restore()</code>了，更不用saveLayer了，对性能更友好。</p>
<p>并且由于裁剪等特殊绘制在独立图层的存在，可以把绘制范围切分的更细粒度，而在Flutter Engine里对于图层是有缓存的，也可以提高绘制性能。</p>
<h2 id="4-4、Layer-种类"><a href="#4-4、Layer-种类" class="headerlink" title="4.4、Layer 种类"></a>4.4、Layer 种类</h2><p>Layer 大体上分为两种类型，ContainerLayer 和非ContainerLayer：</p>
<ul>
<li>非ContainerLayer，用于绘制，一般为LayerTree每一层的尾节点，也有可能在中间节点，比如stopRecording后，再appendLayer<ul>
<li>PictureLayer，用于记录一般绘制操作，大部分RenderObject都是绘制在这上面</li>
<li>TextureLayer，主要用于外接纹理绘制，对应的RenderObject是TextureBox，Widget 是 Texture</li>
<li>PlatformViewLayer，用于嵌入平台 (Android、iOS) 纹理绘制，对应的RenderObject是PlatformViewRenderBox，Widget 是 PlatformViewSurface</li>
</ul>
</li>
<li>ContainerLayer，本身不具备绘制能力，一般用于添加非ContainerLayer，形成LayerTree<ul>
<li>ClipRectLayer、ClipRRectLayer、ClipPathLayer，裁剪层，可以指定裁剪和矩形行为参数。共有4种裁剪行为，none、hardEdge、antiAlias、antiAliashWithSaveLayer（会触发SaveLayer）</li>
<li>OffsetLayer，偏移层，可以指定坐标偏移量</li>
<li>TransformLayer，变换图层，可以指定变换矩阵参数</li>
<li>OpacityLayer，透明层，可以指定透明度</li>
<li>PhysicalModelLayer，透明层，可以指定透明度</li>
<li>ColorFilterLayer，颜色过滤层，可以指定颜色和混合模式参数</li>
<li>BackdropFilterLayer：背景过滤层，可以指定背景图参数</li>
</ul>
</li>
</ul>
<h1 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h1><p>本文主要分析了合成标记、paint绘制、LayerTree等相关内容，下篇文章继续分析具体的合成阶段。</p>
<p>本文链接： <a href="http://w4lle.com/2021/02/01/flutter-ui-paint/">http://w4lle.com/2021/02/01/flutter-ui-paint/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;系列文章的第六篇，本篇文章继续分析下Paint绘制过程及Layer Tree。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://w4lle.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter UI 渲染浅析（五）Layout</title>
    <link href="http://w4lle.com/2021/01/15/flutter-ui-layout/"/>
    <id>http://w4lle.com/2021/01/15/flutter-ui-layout/</id>
    <published>2021-01-15T01:59:52.000Z</published>
    <updated>2021-01-15T10:47:05.108Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章的第五篇，本篇文章主要分析下 Render Tree 的构建及 Layout 过程。</p>
<a id="more"></a>
<p>在上篇文章结尾，提到 <code>RenderObjectElement.attachRenderObject()</code> 方法中调用 <code>RenderObjectElement.insertChildRenderObject(renderObject, newSlot)</code> 将 RenderObject 插入 Render Tree中，继续分析下 Render Tree 的构建过程及 <code>RendererBinding.drawFrame()</code> 过程。</p>
<p>在开始之前，先看下 RenderObject 和 RenderTree。</p>
<h1 id="1、RenderObject"><a href="#1、RenderObject" class="headerlink" title="1、RenderObject"></a>1、RenderObject</h1><p>RenderObject 是 Render Tree 的构成节点，主要负责布局和绘制。</p>
<p>前面提到过，并不是所有的 Element 都会持有 RenderObject 的引用，只有 RenderObjectWidget 及其对应 RenderObjectElement 才会创建 RenderObject。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20210115184016.png" alt=""></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> <span class="keyword">extends</span> <span class="title">AbstractNode</span> <span class="title">with</span> <span class="title">DiagnosticableTreeMixin</span> <span class="keyword">implements</span> <span class="title">HitTestTarget</span> </span>&#123;</div></pre></td></tr></table></figure>
<p>RenderObject 继承自 <code>AbstractNode</code> ，<code>AbstractNode</code> 是树形节点定义，持有 <code>parent</code> 引用，提供了挂载 <code>adoptChild()</code>、卸载 <code>dropChild()</code>、计算深度 <code>redepthChildren()</code> 等方法。</p>
<p>同时持有 <code>ParentData</code> 对象，可以存放子节点的一些特定信息，比如布局信息等。</p>
<p>下篇文章要分析的 <code>Layer</code> 也是 <code>AbstractNode</code> 的子类。</p>
<p>RenderObject 混入了 <code>HitTestTarget</code>，<code>HitTestTarget</code> 提供了处理事件的能力。</p>
<p>RenderObject 定义了通用的布局和绘制协议。</p>
<p>但是没有定义坐标系统，例如子节点是布局在笛卡尔坐标系，还是极坐标系。</p>
<p>也没有指定具体的布局协议，例如是通过宽高，还是通过约束和大小，或者父节点在子节点的布局前后设置位置和大小。</p>
<p>或者子节点是否允许方法其自身的 <code>ParentDara</code> 对象信息。</p>
<p>也没有定义子树模型，比如其是否支持挂载子节点，允许挂载几个子节点等，这些能力由RenderObject 子类 mixin 提供。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20201119112445.png" alt=""></p>
<p>RenderObject 的子类中</p>
<ul>
<li><code>mixin RenderObjectWithChildMixin&lt;ChildType extends RenderObject&gt;</code> 定义了允许挂载<strong>一个子节点</strong>的实现</li>
<li><code>mixin ContainerRenderObjectMixin&lt;ChildType extends RenderObject, ParentDataType extends ContainerParentDataMixin&lt;ChildType&gt;&gt;</code> 定义了允许挂载<strong>多个子节点</strong>的实现</li>
<li>RenderView 是根节点，用于App启动初始化Widget、Element、RenderObject、Layer，绘制完成后将Layer Tree 提交给 Engine</li>
<li>RenderBox 是最重要的一个子类，其实现了基于 2D 笛卡尔坐标系的布局方式，其中的 Offset 定义距父布局的偏移量 x、y，Size 定义了该控件的大小。这种布局方式是和 Android、iOS 原生布局一致的。约束模型对应 BoxConstraints 盒约束</li>
<li>RenderSlive 实现了支持滑动效果的布局方式，可以通过 ViewViewPort 内嵌到 RenderBox 中，约束模型对应于 SliverConstraints 分片约束</li>
</ul>
<p>RenderObject类型、Constraints类型和ParentData类型对应关系如下：</p>
<table>
<thead>
<tr>
<th>RenderObject  类型</th>
<th>Constraints类型</th>
<th>ParentData类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>RenderBox</td>
<td>BoxConstraints</td>
<td>BoxParentData</td>
</tr>
<tr>
<td>RenderSlive</td>
<td>SliverConstraints</td>
<td>SliverLogicalParentData</td>
</tr>
</tbody>
</table>
<h1 id="2、RenderTree-构建"><a href="#2、RenderTree-构建" class="headerlink" title="2、RenderTree 构建"></a>2、RenderTree 构建</h1><p>继续分析上篇文章的结尾部分 <code>RenderObjectElement.insertChildRenderObject()</code> 。</p>
<p>在Flutter v1.21 及以上版本上，该方法被废弃，使用 <code>RenderObjectElement.insertRenderObjectChild(renderObject, newSlot);</code> 代替。</p>
<p>该方法是个空方法，需要子类实现。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectElement</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;  </div><div class="line">  <span class="meta">@protected</span></div><div class="line">  <span class="keyword">void</span> insertRenderObjectChild(covariant RenderObject child, covariant <span class="keyword">dynamic</span> slot) &#123;</div><div class="line">    insertChildRenderObject(child, slot);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以单子节点和多子节点Element为例，看下构建流程。</p>
<h2 id="2-1、单子节点"><a href="#2-1、单子节点" class="headerlink" title="2.1、单子节点"></a>2.1、单子节点</h2><p>单子节点实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleChildRenderObjectElement</span> <span class="keyword">extends</span> <span class="title">RenderObjectElement</span> </span>&#123;</div><div class="line">  <span class="meta">@override</span></div><div class="line">  SingleChildRenderObjectWidget <span class="keyword">get</span> widget =&gt; <span class="keyword">super</span>.widget <span class="keyword">as</span> SingleChildRenderObjectWidget;</div><div class="line">  </div><div class="line">  ...</div><div class="line">    </div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> insertRenderObjectChild(RenderObject child, <span class="keyword">dynamic</span> slot) &#123;</div><div class="line">    <span class="keyword">final</span> RenderObjectWithChildMixin&lt;RenderObject&gt; renderObject = <span class="keyword">this</span>.renderObject <span class="keyword">as</span> RenderObjectWithChildMixin&lt;RenderObject&gt;;</div><div class="line">    renderObject.child = child;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>获取 Element.mount() 过程中通过 <code>Widget.createRenderObject()</code> 已经构建好的 RenderObject</li>
<li>将 RenderObject 挂载到 Render Tree</li>
</ul>
<p>SingleChildRenderObjectElement 通过 <code>SingleChildRenderObjectWidget.createElement()</code>创建。</p>
<p>SingleChildRenderObjectWidget 的子类包括：</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20201218175314.png" alt=""></p>
<p>对应的RenderObject 通过 <code>SingleChildRenderObjectWidget.createRenderObject()</code> 创建，创建出的 RenderObject 混入了 RenderObjectWithChildMixin。</p>
<p>上面提到 RenderObjectWithChildMixin 定义了允许挂载<strong>一个子节点</strong>的实现。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">mixin RenderObjectWithChildMixin&lt;ChildType <span class="keyword">extends</span> RenderObject&gt; on RenderObject &#123;</div><div class="line">	<span class="keyword">set</span> child(ChildType? value) &#123;</div><div class="line">    <span class="keyword">if</span> (_child != <span class="keyword">null</span>)</div><div class="line">      <span class="comment">// 卸载老节点</span></div><div class="line">      dropChild(_child!);</div><div class="line">    <span class="comment">// 更新子节点引用</span></div><div class="line">    _child = value;</div><div class="line">    <span class="keyword">if</span> (_child != <span class="keyword">null</span>)</div><div class="line">      <span class="comment">// 挂载新节点</span></div><div class="line">      adoptChild(_child!);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> <span class="keyword">extends</span> <span class="title">AbstractNode</span> <span class="title">with</span> <span class="title">DiagnosticableTreeMixin</span> <span class="keyword">implements</span> <span class="title">HitTestTarget</span> </span>&#123;</div><div class="line">  <span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> adoptChild(RenderObject child) &#123;</div><div class="line">    <span class="comment">// 初始化 ParentData</span></div><div class="line">    setupParentData(child);</div><div class="line">    <span class="comment">// Layout标脏</span></div><div class="line">    markNeedsLayout();</div><div class="line">    <span class="comment">// 合成位标脏</span></div><div class="line">    markNeedsCompositingBitsUpdate();</div><div class="line">    <span class="comment">// 辅助信息Semantic标脏</span></div><div class="line">    markNeedsSemanticsUpdate();</div><div class="line">    <span class="comment">// 调用AbstractNode.adoptChild()，挂载到 Render Tree，将child.parent指向自己，更新树的深度</span></div><div class="line">    <span class="keyword">super</span>.adoptChild(child);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>卸载老节点</li>
<li>更新子节点引用</li>
<li>调用 <code>RenderObject.adoptChild()</code> 挂载新节点<ul>
<li>初始化 ParentData</li>
<li>markNeedsLayout Layout标脏</li>
<li>markNeedsCompositingBitsUpdate 合成位标脏</li>
<li>markNeedsSemanticsUpdate 辅助信息Semantic标脏</li>
<li>调用AbstractNode.adoptChild()，挂载到 Render Tree，将child.parent指向自己，更新树的深度</li>
</ul>
</li>
</ul>
<h2 id="2-2、多子节点实现"><a href="#2-2、多子节点实现" class="headerlink" title="2.2、多子节点实现"></a>2.2、多子节点实现</h2><p>以 MultiChildRenderObject 为例，看下多子节点实现。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiChildRenderObjectElement</span> <span class="keyword">extends</span> <span class="title">RenderObjectElement</span> </span>&#123;</div><div class="line">	<span class="meta">@override</span></div><div class="line">  MultiChildRenderObjectWidget <span class="keyword">get</span> widget =&gt; <span class="keyword">super</span>.widget <span class="keyword">as</span> MultiChildRenderObjectWidget;</div><div class="line"></div><div class="line">  <span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> insertRenderObjectChild(RenderObject child, IndexedSlot&lt;<span class="built_in">Element</span>&gt; slot) &#123;</div><div class="line">    <span class="keyword">final</span> ContainerRenderObjectMixin&lt;RenderObject, ContainerParentDataMixin&lt;RenderObject&gt;&gt; renderObject =</div><div class="line">      <span class="keyword">this</span>.renderObject <span class="keyword">as</span> ContainerRenderObjectMixin&lt;RenderObject, ContainerParentDataMixin&lt;RenderObject&gt;&gt;;</div><div class="line">    renderObject.insert(child, after: slot?.value?.renderObject);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>获取 Element.mount() 过程中通过 <code>Widget.createRenderObject()</code> 已经构建好的 RenderObject</li>
<li>将 RenderObject 挂载到 Render Tree</li>
</ul>
<p>MultiChildRenderObjectElement 通过 <code>MultiChildRenderObjectWidget.createElement()</code>创建。MultiChildRenderObjectWidget 的子类包含：</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20201218174819.png" alt=""></p>
<p>定义了多子节点实现，最终调用 ContainerParentDataMixin 将 RenderObject 挂载到 Render Tree 上。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">mixin ContainerRenderObjectMixin&lt;ChildType <span class="keyword">extends</span> RenderObject, ParentDataType <span class="keyword">extends</span> ContainerParentDataMixin&lt;ChildType&gt;&gt; on RenderObject &#123;</div><div class="line"></div><div class="line">	<span class="keyword">void</span> insert(ChildType child, &#123; ChildType? after &#125;) &#123;</div><div class="line">    adoptChild(child);</div><div class="line">    _insertIntoChildList(child, after: after);</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">  <span class="keyword">void</span> _insertIntoChildList(ChildType child, &#123; ChildType? after &#125;) &#123;</div><div class="line">    <span class="keyword">final</span> ParentDataType childParentData = child.parentData <span class="keyword">as</span> ParentDataType;</div><div class="line">    _childCount += <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (after == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// 依附的兄弟节点为空，插入在第一个子节点</span></div><div class="line">      childParentData.nextSibling = _firstChild;</div><div class="line">      <span class="keyword">if</span> (_firstChild != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">final</span> ParentDataType _firstChildParentData = _firstChild!.parentData <span class="keyword">as</span> ParentDataType;</div><div class="line">        _firstChildParentData.previousSibling = child;</div><div class="line">      &#125;</div><div class="line">      _firstChild = child;</div><div class="line">      _lastChild ??= child;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">final</span> ParentDataType afterParentData = after.parentData <span class="keyword">as</span> ParentDataType;</div><div class="line">      <span class="keyword">if</span> (afterParentData.nextSibling == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 依附的兄弟节点没有相关联的下一个兄弟节点，插入在兄弟节点队尾</span></div><div class="line">        childParentData.previousSibling = after;</div><div class="line">        afterParentData.nextSibling = child;</div><div class="line">        _lastChild = child;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 依附的兄弟节点有相关联的下一个兄弟节点，插入在兄弟节点中间</span></div><div class="line">        childParentData.nextSibling = afterParentData.nextSibling;</div><div class="line">        childParentData.previousSibling = after;</div><div class="line">        <span class="comment">// set up links from siblings to child</span></div><div class="line">        <span class="keyword">final</span> ParentDataType childPreviousSiblingParentData = childParentData.previousSibling!.parentData <span class="keyword">as</span> ParentDataType;</div><div class="line">        <span class="keyword">final</span> ParentDataType childNextSiblingParentData = childParentData.nextSibling!.parentData <span class="keyword">as</span> ParentDataType;</div><div class="line">        childPreviousSiblingParentData.nextSibling = child;</div><div class="line">        childNextSiblingParentData.previousSibling = child;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>RenderObject.adoptChild()</code> 挂载新节点<ul>
<li>初始化 ParentData</li>
<li>markNeedsLayout Layout标脏</li>
<li>markNeedsCompositingBitsUpdate 合成位标脏</li>
<li>markNeedsSemanticsUpdate 辅助信息Semantic标脏</li>
<li>调用AbstractNode.adoptChild()，挂载到 Render Tree，将child.parent指向自己，更新树的深度</li>
</ul>
</li>
<li>提供一个兄弟节点，将其关联到兄弟链上，用于后续流程兄弟节点之间遍历，分几种情况<ul>
<li>依附的兄弟节点为空，插入在第一个子节点</li>
<li>依附的兄弟节点没有相关联的下一个兄弟节点，插入在兄弟节点队尾</li>
<li>依附的兄弟节点有相关联的下一个兄弟节点，插入在兄弟节点中间</li>
</ul>
</li>
</ul>
<p>至此，Render Tree 构建完毕，基于 Render Tree 接下来分析下 Layout 的过程。</p>
<h1 id="3、markNeedsLayout-标脏"><a href="#3、markNeedsLayout-标脏" class="headerlink" title="3、markNeedsLayout 标脏"></a>3、markNeedsLayout 标脏</h1><p>上面提到，在 RenderObject 节点挂载到 Render Tree 过程中，会触发 <code>markNeedsLayout</code> Layout 标脏操作。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> <span class="keyword">extends</span> <span class="title">AbstractNode</span> <span class="title">with</span> <span class="title">DiagnosticableTreeMixin</span> <span class="keyword">implements</span> <span class="title">HitTestTarget</span> </span>&#123;  </div><div class="line">	<span class="keyword">void</span> markNeedsLayout() &#123;</div><div class="line">    <span class="comment">// 如果已经标脏，避免重复标脏</span></div><div class="line">    <span class="keyword">if</span> (_needsLayout) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">this</span>) &#123;</div><div class="line">      <span class="comment">// 如果 _relayoutBoundary 布局边界不是本节点，那么向上遍历</span></div><div class="line">      markParentNeedsLayout();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 如果 _relayoutBoundary 布局边界是自本节点，将本节点加入 owner._nodesNeedingLayout 列表，等待 layout 流程处理</span></div><div class="line">      _needsLayout = <span class="keyword">true</span>;</div><div class="line">      <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</div><div class="line">        owner!._nodesNeedingLayout.add(<span class="keyword">this</span>);</div><div class="line">        owner!.requestVisualUpdate();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@protected</span></div><div class="line">  <span class="keyword">void</span> markParentNeedsLayout() &#123;</div><div class="line">    ...</div><div class="line">    _needsLayout = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent! <span class="keyword">as</span> RenderObject;</div><div class="line">    parent.markNeedsLayout();</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果已经标脏，避免重复标脏</li>
<li>如果 <code>_relayoutBoundary</code> 布局边界是自本节点，将本节点加入 <code>PipelineOwner</code>渲染管线中的<code>_nodesNeedingLayout</code> 脏列表，触发 <code>scheduleFrame()</code> 流程，等待 layout 流程处理</li>
<li>如果 <code>_relayoutBoundary</code> 布局边界不是本节点，那么向上遍历，直到找到布局边界，将布局边界节点加入 <code>PipelineOwner</code>渲染管线中的<code>_nodesNeedingLayout</code> 脏列表，触发 <code>scheduleFrame()</code> 流程，等待 layout 流程处理</li>
</ul>
<p><code>_relayoutBoundary</code> 布局边界用于优化测量和布局效率，缩小计算范围，通过和 <code>PipelineOwner</code>渲染管线中的<code>_nodesNeedingLayout</code> 脏列表配合，仅对标脏节点和布局边界子树进行测量和布局，达到布局<strong>次线性</strong>复杂度。</p>
<p><code>_relayoutBoundary</code> 有两个地方赋值：</p>
<ol>
<li>RenderView 根节点，在 App 启动过程中调用 RenderObject.scheduleInitialLayout() 方法，<code>_relayoutBoundary = this;</code> 赋值</li>
<li>RenderObject Layout 阶段，在特定条件下，一些节点会被标记为_relayoutBoundary，这个我们后面详细分析</li>
</ol>
<p>所以，在App启动后第一次布局绘制时，只有根节点 RenderView 是_relayoutBoundary，其余符合条件的节点，只有在首次布局测量时，在Layout阶段触发 layout() 方法进行标注，在下一次布局阶段生效。</p>
<h1 id="4、RendererBinding-drawFrame"><a href="#4、RendererBinding-drawFrame" class="headerlink" title="4、RendererBinding.drawFrame()"></a>4、RendererBinding.drawFrame()</h1><p>上一篇文章结尾，我们提到 <code>WidgetsBinding.drawFrame()</code> 流程触发 rebuild()，接着触发 <code>RendererBinding.drawFrame()</code> 流程，看下方法实现。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/binding.dart</span></div><div class="line">	<span class="meta">@protected</span></div><div class="line">  <span class="keyword">void</span> drawFrame() &#123;</div><div class="line">    <span class="keyword">assert</span>(renderView != <span class="keyword">null</span>);</div><div class="line">    pipelineOwner.flushLayout();</div><div class="line">    pipelineOwner.flushCompositingBits();</div><div class="line">    pipelineOwner.flushPaint();</div><div class="line">    <span class="keyword">if</span> (sendFramesToEngine) &#123;</div><div class="line">      renderView.compositeFrame(); <span class="comment">// this sends the bits to the GPU</span></div><div class="line">      pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></div><div class="line">      _firstFrameSent = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>通过<code>PipelineOwner</code>渲染管线和Flutter Engine进行交互，执行以下过程：</p>
<ul>
<li>pipelineOwner.flushLayout() 布局阶段，遍历Layout被标脏的 RenderObject，调用 performLayout() 完成测量和布局工作</li>
<li>pipelineOwner.flushCompositingBits() 标记合成阶段，遍历合成位标脏被标脏的RenderObject，标记那些repaintBoundary==true 的节点及其子节点为需要合成(Compisiting)，为下一步合成layer做准备</li>
<li>pipelineOwner.flushPaint() 绘制阶段，遍历绘制被标脏的RenderObject，执行绘制操作，并通过PaintingContext记录到PictureLayer，最终生成一颗LayerTree</li>
<li>renderView.compositeFrame()合成阶段，遍历Dart Framework LayerTree，构建Engine LayerTree &amp; Scene，将绘制数据通过Flutter Engine发送给GPU</li>
<li>pipelineOwner.flushSemantics() 语义阶段，遍历辅助信息被标脏的RenderObject，执行_updateSemantics()更新语义</li>
</ul>
<p>在Element.rebuild、布局、绘制、合成、语义这几个阶段，有很通用的处理流程</p>
<ol>
<li>RenderObject 节点先被标脏，记录在脏列表中</li>
<li>接着脏列表中的节点，在 RendererBinding.drawFrame() 中被分别处理</li>
</ol>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20210115183142.png" alt=""></p>
<p>通过遍历脏列表，再加上中布局节点和绘制阶段，分别通过 <code>_relayoutBoundary</code> 和 <code>_repaintBoundary</code>进行优化，最终达到整个整个流程都是次线性的，这也就是为什么说 Flutter 绘制高效的根本原因。</p>
<p>#5、flushLayout() </p>
<p>看下方法实现</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/binding.dart</span></div><div class="line">  <span class="keyword">void</span> flushLayout() &#123;</div><div class="line">    <span class="keyword">if</span> (!kReleaseMode) &#123;</div><div class="line">      <span class="comment">//记录Layout过程</span></div><div class="line">      Timeline.startSync(<span class="string">'Layout'</span>, arguments: timelineArgumentsIndicatingLandmarkEvent);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">while</span> (_nodesNeedingLayout.isNotEmpty) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout;</div><div class="line">        _nodesNeedingLayout = &lt;RenderObject&gt;[];</div><div class="line">        <span class="comment">//广度优先</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth)) &#123;</div><div class="line">          <span class="keyword">if</span> (node._needsLayout &amp;&amp; node.owner == <span class="keyword">this</span>)</div><div class="line">            node._layoutWithoutResize();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      ...</div><div class="line">      <span class="keyword">if</span> (!kReleaseMode) &#123;</div><div class="line">        <span class="comment">//结束 Layout 过程记录</span></div><div class="line">        Timeline.finishSync();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>遍历<code>PipelineOwner</code>渲染管线中的<code>_nodesNeedingLayout</code> 脏列表中的 ，广度优先原则调用<code>_layoutWithoutResize()</code>方法。</p>
<p>该阶段被记录在Timeline的Layout过程，在UI线程执行。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/object.dart</span></div><div class="line">  <span class="keyword">void</span> _layoutWithoutResize() &#123;</div><div class="line">    <span class="comment">// 只有 _relayoutBoundary 节点才会被加入脏列表</span></div><div class="line">    <span class="keyword">assert</span>(_relayoutBoundary == <span class="keyword">this</span>);</div><div class="line">		...</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//具体的布局操作</span></div><div class="line">      performLayout();</div><div class="line">      <span class="comment">// 辅助信息标脏</span></div><div class="line">      markNeedsSemanticsUpdate();</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    _needsLayout = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//_needsPaint标脏，并记录在_nodesNeedingPaint列表中</span></div><div class="line">    markNeedsPaint();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>只有 _relayoutBoundary 节点才会被加入脏列表</li>
<li>测量和布局，performLayout() 是空方法，需要子类实现</li>
<li>辅助信息标脏</li>
<li>needsPaint标脏，并记录在_nodesNeedingPaint列表中</li>
</ul>
<p>由于是广度优先遍历，并且根节点是RenderView，先看下RenderView.performLayout()的实现</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/rendering/view.dart</span></div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> performLayout() &#123;</div><div class="line">    _size = configuration.size;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>)</div><div class="line">      child.layout(BoxConstraints.tight(_size));</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>根据屏幕最大宽高，生成一个BoxConstraints盒约束，传递给子节点，子节点layout() 用于测量和布局。</p>
<p>看下 RenderObject 的 layout 方法实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> layout(Constraints constraints, &#123; <span class="built_in">bool</span> parentUsesSize = <span class="keyword">false</span> &#125;) &#123;</div><div class="line">  RenderObject? relayoutBoundary;</div><div class="line">  <span class="keyword">if</span> (!parentUsesSize || sizedByParent || constraints.isTight || parent <span class="keyword">is</span>! RenderObject) &#123;</div><div class="line">    relayoutBoundary = <span class="keyword">this</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    relayoutBoundary = (parent <span class="keyword">as</span> RenderObject)._relayoutBoundary;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123;</div><div class="line">    <span class="comment">// 不需要重新布局，直接返回</span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  _constraints = constraints;</div><div class="line">  <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">null</span> &amp;&amp; relayoutBoundary != _relayoutBoundary) &#123;</div><div class="line">    <span class="comment">// _relayoutBoundary 边界改变，清理所有子节点的边界信息</span></div><div class="line">    visitChildren(_cleanChildRelayoutBoundary);</div><div class="line">  &#125;</div><div class="line">  _relayoutBoundary = relayoutBoundary;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (sizedByParent) &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 依赖父节点传递的约束信息，测量布局大小Size，sizedByParent为true的子节点，需要重写	performResize()</span></div><div class="line">    performResize();</div><div class="line">  &#125;</div><div class="line">  RenderObject? debugPreviousActiveLayout;</div><div class="line"></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 触发布局</span></div><div class="line">    performLayout();</div><div class="line">    markNeedsSemanticsUpdate();</div><div class="line">  &#125; <span class="keyword">catch</span> (e, stack) &#123;</div><div class="line">    _debugReportException(<span class="string">'performLayout'</span>, e, stack);</div><div class="line">  &#125;</div><div class="line"><span class="comment">// 清楚标记</span></div><div class="line">  _needsLayout = <span class="keyword">false</span>;</div><div class="line">  <span class="comment">// 绘制标脏</span></div><div class="line">  markNeedsPaint();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-1、RelayoutBoundary-布局边界"><a href="#5-1、RelayoutBoundary-布局边界" class="headerlink" title="5.1、RelayoutBoundary 布局边界"></a>5.1、RelayoutBoundary 布局边界</h3><p>这里有三个概念比较重要：</p>
<ul>
<li>parentUsesSize  ：父节点是否依赖子节点的测量布局信息，才能够确定其自身的测量布局信息；默认为 false，为 true 时，当子节点layout标脏时，父节点也要标脏</li>
<li>sizedByParent：根据父节点传递过来的约束条件 constraints，就可以唯一确定该节点的 Size 大小，不需要依赖其自身和子节点的属性就可以确定大小。</li>
<li>isTight: 当盒约束 BoxConstraint 的 minWidth = maxWidth &amp;&amp; minHeight == maxHeight 时，isTight 为true</li>
</ul>
<p>根据这三个变量，可以确定该节点是否是 relayoutBoundary 布局边界，根本原因是布局边界的触发条件是，本节点不依赖父节点的改变而改变。</p>
<p>布局边界相当于在RenderTree中，插入了一层布局屏障，外界改变不会引起布局边界内子树的改变；同样的，当布局边界子树内部发生布局大小变化，也不会影响父节点重新布局。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20210115174505.png" alt=""></p>
<p>布局边界机制可以提高布局性能。</p>
<h3 id="5-2-Layout-布局"><a href="#5-2-Layout-布局" class="headerlink" title="5.2 Layout 布局"></a>5.2 Layout 布局</h3><p>performResize() 用于测量大小，子节点需要重写该方法，根据父节点传递的constraints约束计算大小，结果记录在 _size 中。仅当sizedByParent为true时，会触发该方法。</p>
<p>performLayout() 用于布局，子类需要重写该方法，布局信息存储在当前节点parentData中，后面在绘制阶段会由父节点使用。</p>
<p>在RenderTree中 递归调用 <strong>layout()-&gt;performLayout()/performResize()-&gt;child.layout()-&gt;…</strong>完成测量和布局。</p>
<p>布局原则：</p>
<p><strong>Constraints go down. </strong></p>
<p><strong>Sizes go up. </strong></p>
<p><strong>Parent sets position.</strong></p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20210115184056.png" alt=""></p>
<p>可以理解为约束从高向下传递，子节点根据约束和自身情况确定大小，并向上告知父节点，最终布局情况由父节点确定。</p>
<p>整个布局过程是次线性的。</p>
<p>本篇文章分析了RenderObject及RenderTree的构建，以及RenderTree Layout 布局过程。</p>
<p>下篇文章继续分析下Paint绘制过程。</p>
<p>本文链接： <a href="http://w4lle.com/2021/01/15/flutter-ui-layout/">http://w4lle.com/2021/01/15/flutter-ui-layout/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;系列文章的第五篇，本篇文章主要分析下 Render Tree 的构建及 Layout 过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://w4lle.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter UI 渲染浅析（四）Build</title>
    <link href="http://w4lle.com/2020/11/16/flutter-ui-build/"/>
    <id>http://w4lle.com/2020/11/16/flutter-ui-build/</id>
    <published>2020-11-16T06:30:12.000Z</published>
    <updated>2020-12-11T10:26:04.142Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章的第四篇，本篇文章主要分析下 Element.rebuild() 过程。</p>
<p>源码基于 Flutter v1.20.4。</p>
<a id="more"></a>
<p>在 <a href="http://w4lle.com/2020/11/11/flutter-ui-vsync/">Flutter UI 渲染浅析（二）VSync 注册</a> 这篇文章中提到，C++ Engine 接收到 VSync 信号后，需要做三件事情：</p>
<ul>
<li>执行 Dart Framework <code>dart:ui</code> 包下的 <code>_beginFrame()</code></li>
<li>执行 microtasks 任务</li>
<li>执行 Dart Framework <code>dart:ui</code> 包下的  <code>_drawFrame()</code></li>
</ul>
<p>上一篇文章 <a href="http://w4lle.com/2020/11/13/flutter-ui-animate/">Flutter UI 渲染浅析（三）Animation 原理</a> 中分析了 <code>_beginFrame()</code> 的过程。</p>
<p>然后接着去处理在 <code>Animate</code> 过程中触发的 <code>microtasks</code> 任务，一般为 <code>Ticker</code> 或者 <code>AnimationController</code> 中  Future 的完成回调。</p>
<p>本篇文章分析下 <code>_drawFrame()</code> 的前半部分—— <code>Element.rebuild()</code> 的过程。</p>
<h1 id="1、-handleDrawFrame"><a href="#1、-handleDrawFrame" class="headerlink" title="1、_handleDrawFrame()"></a>1、_handleDrawFrame()</h1><p>同上篇文章的逻辑一样，调用到 Dart Framework 的<code>SchedulerBinding._handleDrawFrame()</code> 方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/scheduler/binding.dart</span></div><div class="line">	<span class="keyword">void</span> _handleDrawFrame() &#123;</div><div class="line">    <span class="keyword">if</span> (_ignoreNextEngineDrawFrame) &#123;</div><div class="line">      _ignoreNextEngineDrawFrame = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    handleDrawFrame();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">void</span> handleDrawFrame() &#123;</div><div class="line">    <span class="keyword">assert</span>(_schedulerPhase == SchedulerPhase.midFrameMicrotasks);</div><div class="line">    <span class="comment">//结束Animate过程记录</span></div><div class="line">    Timeline.finishSync(); <span class="comment">// end the "Animate" phase</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// PERSISTENT FRAME CALLBACKS</span></div><div class="line">      _schedulerPhase = SchedulerPhase.persistentCallbacks;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> FrameCallback callback <span class="keyword">in</span> _persistentCallbacks)</div><div class="line">        _invokeFrameCallback(callback, _currentFrameTimeStamp);</div><div class="line"></div><div class="line">      <span class="comment">// POST-FRAME CALLBACKS</span></div><div class="line">      _schedulerPhase = SchedulerPhase.postFrameCallbacks;</div><div class="line">      <span class="keyword">final</span> <span class="built_in">List</span>&lt;FrameCallback&gt; localPostFrameCallbacks =</div><div class="line">          <span class="built_in">List</span>&lt;FrameCallback&gt;.from(_postFrameCallbacks);</div><div class="line">      <span class="comment">//清除列表</span></div><div class="line">      _postFrameCallbacks.clear();</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> FrameCallback callback <span class="keyword">in</span> localPostFrameCallbacks)</div><div class="line">        _invokeFrameCallback(callback, _currentFrameTimeStamp);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="comment">//SchedulerPhase状态置为idle，等待下一次绘制触发</span></div><div class="line">      _schedulerPhase = SchedulerPhase.idle;</div><div class="line">      <span class="comment">//结束Frame过程记录</span></div><div class="line">      Timeline.finishSync(); <span class="comment">// end the Frame</span></div><div class="line">      _currentFrameTimeStamp = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>主要做了两件事情：</p>
<ul>
<li>遍历 <code>_persistentCallbacks</code>，由 <code>WidgetsBinding.addPersistentFrameCallback()</code> 注册，从名字也可以看出，它是一个需要持久回调的列表，所以不可删除，每次绘制过程都会回调</li>
<li>遍历<code>_postFrameCallbacks</code>，由 <code>WidgetsBinding.addPostFrameCallback()</code> 注册，只会回调一次，调用过后清除回调列表，一般用于监听绘制完成后处理一些任务</li>
</ul>
<p>下面主要看下<code>_persistentCallbacks</code> 的执行过程。</p>
<h2 id="1-1、RendererBinding-drawFrame"><a href="#1-1、RendererBinding-drawFrame" class="headerlink" title="1.1、RendererBinding.drawFrame()"></a>1.1、RendererBinding.drawFrame()</h2><p>在 <a href="http://w4lle.com/2020/11/11/flutter-ui-vsync/">Flutter UI 渲染浅析（二）VSync 注册</a> 这篇文章中，我们简单分析了 7 个 Binding 类的作用及其初始化顺序。</p>
<p>在 <code>RendererBinding</code> 在初始化过程中，注册了<code>_persistentCallbacks</code> 回调，如下。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">mixin RendererBinding on BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, SemanticsBinding, HitTestable &#123;</div><div class="line">  <span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> initInstances() &#123;</div><div class="line">    <span class="keyword">super</span>.initInstances();</div><div class="line">    _instance = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">//初始化绘制管线</span></div><div class="line">    _pipelineOwner = PipelineOwner(</div><div class="line">      onNeedVisualUpdate: ensureVisualUpdate,</div><div class="line">      onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,</div><div class="line">      onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,</div><div class="line">    );</div><div class="line">    <span class="comment">//注册window回调</span></div><div class="line">    <span class="built_in">window</span></div><div class="line">      ..onMetricsChanged = handleMetricsChanged</div><div class="line">      ..onTextScaleFactorChanged = handleTextScaleFactorChanged</div><div class="line">      ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged</div><div class="line">      ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged</div><div class="line">      ..onSemanticsAction = _handleSemanticsAction;</div><div class="line">    <span class="comment">//初始化RenderObject根节点RenderView</span></div><div class="line">    initRenderView();</div><div class="line">    _handleSemanticsEnabledChanged();</div><div class="line">    <span class="comment">//这里添加_persistentCallbacks回调</span></div><div class="line">    addPersistentFrameCallback(_handlePersistentFrameCallback);</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">  <span class="comment">//_persistentCallbacks回调</span></div><div class="line">  <span class="keyword">void</span> _handlePersistentFrameCallback(<span class="built_in">Duration</span> timeStamp) &#123;</div><div class="line">    <span class="comment">//真正执行frame绘制</span></div><div class="line">    drawFrame();</div><div class="line">    _mouseTracker.schedulePostFrameCheck();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><code>_handlePersistentFrameCallback(Duration timeStamp)</code> 方法是 <code>_persistentCallbacks</code> 回调列表的一个子元素，其中去调用 <code>drawFrame()</code> 方法。</p>
<p>由于 <code>WidgetsFlutterBinding</code> 的混入顺序</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/widgets/binding.dart</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetsFlutterBinding</span> <span class="keyword">extends</span> <span class="title">BindingBase</span> <span class="title">with</span> <span class="title">GestureBinding</span>, <span class="title">SchedulerBinding</span>, <span class="title">ServicesBinding</span>, <span class="title">PaintingBinding</span>, <span class="title">SemanticsBinding</span>, <span class="title">RendererBinding</span>, <span class="title">WidgetsBinding</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> WidgetsBinding ensureInitialized() &#123;</div><div class="line">    <span class="keyword">if</span> (WidgetsBinding.instance == <span class="keyword">null</span>)</div><div class="line">      WidgetsFlutterBinding();</div><div class="line">    <span class="keyword">return</span> WidgetsBinding.instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>WidgetsBinding</code> 在 <code>RendererBinding</code> 之后，所以会先执行 <code>WidgetsBinding.drawFrame()</code> 方法。</p>
<h2 id="1-2、WidgetsBinding-drawFrame"><a href="#1-2、WidgetsBinding-drawFrame" class="headerlink" title="1.2、WidgetsBinding.drawFrame()"></a>1.2、WidgetsBinding.drawFrame()</h2><p><code>WidgetsBinding.drawFrame()</code> 实现: </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/widgets/binding.dart WidgetsBinding</span></div><div class="line">mixin WidgetsBinding on BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding &#123;</div><div class="line">  <span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> initInstances() &#123;</div><div class="line">    <span class="keyword">super</span>.initInstances();</div><div class="line">    _instance = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">//构造BuildeOwner，主要负责Widget的build过程</span></div><div class="line">    _buildOwner = BuildOwner();</div><div class="line">    buildOwner.onBuildScheduled = _handleBuildScheduled;</div><div class="line">    <span class="comment">//注册window相关回调</span></div><div class="line">    <span class="built_in">window</span>.onLocaleChanged = handleLocaleChanged;</div><div class="line">    <span class="built_in">window</span>.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged;</div><div class="line">  	<span class="comment">//导航channel  </span></div><div class="line">    SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation);</div><div class="line">    FlutterErrorDetails.propertiesTransformers.add(transformDebugCreator);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> drawFrame() &#123;</div><div class="line">		...</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//renderViewElement是根RenderObject RenderView对应的Element</span></div><div class="line">      <span class="keyword">if</span> (renderViewElement != <span class="keyword">null</span>)</div><div class="line">        buildOwner.buildScope(renderViewElement);</div><div class="line">      <span class="comment">//调用mixin的drawFrame方法，即RendererBinding.drawFrame()</span></div><div class="line">      <span class="keyword">super</span>.drawFrame();</div><div class="line">      buildOwner.finalizeTree();</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>buildOwner.buildScope() 触发Widget Tree、Element Tree、RenderObject Tree三棵树的构建或刷新过程</li>
<li>super.drawFrame() 调用父类的 drawFrame() 方法，由于 <code>WidgetsBinding</code> 混入了 <code>RendererBinding</code> ，所以这里会去调用 <code>RendererBinding.drawFrame()</code> ，下篇文章会继续分析</li>
<li>buildOwner.finalizeTree() 卸载未激活状态的 Element 节点。未激活状态的节点在一个绘制帧周期内，是有可能被重新激活的，如果没有重新激活，那么就卸载掉</li>
</ul>
<h2 id="1-3、BuildOwner-buildScope"><a href="#1-3、BuildOwner-buildScope" class="headerlink" title="1.3、BuildOwner.buildScope()"></a>1.3、BuildOwner.buildScope()</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/widgets/framework.dart BuildOwner</span></div><div class="line">	<span class="keyword">void</span> buildScope(<span class="built_in">Element</span> context, [ VoidCallback callback ]) &#123;</div><div class="line">    <span class="comment">// 记录 Build 过程</span></div><div class="line">    Timeline.startSync(<span class="string">'Build'</span>, arguments: timelineArgumentsIndicatingLandmarkEvent);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      _scheduledFlushDirtyElements = <span class="keyword">true</span>;</div><div class="line">      <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</div><div class="line">        _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">// 执行回调，在App启动构建三棵树时会用到</span></div><div class="line">        callback();</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 重排序，高度优先</span></div><div class="line">      _dirtyElements.sort(<span class="built_in">Element</span>._sort);</div><div class="line">      _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</div><div class="line">      <span class="built_in">int</span> dirtyCount = _dirtyElements.length;</div><div class="line">      <span class="built_in">int</span> index = <span class="number">0</span>;</div><div class="line">      <span class="keyword">while</span> (index &lt; dirtyCount) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="comment">// 触发 Elemeng.rebuild() 更新三棵树</span></div><div class="line">          _dirtyElements[index].rebuild();</div><div class="line">        &#125;</div><div class="line">        index += <span class="number">1</span>;</div><div class="line">        <span class="comment">// 在等待VSync 信号回调过程中，有可能又有新的标脏节点进来</span></div><div class="line">        <span class="keyword">if</span> (dirtyCount &lt; _dirtyElements.length || _dirtyElementsNeedsResorting) &#123;</div><div class="line">          <span class="comment">// 重排序，高度优先</span></div><div class="line">          _dirtyElements.sort(<span class="built_in">Element</span>._sort);</div><div class="line">          _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</div><div class="line">          dirtyCount = _dirtyElements.length;</div><div class="line">          <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; _dirtyElements[index - <span class="number">1</span>].dirty) &#123;</div><div class="line">            index -= <span class="number">1</span>;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> <span class="built_in">Element</span> element <span class="keyword">in</span> _dirtyElements) &#123;</div><div class="line">        <span class="comment">// 清除 Element 脏标记</span></div><div class="line">        element._inDirtyList = <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 清空脏列表</span></div><div class="line">      _dirtyElements.clear();</div><div class="line">      _scheduledFlushDirtyElements = <span class="keyword">false</span>;</div><div class="line">      _dirtyElementsNeedsResorting = <span class="keyword">null</span>;</div><div class="line">      <span class="comment">// 结束 Build 记录过程</span></div><div class="line">      Timeline.finishSync();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>执行回调，在 App 启动时<code>WidgetsFlutterBinding.ensureInitialized()
  ..scheduleAttachRootWidget(app)</code> 会用到，用于构建出三棵树，callback 为 <code>element.mount(null, null);</code></li>
<li><code>_dirtyElements</code> 脏列表重排序，在等待 VSync 信号回调过程中，有可能又有新的标脏节点进来</li>
<li>脏列表中的节点，即调用了 <code>State.setState()</code> 的节点，触发 Element.rebuild() 更新三棵树，这里的重点也是Element.rebuild()。</li>
<li>清除 Element 脏标记，清空脏列表</li>
</ul>
<h2 id="1-4、Element-rebuild"><a href="#1-4、Element-rebuild" class="headerlink" title="1.4、Element.rebuild()"></a>1.4、Element.rebuild()</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// flutter/lib/src/widgets/framework.dart Elememt  </span></div><div class="line">	<span class="keyword">void</span> rebuild() &#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> (!_active || !_dirty)</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    performRebuild();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@protected</span></div><div class="line">  <span class="keyword">void</span> performRebuild();</div></pre></td></tr></table></figure>
<p>逻辑比较简单，调用 <code>performRebuild()</code>，它是一个空方法，实现在子类。</p>
<h1 id="2、Widget、Element-与-RenderObject"><a href="#2、Widget、Element-与-RenderObject" class="headerlink" title="2、Widget、Element 与 RenderObject"></a>2、Widget、Element 与 RenderObject</h1><p>在继续分析后续流程之前，先简单梳理下 Widget、Element 与 RenderObject 之间的关系，以及三棵树与 Layer Tree 之间的关系。</p>
<p>Flutter 开发者最熟悉的就是 Widget 了。</p>
<p>Widget 是面向开发者的接口，它是对UI的描述性表达，即是用于描述 Element 的配置的。</p>
<p>Widget 是声明式的 UI 结构，开发者通过组合 Widget 构建出想要的UI效果。</p>
<p>Widget 是不可变的（immutable），这就意味着每次刷新，都会重新构建出新的Widget对象，创建的开销很小，成本较低。</p>
<p>我们通常将 Widget 组合构建出的 UI 层级结构称为 Widget Tree，但相比 Element Tree，实际上并不存在 Widget              Tree，由于 Widget 节点挂载在 Element 节点上，所以我们可以抽象为 Widget Tree。</p>
<p>Widget 提供 <code>createElement()</code> 和 <code>createRenderObject()</code> （并不是所有）用于构建 Element 和 RenderObject。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter_widgets_categories.png" alt=""></p>
<p>Widget 主要有三种类型：</p>
<ul>
<li>ProxyWidget 代理类，不直接参与构建UI，它们可以为其他 Widget 提供一些附加信息。例如 <code>InheritedWidget</code> 可以在其子树中传递附加信息；<code>ParentDataWidget</code> 用于提供其子树的布局信息</li>
<li>ComponentWidget 组合类，不直接参与绘制，它们用来组合包装用来构建复杂的UI布局。一般都是 <code>StatefullWidget</code> 或者 <code>StatelessWidget</code> 的子类，例如 <code>RaisedButton</code> 、<code>Scaffold</code>、<code>Text</code>、 <code>GestureDetector</code>、 <code>Container</code> 等</li>
<li>RenderObjectWidget 绘制类，可以构建出 RenderObject 用来布局和绘制</li>
</ul>
<p>Element 是响应式编程的基础，频繁的创建 Element 会对性能有影响，所以只有在必要条件下才会创建一个新的 Element 对象，大部分情况下会进行复用，主要包含两个职责：</p>
<ul>
<li>持有 Widget 和 RenderObject 的引用，协调二者之间的数据绑定关系</li>
<li>根据 Widget 的变化来创建或更新 Element Tree，包括挂载、更新、更改位置、卸载等</li>
</ul>
<p>Element 和 Widget 是一一对应的关系，同样类型的 Widget 构建出同样类型的 Element。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter_element_types.png" alt=""></p>
<p>RenderObject 用来布局和绘制，处理输入事件等。</p>
<p>Element 和 RenderObject 不是一一对应的，只有可以绘制的节点才有 RenderObject 对象。</p>
<p>Render Tree 用来布局和绘制 RenderObject 节点，最终生成 Layer Tree 提交给 C++ Engine。它的根节点是 RenderView。</p>
<p>他们三者之间的关系：</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesinternals_element.png" alt=""></p>
<p>Element 持有 Widget 引用和 RenderObject 应用（可能没有），Widget 用来构建 RenderObject 对象。</p>
<p>对于 StatefullElement 来说，它还会持有 State 的引用。</p>
<p>这里需要注意，Element 的 child 是 Widget 中 build() 方法构建出来的 Widget 所对应的 Element，下面会用到。</p>
<p>Widget、Element、RenderObject 构建出三棵树 Widget Tree、Element Tree、Render Tree，它们共同组成了 Flutter 对于UI的组织描述。</p>
<p>前两棵树可以认为是面向开发者的，它们构成了声明式UI、响应式UI的基础，Render Tree 用来真正的布局和绘制，最后生成 Layer Tree，并保存在 Scene 对象中，提交给 C++ Engine 做光栅化合成。</p>
<p>那么，可不可以绕开 Widget、Element、RenderObject 来进行绘制，其实是可以的，它们只是用来组织描述绘制信息的，我们可以直接拿到 Canvas 进行绘制，只要最终可以生成Layer Tree 保存在 Scene 中就可以。</p>
<p>例如 <a href="https://codepen.io/w4lle/pen/ZEOPZEe" target="_blank" rel="external">这个例子 🌰</a> 。</p>
<p>更进一步的，甚至可以绕过或者舍弃 Dart Framework，直接对接 C++ Engine，任何可以组织描述UI绘制结构的组织形式，理论上都可以桥接到 C++ Engine。</p>
<p>例如基于 W3C 标准的 CSS + JS/TS 组织的UI描述，通过绑定JS与C++ Engine，将绘制信息发送给 Engine，理论上也是可行的，如下图</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20201117155018.png" alt=""></p>
<h1 id="3、Element-performRebuild"><a href="#3、Element-performRebuild" class="headerlink" title="3、Element.performRebuild()"></a>3、Element.performRebuild()</h1><p>继续上面分析到 <code>Element.performRebuild()</code>。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter_ondrawframe.gif" alt=""></p>
<p>分 Element 类型看下实现</p>
<p>ComponentElement：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/widgets/framework.dart ComponentElement</span></div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> performRebuild() &#123;</div><div class="line">    Widget built;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      ...</div><div class="line">      built = build();</div><div class="line">      ...</div><div class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</div><div class="line">      _debugDoingBuild = <span class="keyword">false</span>;</div><div class="line">      <span class="comment">// 错误情况，这里是构建红屏的地方</span></div><div class="line">      built = ErrorWidget.builder();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="comment">// 改变标志位</span></div><div class="line">      _dirty = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      ...</div><div class="line">      _child = updateChild(_child, built, slot);</div><div class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</div><div class="line">      <span class="comment">// 错误情况，这里也是构建红屏的地方</span></div><div class="line">      built = ErrorWidget.builder();</div><div class="line">      _child = updateChild(<span class="keyword">null</span>, built, slot);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">// lib/src/widgets/framework.dart StatefullElement</span></div><div class="line">  <span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> performRebuild() &#123;</div><div class="line">    <span class="keyword">if</span> (_didChangeDependencies) &#123;</div><div class="line">      <span class="comment">// 依赖的祖先节点如果有变化，需要调用</span></div><div class="line">      _state.didChangeDependencies();</div><div class="line">      _didChangeDependencies = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">super</span>.performRebuild();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>主要做了两件事情：</p>
<ul>
<li><code>build()</code> 构建子 Widget，注意这里是 <strong>子Widget</strong></li>
<li><code>_updateChild()</code> 创建或更新子Element，注意这里是 <strong>子Element</strong></li>
</ul>
<p>为什么强调子Widget和子Element，因为在这个Element对象中，它对应的 Widget 和 Element 就是Element自己合它持有的 Widget。这里很容易搞混。</p>
<p>RenderObjectElement：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/widgets/framework.dart RenderObjectElement</span></div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> performRebuild() &#123;</div><div class="line">    ...</div><div class="line">     </div><div class="line">    widget.updateRenderObject(<span class="keyword">this</span>, renderObject);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">// lib/src/widgets/basic Stack</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> <span class="keyword">extends</span> <span class="title">MultiChildRenderObjectWidget</span> </span>&#123;</div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> updateRenderObject(BuildContext context, RenderStack renderObject) &#123;</div><div class="line">    <span class="keyword">assert</span>(_debugCheckHasDirectionality(context));</div><div class="line">    renderObject</div><div class="line">      ..alignment = alignment</div><div class="line">      ..textDirection = textDirection ?? Directionality.of(context)</div><div class="line">      ..fit = fit</div><div class="line">      ..clipBehavior = overflow == Overflow.visible ? Clip.none : clipBehavior;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <code>widget.updateRenderObject()</code> 的作用是把 Widget 中的属性值，绑定到 RenderObject 中，属性的类型一一对应。</p>
<h2 id="3-1、Element-build"><a href="#3-1、Element-build" class="headerlink" title="3.1、Element.build()"></a>3.1、Element.build()</h2><p><code>build()</code> 在各个类型的 Element 的实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// StatefullElement</span></div><div class="line">	<span class="meta">@override</span></div><div class="line">  Widget build() =&gt; _state.build(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"><span class="comment">// StatelessElement</span></div><div class="line">  <span class="meta">@override</span></div><div class="line">  Widget build() =&gt; widget.build(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"><span class="comment">// ProxyElement</span></div><div class="line">  <span class="meta">@override</span></div><div class="line">  Widget build() =&gt; widget.child;</div></pre></td></tr></table></figure>
<h2 id="3-2、Element-updateChild"><a href="#3-2、Element-updateChild" class="headerlink" title="3.2、Element.updateChild()"></a>3.2、Element.updateChild()</h2><p>这个方法是响应式UI的基础，也是 Dart Framework 的核心方法之一，看下实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@protected</span></div><div class="line"><span class="built_in">Element</span> updateChild(<span class="built_in">Element</span> child, Widget newWidget, <span class="keyword">dynamic</span> newSlot) &#123;</div><div class="line">  <span class="keyword">if</span> (newWidget == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// case 1</span></div><div class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>)</div><div class="line">      deactivateChild(child);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">Element</span> newChild;</div><div class="line">  <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// case 2</span></div><div class="line">    <span class="built_in">bool</span> hasSameSuperclass = <span class="keyword">true</span>;</div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> (hasSameSuperclass &amp;&amp; child.widget == newWidget) &#123;</div><div class="line">      <span class="comment">// case 2.1</span></div><div class="line">      <span class="keyword">if</span> (child.slot != newSlot)</div><div class="line">        updateSlotForChild(child, newSlot);</div><div class="line">      newChild = child;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasSameSuperclass &amp;&amp; Widget.canUpdate(child.widget, newWidget)) &#123;</div><div class="line">      <span class="comment">// case 2.2</span></div><div class="line">      <span class="keyword">if</span> (child.slot != newSlot)</div><div class="line">        updateSlotForChild(child, newSlot);</div><div class="line">      child.update(newWidget);</div><div class="line">      newChild = child;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// case 2.3</span></div><div class="line">      deactivateChild(child);</div><div class="line">      newChild = inflateWidget(newWidget, newSlot);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// case 3</span></div><div class="line">    newChild = inflateWidget(newWidget, newSlot);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> newChild;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先要先明确，这个方法是用来更新子树的，第一个参数 <code>child</code> 是 <strong>子Element</strong>，第二个参数<code>newWidget</code>是 <strong>子Widget</strong> 。</p>
<p>分几种情况：</p>
<ul>
<li>case 1：newWidget 为空，也就是当前 Element 节点对应的 Widget build() 返回了空，那么标记child为非激活状态(当前帧绘制完成后会被卸载)，然后返回空</li>
<li>case 2：如果child不为空，也就是之前构建过一次子Element<ul>
<li>case 2.1：如果子Element对应的widget 即 child.widget 和新构建的 newWidget 相等，直接更新子widget，如果插槽不同，更新下插槽</li>
<li>case 2.2：如果 <code>Widget.canUpdate(child.widget, newWidget)</code> ，判断标准是 <code>runtimeType</code> 和<code>key</code> 都相等，那么调用 <code>update()</code> 更新 child</li>
<li>case 2.3：否则child不可复用，标记child为非激活状态(当前帧绘制完成后会被卸载)，然后构建出一个新的 Element 节点，挂载到Element Tree上</li>
</ul>
</li>
<li>case 3：否则 child 为空，不可复用，构建出一个新的 Element 节点，挂载到Element Tree上</li>
</ul>
<p>下面看下几个关键的方法</p>
<h2 id="3-3、Element-update"><a href="#3-3、Element-update" class="headerlink" title="3.3、Element.update()"></a>3.3、Element.update()</h2><p>Element 类实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/widgets/framework.dart Element  </span></div><div class="line">	<span class="meta">@mustCallSuper</span> <span class="comment">// 子类复写该方法必须调用super</span></div><div class="line">  <span class="keyword">void</span> update(covariant Widget newWidget) &#123;</div><div class="line">    _widget = newWidget;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>直接更新 Element 子节点的 <code>_widget</code> 引用。</p>
<p>子类复写该方法必须调用super。</p>
<p>看下子类的实现。</p>
<h3 id="3-3-1、RenderObjectElement-update"><a href="#3-3-1、RenderObjectElement-update" class="headerlink" title="3.3.1、RenderObjectElement.update()"></a>3.3.1、RenderObjectElement.update()</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectElement</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> update(covariant RenderObjectWidget newWidget) &#123;</div><div class="line">    <span class="keyword">super</span>.update(newWidget);</div><div class="line">    widget.updateRenderObject(<span class="keyword">this</span>, renderObject);</div><div class="line">    _dirty = <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同上面一样，把 newWidget 中的属性值，绑定到 RenderObject 中。</p>
<p><code>SingleChildRenderObjectElement</code>、<code>MultiChildRenderObjectElement</code> 是 <code>RenderObjectElement</code> 的子类，分别看下实现。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleChildRenderObjectElement</span> <span class="keyword">extends</span> <span class="title">RenderObjectElement</span> </span>&#123;</div><div class="line">  <span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> update(SingleChildRenderObjectWidget newWidget) &#123;</div><div class="line">    <span class="keyword">super</span>.update(newWidget);</div><div class="line">    <span class="comment">// 更新子树</span></div><div class="line">    _child = updateChild(_child, widget.child, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用super，复用 RenderObjectElement.update() 逻辑</li>
<li>更新子树</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiChildRenderObjectElement</span> <span class="keyword">extends</span> <span class="title">RenderObjectElement</span> </span>&#123;</div><div class="line">  <span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> update(MultiChildRenderObjectWidget newWidget) &#123;</div><div class="line">    <span class="keyword">super</span>.update(newWidget);</div><div class="line">    _children = updateChildren(_children, widget.children, forgottenChildren: _forgottenChildren);</div><div class="line">    _forgottenChildren.clear();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用super，复用 RenderObjectElement.update() 逻辑</li>
<li>通过差分算法将新构造的 widget.children 绑定到已有的 _children 上来更新子树，updateChildren() 逻辑虽然看起来很多，但是还比较好理解，这里就不放源码了，说下逻辑<ul>
<li>首先从 topIndex 到 bottomIndex 遍历 oldChildElement 和 newChildWidget，如果<code>Widget.canUpdate(oldChild.widget, newWidget)</code>，那么<code>updateChild()</code>更新子树 <code>updateChild()</code>，直到匹配失败，记录 topIndex 累加值</li>
<li>从 bottomIndex 到 topIndex 遍历oldChildElement 和 newChildWidget，直到匹配失败，记录 bottomIndex 累减值，这里不更新子树</li>
<li>遍历缩小了的 oldChildElement 列表，记录 oldChild.widget.key 和 oldChild 到 map，key为空的反激活</li>
<li>遍历缩小了的 newChildWidget 列表，匹配 map 中的key类型，<code>updateChild()</code> 更新子树，未匹配到的反激活</li>
<li>最后更新第二步得到剩余的部分</li>
</ul>
</li>
</ul>
<h3 id="3-3-2、StatefullElement-update"><a href="#3-3-2、StatefullElement-update" class="headerlink" title="3.3.2、StatefullElement.update()"></a>3.3.2、StatefullElement.update()</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@override</span></div><div class="line"><span class="keyword">void</span> update(StatefulWidget newWidget) &#123;</div><div class="line">  <span class="keyword">super</span>.update(newWidget);</div><div class="line">  <span class="keyword">final</span> StatefulWidget oldWidget = _state._widget;</div><div class="line">  <span class="comment">// Notice that we mark ourselves as dirty before calling didUpdateWidget to</span></div><div class="line">  <span class="comment">// let authors call setState from within didUpdateWidget without triggering</span></div><div class="line">  <span class="comment">// asserts.</span></div><div class="line">  _dirty = <span class="keyword">true</span>;</div><div class="line">  _state._widget = widget <span class="keyword">as</span> StatefulWidget;</div><div class="line">  <span class="keyword">final</span> <span class="keyword">dynamic</span> debugCheckForReturnedFuture = _state.didUpdateWidget(oldWidget) <span class="keyword">as</span> <span class="keyword">dynamic</span>;</div><div class="line">  <span class="comment">// 更新子树</span></div><div class="line">  rebuild();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 super</li>
<li>更新 state 中 widget 的引用</li>
<li>调用 _state.didUpdateWidget(oldWidget)</li>
<li>调用 <code>rebuild()</code> 更新子树，由于 <code>rebuild()</code> 一定会触发 <code>build()</code> 方法调用，所以这里进行标脏</li>
</ul>
<p>StatelessElement.update() 类似，不写出来了。</p>
<h2 id="3-4、Element-inflateWidget"><a href="#3-4、Element-inflateWidget" class="headerlink" title="3.4、Element.inflateWidget()"></a>3.4、Element.inflateWidget()</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@protected</span></div><div class="line"><span class="built_in">Element</span> inflateWidget(Widget newWidget, <span class="keyword">dynamic</span> newSlot) &#123;</div><div class="line">  <span class="keyword">final</span> Key key = newWidget.key;</div><div class="line">  <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</div><div class="line">    <span class="comment">// 如果key类型是 GlobalKey，从非激活状态的列表中尝试匹配类型相同的节点，抢救复用一下</span></div><div class="line">    <span class="keyword">final</span> <span class="built_in">Element</span> newChild = _retakeInactiveElement(key, newWidget);</div><div class="line">    <span class="keyword">if</span> (newChild != <span class="keyword">null</span>) &#123;</div><div class="line">      newChild._activateWithParent(<span class="keyword">this</span>, newSlot);</div><div class="line">      <span class="keyword">final</span> <span class="built_in">Element</span> updatedChild = updateChild(newChild, newWidget, newSlot);</div><div class="line">      <span class="keyword">return</span> updatedChild;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 通过 Widget，创建对应的 Element</span></div><div class="line">  <span class="keyword">final</span> <span class="built_in">Element</span> newChild = newWidget.createElement();</div><div class="line"><span class="comment">// 挂载到 Element Tree 上</span></div><div class="line">  newChild.mount(<span class="keyword">this</span>, newSlot);</div><div class="line">  <span class="keyword">return</span> newChild;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果key类型是 GlobalKey，从非激活状态的列表中尝试匹配类型相同的节点，抢救性复用一下</li>
<li>通过 Widget，创建对应的 Element</li>
<li>挂载到 Element Tree 上</li>
</ul>
<h2 id="3-5、Element-mount"><a href="#3-5、Element-mount" class="headerlink" title="3.5、Element.mount()"></a>3.5、Element.mount()</h2><p>挂载到Element Tree上</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@mustCallSuper</span></div><div class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</div><div class="line">  <span class="comment">// 更新父节点信息</span></div><div class="line">  _parent = parent;</div><div class="line">  <span class="comment">// 更新插槽信息</span></div><div class="line">  _slot = newSlot;</div><div class="line">  <span class="comment">// 更新深度</span></div><div class="line">  _depth = _parent != <span class="keyword">null</span> ? _parent.depth + <span class="number">1</span> : <span class="number">1</span>;</div><div class="line">  <span class="comment">// 从初始化状态更改为激活状态</span></div><div class="line">  _active = <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) </div><div class="line">    <span class="comment">// 绑定 BuildOwner 对象</span></div><div class="line">    _owner = parent.owner;</div><div class="line">  <span class="keyword">final</span> Key key = widget.key;</div><div class="line">  <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</div><div class="line">    <span class="comment">// 如果是 GlobalKey，注册到公共map，全局复用</span></div><div class="line">    key._register(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 从 parent 更新 _inheritedWidgets，用于传递附加信息</span></div><div class="line">  _updateInheritance();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>更新父节点信息</li>
<li>更新插槽信息</li>
<li>更新深度</li>
<li>从初始化状态更改为激活状态</li>
<li>绑定 BuildOwner 对象</li>
<li>如果是 GlobalKey，注册到公共map，全局复用</li>
<li>从 parent 更新 _inheritedWidgets，用于传递附加信息</li>
</ul>
<p>如果子类复写该方法，那么必须要调用 super。</p>
<h3 id="3-5-1、ComponentElement-mount"><a href="#3-5-1、ComponentElement-mount" class="headerlink" title="3.5.1、ComponentElement.mount()"></a>3.5.1、ComponentElement.mount()</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentElement</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;  </div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</div><div class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</div><div class="line">    _firstBuild();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">void</span> _firstBuild() &#123;</div><div class="line">    rebuild();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 super() 调用 <code>Element.mount()</code></li>
<li>调用 _firstBuild() -&gt; rebuild() -&gt; performRebuild() 构建 Element 子树</li>
</ul>
<p>下面还有 SingleChildRenderObjectElement 、MultiChildRenderObjectElement 等子类，逻辑跟<code>update()</code>差不多，就不列出来了。</p>
<h3 id="3-5-2、RenderObjectElement-mount"><a href="#3-5-2、RenderObjectElement-mount" class="headerlink" title="3.5.2、RenderObjectElement.mount()"></a>3.5.2、RenderObjectElement.mount()</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectElement</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</div><div class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</div><div class="line">    <span class="comment">// 构建 RenderObject</span></div><div class="line">    _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</div><div class="line">		<span class="comment">// 将 RenderObject 挂载到 Render Tree 上</span></div><div class="line">    attachRenderObject(newSlot);</div><div class="line">    _dirty = <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 super() 调用 <code>Element.mount()</code></li>
<li>构建 RenderObject</li>
<li>将 RenderObject 挂载到 Render Tree 上</li>
</ul>
<h2 id="3-6、RenderObjectElement-attachRenderObject"><a href="#3-6、RenderObjectElement-attachRenderObject" class="headerlink" title="3.6、RenderObjectElement.attachRenderObject()"></a>3.6、RenderObjectElement.attachRenderObject()</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectElement</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;  </div><div class="line">	<span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> attachRenderObject(<span class="keyword">dynamic</span> newSlot) &#123;</div><div class="line">    _slot = newSlot;</div><div class="line">    <span class="comment">// Element Tree 向上遍历祖先节点，找到第一个 RenderObject 节点</span></div><div class="line">    _ancestorRenderObjectElement = _findAncestorRenderObjectElement();</div><div class="line">    <span class="comment">// 根据规则插入到 Render Tree 中，需要子类实现</span></div><div class="line">    _ancestorRenderObjectElement?.insertChildRenderObject(renderObject, newSlot);</div><div class="line">    <span class="comment">// Element Tree 向上遍历祖先节点，找到第一个 ParentDataElement 节点</span></div><div class="line">    <span class="keyword">final</span> ParentDataElement&lt;ParentData&gt; parentDataElement = _findAncestorParentDataElement();</div><div class="line">    <span class="keyword">if</span> (parentDataElement != <span class="keyword">null</span>)</div><div class="line">      _updateParentData(parentDataElement.widget);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">void</span> _updateParentData(ParentDataWidget&lt;ParentData&gt; parentDataWidget) &#123;</div><div class="line">    ...</div><div class="line">    parentDataWidget.applyParentData(renderObject);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Element Tree 向上遍历祖先节点，找到第一个 RenderObject 节点</li>
<li>根据规则插入到 Render Tree 中，需要子类实现，这里就<strong>构建出了 Render Tree</strong>，为下面 Layout、Paint 等过程做准备，下篇文章会详细分析</li>
<li>Element Tree 向上遍历祖先节点，找到第一个 ParentDataElement 节点，ParentDataElement 节点中记录着布局位置等信息，如果没有找到返回空</li>
<li>根据 ParentDataElement 找到对应的 ParentDataWidget，调用 <code>applyParentData()</code></li>
</ul>
<p>其中，<code>ParentDataElement</code> 根据参数绑定了 <code>ParentDataWidget</code> 类型，并通过泛型绑定了 ParentData 类型。</p>
<h3 id="3-6-1、ParentDataWidget-applyParentData"><a href="#3-6-1、ParentDataWidget-applyParentData" class="headerlink" title="3.6.1、ParentDataWidget.applyParentData()"></a>3.6.1、ParentDataWidget.applyParentData()</h3><p>ParentDataWidget 是 ProxyWidget 的子类，它的子类包括 Flexible、LayoutId、Positioned、KeepAlive 等Widget。</p>
<p>ParentDataWidget 使用泛型绑定了 ParentData 类型。</p>
<p>以 Flexible 为例看下实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flexible</span> <span class="keyword">extends</span> <span class="title">ParentDataWidget</span>&lt;<span class="title">FlexParentData</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> applyParentData(RenderObject renderObject) &#123;</div><div class="line">    <span class="keyword">final</span> FlexParentData parentData = renderObject.parentData <span class="keyword">as</span> FlexParentData;</div><div class="line">    <span class="built_in">bool</span> needsLayout = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (parentData.flex != flex) &#123;</div><div class="line">      parentData.flex = flex;</div><div class="line">      needsLayout = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (parentData.fit != fit) &#123;</div><div class="line">      parentData.fit = fit;</div><div class="line">      needsLayout = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (needsLayout) &#123;</div><div class="line">      <span class="keyword">final</span> AbstractNode targetParent = renderObject.parent;</div><div class="line">      <span class="keyword">if</span> (targetParent <span class="keyword">is</span> RenderObject)</div><div class="line">        targetParent.markNeedsLayout();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>更新布局属性信息</li>
<li>RenderObject 节点 Layout 标脏，记录在 <code>BuildOwner._nodesNeedingLayout</code> 列表中，等待下一步 Layout 处理</li>
</ul>
<h1 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h1><p>本篇文章介绍了 <code>WidgetsBinding.drawFrame()</code> 的过程，以及 Widget、Element、RenderObject 及三棵树的关系，梳理了<code>build()</code> 过程在三棵树之间的流转关系，通过 Element Tree 和 Widget Tree 构建 Render Tree，最终触发 RenderObject.markNeedsLayout()  Layout 标脏操作，记录在 <code>BuildOwner._nodesNeedingLayout</code> 列表中，等待下一步 Layout 处理。</p>
<p>下一篇文章将继续分析 Render Tree 的构建过程及 <code>RendererBinding.drawFrame()</code> 中 Layout 过程。</p>
<p>参考 </p>
<ul>
<li><p><a href="https://www.didierboelens.com/2019/09/flutter-internals/" target="_blank" rel="external">Flutter Internals</a></p>
</li>
<li><p><a href="https://blog.voiddog.org/1599449233776/" target="_blank" rel="external">谈谈 Flutter 的 build</a></p>
</li>
<li><p><a href="http://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/" target="_blank" rel="external">深入浅出 Flutter Framework 之 Element</a></p>
</li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2020/11/16/flutter-ui-build/">http://w4lle.com/2020/11/16/flutter-ui-build/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;系列文章的第四篇，本篇文章主要分析下 Element.rebuild() 过程。&lt;/p&gt;
&lt;p&gt;源码基于 Flutter v1.20.4。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://w4lle.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter UI 渲染浅析（三）Animation 原理</title>
    <link href="http://w4lle.com/2020/11/13/flutter-ui-animate/"/>
    <id>http://w4lle.com/2020/11/13/flutter-ui-animate/</id>
    <published>2020-11-13T10:45:24.000Z</published>
    <updated>2020-11-16T06:48:15.232Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章的第三篇，本篇文章主要分析下收到 VSync 信号回调后 Dart Framework 触发动画的过程及动画实现原理。</p>
<p>基于 Android 平台，Flutter v1.20.4。</p>
<a id="more"></a>
<p>在上一篇文章最后，我们提到做三件事情：</p>
<ul>
<li>执行 Dart Framework <code>dart:ui</code> 包下的 <code>_beginFrame()</code></li>
<li>执行 microtasks 任务</li>
<li>执行 Dart Framework <code>dart:ui</code> 包下的  <code>_drawFrame()</code></li>
</ul>
<p><code>dart:ui</code> 包下的两个方法的实现在 hooks.dart</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/ui/hooks.dart</span></div><div class="line"><span class="comment">// 没有直接引用，注解标记防止被 tree shaking干掉</span></div><div class="line"><span class="meta">@pragma</span>(<span class="string">'vm:entry-point'</span>)</div><div class="line"><span class="keyword">void</span> _beginFrame(<span class="built_in">int</span> microseconds) &#123;</div><div class="line">  <span class="comment">// 执行 window.onBeginFrame</span></div><div class="line">  _invoke1&lt;<span class="built_in">Duration</span>&gt;(<span class="built_in">window</span>.onBeginFrame, <span class="built_in">window</span>._onBeginFrameZone, <span class="built_in">Duration</span>(microseconds: microseconds));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@pragma</span>(<span class="string">'vm:entry-point'</span>)</div><div class="line"><span class="keyword">void</span> _drawFrame() &#123;</div><div class="line">  <span class="comment">// 执行 window.onDrawFrame</span></div><div class="line">  _invoke(<span class="built_in">window</span>.onDrawFrame, <span class="built_in">window</span>._onDrawFrameZone);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> _invoke(<span class="keyword">void</span> callback()?, Zone zone) &#123;</div><div class="line">	...</div><div class="line">    <span class="comment">// 运行 zone 未变，直接调用方法</span></div><div class="line">  <span class="keyword">if</span> (identical(zone, Zone.current)) &#123;</div><div class="line">    callback();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    zone.runGuarded(callback);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上篇文章中提到，<code>SchedulerBinding</code> 注册了 <code>window.onBeginFrame()</code> 和 <code>window.onDrawFrame()</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/scheduler/binding.dart</span></div><div class="line">  <span class="keyword">void</span> ensureFrameCallbacksRegistered() &#123;</div><div class="line">    <span class="comment">// 注册 onBeginFrame 、onDrawFrame 回调方法</span></div><div class="line">    <span class="built_in">window</span>.onBeginFrame ??= _handleBeginFrame;</div><div class="line">    <span class="built_in">window</span>.onDrawFrame ??= _handleDrawFrame;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>本篇文章先分析 <code>SchedulerBinding._handleBeginFrame()</code>。</p>
<h2 id="1、-handleBeginFrame"><a href="#1、-handleBeginFrame" class="headerlink" title="1、_handleBeginFrame()"></a>1、_handleBeginFrame()</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> _handleBeginFrame(<span class="built_in">Duration</span> rawTimeStamp) &#123;</div><div class="line">  <span class="keyword">if</span> (_warmUpFrame) &#123;</div><div class="line">    <span class="comment">// 如果是启动预热帧，忽略本次调用</span></div><div class="line">    _ignoreNextEngineDrawFrame = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  handleBeginFrame(rawTimeStamp);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是启动预热帧，忽略本次调用。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> handleBeginFrame(<span class="built_in">Duration</span> rawTimeStamp) &#123;</div><div class="line">  <span class="comment">// 开始记录 Frame 过程</span></div><div class="line">  Timeline.startSync(<span class="string">'Frame'</span>, arguments: timelineArgumentsIndicatingLandmarkEvent);</div><div class="line">  _firstRawTimeStampInEpoch ??= rawTimeStamp;</div><div class="line">  _currentFrameTimeStamp = _adjustForEpoch(rawTimeStamp ?? _lastRawTimeStamp);</div><div class="line">  <span class="keyword">if</span> (rawTimeStamp != <span class="keyword">null</span>)</div><div class="line">    _lastRawTimeStamp = rawTimeStamp;</div><div class="line"></div><div class="line">  <span class="keyword">assert</span>(() &#123;</div><div class="line">    <span class="comment">// 绘制次数 + 1</span></div><div class="line">    _debugFrameNumber += <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (debugPrintBeginFrameBanner || debugPrintEndFrameBanner) &#123;</div><div class="line">      <span class="keyword">final</span> <span class="built_in">StringBuffer</span> frameTimeStampDescription = <span class="built_in">StringBuffer</span>();</div><div class="line">      <span class="keyword">if</span> (rawTimeStamp != <span class="keyword">null</span>) &#123;</div><div class="line">        _debugDescribeTimeStamp(_currentFrameTimeStamp, frameTimeStampDescription);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        frameTimeStampDescription.write(<span class="string">'(warm-up frame)'</span>);</div><div class="line">      &#125;</div><div class="line">      _debugBanner = <span class="string">'▄▄▄▄▄▄▄▄ Frame <span class="subst">$&#123;_debugFrameNumber.toString().padRight(<span class="number">7</span>)&#125;</span>   <span class="subst">$&#123;frameTimeStampDescription.toString().padLeft(<span class="number">18</span>)&#125;</span> ▄▄▄▄▄▄▄▄'</span>;</div><div class="line">      <span class="keyword">if</span> (debugPrintBeginFrameBanner)</div><div class="line">        debugPrint(_debugBanner);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;());</div><div class="line"><span class="comment">//当前处于 SchedulerPhase.idle 状态</span></div><div class="line">  <span class="keyword">assert</span>(schedulerPhase == SchedulerPhase.idle);</div><div class="line">  <span class="comment">// 更新标志位，接收下次 scheduleFrame 请求</span></div><div class="line">  _hasScheduledFrame = <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// TRANSIENT FRAME CALLBACKS</span></div><div class="line">    <span class="comment">// 开始记录 Animate 过程</span></div><div class="line">    Timeline.startSync(<span class="string">'Animate'</span>, arguments: timelineArgumentsIndicatingLandmarkEvent);</div><div class="line">    _schedulerPhase = SchedulerPhase.transientCallbacks;</div><div class="line">    <span class="comment">// 执行 transientCallbacks 回调</span></div><div class="line">    <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">int</span>, _FrameCallbackEntry&gt; callbacks = _transientCallbacks;</div><div class="line">    <span class="comment">// 清空列表</span></div><div class="line">    _transientCallbacks = &lt;<span class="built_in">int</span>, _FrameCallbackEntry&gt;&#123;&#125;;</div><div class="line">    callbacks.forEach((<span class="built_in">int</span> id, _FrameCallbackEntry callbackEntry) &#123;</div><div class="line">      <span class="keyword">if</span> (!_removedIds.contains(id))</div><div class="line">        _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp, callbackEntry.debugStack);</div><div class="line">    &#125;);</div><div class="line">    _removedIds.clear();</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">//改变状态为 SchedulerPhase.midFrameMicrotasks</span></div><div class="line">    _schedulerPhase = SchedulerPhase.midFrameMicrotasks;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>TimeLine 开始记录 <code>Frame</code> 过程</li>
<li>如果 debugPrintBeginFrameBanner || debugPrintEndFrameBanner 打印绘制次数及时间</li>
<li>更新标志位 _hasScheduledFrame = false ，接收下次 scheduleFrame 请求</li>
<li>开始记录 Animate 过程</li>
<li>执行 <code>transientCallbacks</code> 瞬时帧回调，并清空回调列表，由 <code>WidgetsBinding.scheduleFrameCallback()</code> 注册</li>
<li>改变状态为 <code>SchedulerPhase.midFrameMicrotasks</code></li>
</ul>
<p>打印如下，打印的时间为距离首帧绘制的时间，<code>warm-up frame</code> 为 <code>runApp()</code> 启动过程中，<code>RenderView</code> 触发的预热帧，非 C ++ Engine 回调</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">I/flutter (<span class="number">14160</span>): ▄▄▄▄▄▄▄▄ Frame <span class="number">1</span>            (warm-up frame) ▄▄▄▄▄▄▄▄</div><div class="line">I/flutter (<span class="number">14160</span>): ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀</div><div class="line">D/PhoneWindow(<span class="number">14160</span>): setNavigationBarColor: ff000000</div><div class="line">I/flutter (<span class="number">14160</span>): ▄▄▄▄▄▄▄▄ Frame <span class="number">2</span>                        <span class="number">0</span>ms ▄▄▄▄▄▄▄▄</div><div class="line">I/flutter (<span class="number">14160</span>): ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀</div><div class="line">I/flutter (<span class="number">14160</span>): [verbose]: Add bucket <span class="keyword">in</span> <span class="keyword">set</span> from <span class="number">0</span></div><div class="line">I/flutter (<span class="number">14160</span>): ▄▄▄▄▄▄▄▄ Frame <span class="number">3</span>                  <span class="number">301.668</span>ms ▄▄▄▄▄▄▄▄</div><div class="line">I/flutter (<span class="number">14160</span>): ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀</div><div class="line">I/flutter (<span class="number">14160</span>): ▄▄▄▄▄▄▄▄ Frame <span class="number">4</span>                  <span class="number">402.225</span>ms ▄▄▄▄▄▄▄▄</div></pre></td></tr></table></figure>
<p><code>beginFrame()</code>主要是执行 <code>transientCallbacks</code> 瞬时帧回调，是由 <code>WidgetsBinding.scheduleFrameCallback</code> 注册，用来处理帧间动画计算和更新的工作，如果没有动画，则 <code>transientCallbacks</code> 为空。</p>
<p>先看下动画注册瞬时帧回调的过程。</p>
<h2 id="2、Flutter-Animation-动画原理"><a href="#2、Flutter-Animation-动画原理" class="headerlink" title="2、Flutter Animation 动画原理"></a>2、Flutter Animation 动画原理</h2><h3 id="2-1、主要类"><a href="#2-1、主要类" class="headerlink" title="2.1、主要类"></a>2.1、主要类</h3><p>Flutter 中的动画主要类结构如下图</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter_animation.png" alt=""></p>
<ul>
<li><code>Animation</code> 动画实现类，通过 <code>Ticker</code> 瞬时帧回调改变当前值，提供值回调和状态回调<ul>
<li>值回调 addListener(VoidCallback)</li>
<li>状态回调 addStatusListener(AnimationStatusListener)</li>
</ul>
</li>
<li><code>AnimationController</code> ，动画控制器，用于控制 <code>Animation</code> 运行状态，注册 <code>Ticker</code> 回调方法</li>
<li><code>Ticker</code> 用于注册 <code>SchedulerBinding.transientCallbacks</code> 回调，执行 <code>AnimationController</code> 注册的回调</li>
<li><code>TickerProvider</code> &amp; <code>SingleTickerProviderStateMixin</code>，提供默认的 <code>Ticker</code> 对象</li>
<li><code>AnimateWidget</code> &amp; <code>AnimateState</code> or  <code>AnimateBuilder</code>  动画 UI 展示，注册 <code>Animation</code> 值回调，自动触发 <code>setState()</code> ，混入<code>SingleTickerProviderStateMixin</code> 提供默认的 <code>Ticker</code> 对象，用于构建 <code>AnimationController</code> 动画控制器</li>
<li><code>Curve</code> 动画曲线可以控制时间的变化情况，类似于 Android 动画的插值器，默认是线性流逝，有以下几种类型，效果参考 <a href="https://api.flutter.dev/flutter/animation/Curves-class.html" target="_blank" rel="external">官网 Curves-class</a><ul>
<li>linear</li>
<li>decelerate</li>
<li>ease</li>
<li>easeIn</li>
<li>easeOut</li>
<li>easeInOut</li>
<li>fastOutSlowIn</li>
<li>bounceIn</li>
<li>bounceOut</li>
<li>bounceInOut</li>
<li>elasticIn</li>
<li>elasticOut</li>
<li>elasticInOut</li>
</ul>
</li>
<li><code>Tween</code> 动画取值计算出当前时间 <code>t</code> 对应的泛型值，有以下几个子类<ul>
<li>ReverseTween</li>
<li>ColorTween</li>
<li>SizeTween</li>
<li>RectTween</li>
<li>IntTween</li>
<li>StepTween</li>
<li>ConstantTween</li>
</ul>
</li>
<li><code>AnimationStatus</code> 动画状态机，含有四个状态<ul>
<li>dismissed：动画暂未开始</li>
<li>forward：动画正向运行</li>
<li>reverse：动画反向运行</li>
<li>complete：动画完成状态</li>
</ul>
</li>
<li><code>Simulation</code> 物理模拟器，位于<code>physics</code> 包下，用于模拟物理运动，提供以下信息<ul>
<li>位置信息 x</li>
<li>速度d(x)</li>
<li>是否完成 isDone </li>
</ul>
</li>
</ul>
<h3 id="2-2、官方例子"><a href="#2-2、官方例子" class="headerlink" title="2.2、官方例子"></a>2.2、官方例子</h3><p>在 Flutter 中可以使用 <code>AnimateWidget</code> or <code>AnimateBuilder</code> 构建一个动画，如下</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogoApp</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</div><div class="line">  _LogoAppState createState() =&gt; _LogoAppState();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">_LogoAppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">LogoApp</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</div><div class="line">  Animation&lt;<span class="built_in">double</span>&gt; animation;</div><div class="line">  AnimationController controller;</div><div class="line"></div><div class="line">  <span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> initState() &#123;</div><div class="line">    <span class="keyword">super</span>.initState();</div><div class="line">    controller =</div><div class="line">        AnimationController(duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>), vsync: <span class="keyword">this</span>);</div><div class="line">    animation = Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0</span>, end: <span class="number">300</span>).animate(controller);</div><div class="line">    controller.forward();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@override</span>        </div><div class="line">  Widget build(BuildContext context) =&gt; AnimatedLogo(animation: animation);</div><div class="line"></div><div class="line">  <span class="meta">@override</span>            </div><div class="line">  <span class="keyword">void</span> dispose() &#123;            </div><div class="line">    controller.dispose();            </div><div class="line">    <span class="keyword">super</span>.dispose();            </div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimatedLogo</span> <span class="keyword">extends</span> <span class="title">AnimatedWidget</span> </span>&#123;</div><div class="line">  AnimatedLogo(&#123;Key key, Animation&lt;<span class="built_in">double</span>&gt; animation&#125;)</div><div class="line">      : <span class="keyword">super</span>(key: key, listenable: animation);</div><div class="line"></div><div class="line">  Widget build(BuildContext context) &#123;</div><div class="line">    <span class="keyword">final</span> animation = listenable <span class="keyword">as</span> Animation&lt;<span class="built_in">double</span>&gt;;</div><div class="line">    <span class="keyword">return</span> Center(</div><div class="line">      child: Container(</div><div class="line">        margin: EdgeInsets.symmetric(vertical: <span class="number">10</span>),</div><div class="line">        height: animation.value,</div><div class="line">        width: animation.value,</div><div class="line">        child: FlutterLogo(),</div><div class="line">      ),</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>跟下构建流程。</p>
<h3 id="2-3、AnimationController"><a href="#2-3、AnimationController" class="headerlink" title="2.3、AnimationController"></a>2.3、AnimationController</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">AnimationController(&#123;</div><div class="line">  <span class="built_in">double</span> value,</div><div class="line">  <span class="keyword">this</span>.duration,<span class="comment">// 动画时长</span></div><div class="line">  <span class="keyword">this</span>.reverseDuration,</div><div class="line">  <span class="keyword">this</span>.debugLabel,</div><div class="line">  <span class="keyword">this</span>.lowerBound = <span class="number">0.0</span>, <span class="comment">// 默认是 0.0 - 1.0</span></div><div class="line">  <span class="keyword">this</span>.upperBound = <span class="number">1.0</span>,</div><div class="line">  <span class="keyword">this</span>.animationBehavior = AnimationBehavior.normal,</div><div class="line">  <span class="comment">// TickerProvider 对象，一般为混入了 SingleTickerProviderStateMixin 的 State 类对象</span></div><div class="line">  <span class="meta">@required</span> TickerProvider vsync,</div><div class="line">&#125;) : <span class="keyword">assert</span>(lowerBound != <span class="keyword">null</span>),</div><div class="line">     <span class="keyword">assert</span>(upperBound != <span class="keyword">null</span>),</div><div class="line">     <span class="keyword">assert</span>(upperBound &gt;= lowerBound),</div><div class="line">     <span class="keyword">assert</span>(vsync != <span class="keyword">null</span>),</div><div class="line">     _direction = _AnimationDirection.forward &#123;</div><div class="line">  <span class="comment">//构建 Ticker 对象</span></div><div class="line">  _ticker = vsync.createTicker(_tick);</div><div class="line">  <span class="comment">// 更新状态和动画值</span></div><div class="line">  _internalSetValue(value ?? lowerBound);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>提供动画时长</li>
<li>提供 TickerProvider 对象，一般为混入了 SingleTickerProviderStateMixin 的 State 类对象</li>
<li>构建 Ticker 对象，注册回调方法 <code>_tick()</code></li>
</ul>
<p>当调用 <code>AnimationController.forward()</code> 方式</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/animation/animation_controller.dart</span></div><div class="line">	TickerFuture forward(&#123; <span class="built_in">double</span> from &#125;) &#123;</div><div class="line">		...</div><div class="line">    <span class="comment">// 正向运行</span></div><div class="line">    _direction = _AnimationDirection.forward;</div><div class="line">    <span class="keyword">if</span> (from != <span class="keyword">null</span>)</div><div class="line">      value = from;</div><div class="line">    <span class="keyword">return</span> _animateToInternal(upperBound);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  TickerFuture _animateToInternal(<span class="built_in">double</span> target, &#123; <span class="built_in">Duration</span> duration, Curve curve = Curves.linear &#125;) &#123; </div><div class="line">    <span class="comment">// 默认线性曲线</span></div><div class="line">    <span class="built_in">double</span> scale = <span class="number">1.0</span>;</div><div class="line">		...</div><div class="line">    <span class="built_in">Duration</span> simulationDuration = duration;</div><div class="line">    <span class="keyword">if</span> (simulationDuration == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">final</span> <span class="built_in">double</span> range = upperBound - lowerBound;</div><div class="line">      <span class="keyword">final</span> <span class="built_in">double</span> remainingFraction = range.isFinite ? (target - _value).abs() / range : <span class="number">1.0</span>;</div><div class="line">      <span class="keyword">final</span> <span class="built_in">Duration</span> directionDuration =</div><div class="line">        (_direction == _AnimationDirection.reverse &amp;&amp; reverseDuration != <span class="keyword">null</span>)</div><div class="line">        ? reverseDuration</div><div class="line">        : <span class="keyword">this</span>.duration;</div><div class="line">      simulationDuration = directionDuration * remainingFraction;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target == value) &#123;</div><div class="line">      <span class="comment">// Already at target, don't animate.</span></div><div class="line">      simulationDuration = <span class="built_in">Duration</span>.zero;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 停止老的动画</span></div><div class="line">    stop();</div><div class="line">    <span class="keyword">if</span> (simulationDuration == <span class="built_in">Duration</span>.zero) &#123;</div><div class="line">      <span class="keyword">if</span> (value != target) &#123;</div><div class="line">        <span class="comment">// 更新值，通知回调</span></div><div class="line">        _value = target.clamp(lowerBound, upperBound) <span class="keyword">as</span> <span class="built_in">double</span>;</div><div class="line">        notifyListeners();</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 改变状态</span></div><div class="line">      _status = (_direction == _AnimationDirection.forward) ?</div><div class="line">        AnimationStatus.completed :</div><div class="line">        AnimationStatus.dismissed;</div><div class="line">      _checkStatusChanged();</div><div class="line">      <span class="keyword">return</span> TickerFuture.complete();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 构建一个 Simulation 物理模拟器对象，使用线性曲线</span></div><div class="line">    <span class="keyword">return</span> _startSimulation(_InterpolationSimulation(_value, target, simulationDuration, curve, scale));</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>构建一个 <code>Simulation</code> 物理模拟器对象，这里使用线性模拟，内部使用的是 <code>Curves.linear</code> 实现。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/animation/animation_controller.dart</span></div><div class="line">	TickerFuture _startSimulation(Simulation simulation) &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 通过模拟器获取值</span></div><div class="line">    _value = simulation.x(<span class="number">0.0</span>).clamp(lowerBound, upperBound) <span class="keyword">as</span> <span class="built_in">double</span>;</div><div class="line">    <span class="comment">// ticker 开始工作</span></div><div class="line">    <span class="keyword">final</span> TickerFuture result = _ticker.start();</div><div class="line">    <span class="comment">// 更新状态</span></div><div class="line">    _status = (_direction == _AnimationDirection.forward) ?</div><div class="line">      AnimationStatus.forward :</div><div class="line">      AnimationStatus.reverse;</div><div class="line">    _checkStatusChanged();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line">	</div><div class="line">	<span class="comment">// 检查状态变化</span></div><div class="line">  <span class="keyword">void</span> _checkStatusChanged() &#123;</div><div class="line">    <span class="keyword">final</span> AnimationStatus newStatus = status;</div><div class="line">    <span class="keyword">if</span> (_lastReportedStatus != newStatus) &#123;</div><div class="line">      _lastReportedStatus = newStatus;</div><div class="line">      notifyStatusListeners(newStatus);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="2-4、Ticker"><a href="#2-4、Ticker" class="headerlink" title="2.4、Ticker"></a>2.4、Ticker</h3><p><code>Ticker</code> 开始工作</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/schedule/ticker.dart</span></div><div class="line">	TickerFuture start() &#123;</div><div class="line">    _future = TickerFuture._();</div><div class="line">    <span class="keyword">if</span> (shouldScheduleTick) &#123;</div><div class="line">      <span class="comment">// 触发 tick 事件</span></div><div class="line">      scheduleTick();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (SchedulerBinding.instance.schedulerPhase.index &gt; SchedulerPhase.idle.index &amp;&amp;</div><div class="line">        SchedulerBinding.instance.schedulerPhase.index &lt; SchedulerPhase.postFrameCallbacks.index)</div><div class="line">      <span class="comment">// Scheduler状态在 idle 和 postFrameCallbacks 之间，即在绘制状态中</span></div><div class="line">      _startTime = SchedulerBinding.instance.currentFrameTimeStamp;</div><div class="line">    <span class="keyword">return</span> _future;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@protected</span></div><div class="line">  <span class="keyword">void</span> scheduleTick(&#123; <span class="built_in">bool</span> rescheduling = <span class="keyword">false</span> &#125;) &#123;</div><div class="line">    <span class="comment">// 加入到 _transientCallbacks 队列中，等待回调 _tick 方法</span></div><div class="line">    _animationId = SchedulerBinding.instance.scheduleFrameCallback(_tick, rescheduling: rescheduling);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>加入到 <code>SchedulerBinding._transientCallbacks</code> 队列中，等待回调 <code>_tick</code> 方法</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/scheduler/binding.dart</span></div><div class="line">	<span class="built_in">int</span> scheduleFrameCallback(FrameCallback callback, &#123; <span class="built_in">bool</span> rescheduling = <span class="keyword">false</span> &#125;) &#123;</div><div class="line">    <span class="comment">// 请求绘制</span></div><div class="line">    scheduleFrame();</div><div class="line">    _nextFrameCallbackId += <span class="number">1</span>;</div><div class="line">    <span class="comment">// 加入 _transientCallbacks 队列</span></div><div class="line">    _transientCallbacks[_nextFrameCallbackId] = _FrameCallbackEntry(callback, rescheduling: rescheduling);</div><div class="line">    <span class="keyword">return</span> _nextFrameCallbackId;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>请求绘制</li>
<li>加入 _transientCallbacks 队列</li>
</ul>
<p><code>Ticker._tick()</code> 方法</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/schedule/ticker.dart</span></div><div class="line">	<span class="keyword">void</span> _tick(<span class="built_in">Duration</span> timeStamp) &#123;</div><div class="line">    _animationId = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    _startTime ??= timeStamp;</div><div class="line">    <span class="comment">// 回调 AnimationController 注册的回调方法</span></div><div class="line">    _onTick(timeStamp - _startTime);</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (shouldScheduleTick)</div><div class="line">      <span class="comment">// 再次注册 _transientCallbacks 回调</span></div><div class="line">      scheduleTick(rescheduling: <span class="keyword">true</span>);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>回调 <code>AnimationController</code> 构建 <code>Ticker</code> 对象时注册的回调方法 <code>_tick()</code></li>
<li>再次注册 <code>_transientCallbacks</code> 回调，等待触发再次注册… 直到动画完成或停止</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/animation/animation_controller.dart</span></div><div class="line">	<span class="keyword">void</span> _tick(<span class="built_in">Duration</span> elapsed) &#123;</div><div class="line">    _lastElapsedDuration = elapsed;</div><div class="line">    <span class="keyword">final</span> <span class="built_in">double</span> elapsedInSeconds = elapsed.inMicroseconds.toDouble() / <span class="built_in">Duration</span>.microsecondsPerSecond;</div><div class="line">    <span class="comment">// 更新动画值</span></div><div class="line">    _value = _simulation.x(elapsedInSeconds).clamp(lowerBound, upperBound) <span class="keyword">as</span> <span class="built_in">double</span>;</div><div class="line">    <span class="comment">// 更新动画状态</span></div><div class="line">    <span class="keyword">if</span> (_simulation.isDone(elapsedInSeconds)) &#123;</div><div class="line">      _status = (_direction == _AnimationDirection.forward) ?</div><div class="line">        AnimationStatus.completed :</div><div class="line">        AnimationStatus.dismissed;</div><div class="line">      stop(canceled: <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 通知监听</span></div><div class="line">    notifyListeners();</div><div class="line">    _checkStatusChanged();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="2-5、刷新界面"><a href="#2-5、刷新界面" class="headerlink" title="2.5、刷新界面"></a>2.5、刷新界面</h3><p>在 <code>AnimatedWidget</code> 或 <code>AnimatedBuilder</code> 对应的 State 中，会对 <code>Animation</code> 注册动画监听</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/widgets/trasitions.dart</span></div><div class="line">	<span class="keyword">void</span> initState() &#123;</div><div class="line">    <span class="keyword">super</span>.initState();</div><div class="line">    widget.listenable.addListener(_handleChange);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">void</span> _handleChange() &#123;</div><div class="line">    <span class="comment">// element 标脏，触发绘制</span></div><div class="line">    setState(() &#123;</div><div class="line">      <span class="comment">// The listenable's state is our build state, and it changed already.</span></div><div class="line">    &#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>通过 <code>Animation</code> 的回调方法触发界面刷新</li>
<li>Widget 通过 <code>Animation</code> 对象获取对应的值</li>
<li><code>setState()</code> 标脏 element，下一次 VSync 信号到来触发 rebuild()</li>
</ul>
<p>调用过程：</p>
<p><code>AnimationController.forward()</code> -&gt; <code>Ticker.start()</code> -&gt; <code>Ticker.scheduleTick()</code> -&gt; <code>Ticker._tick()</code> -&gt; <code>AnimationController._tick()</code> -&gt; <code>Widget.build()</code> -&gt; <code>Ticker.scheduleTick()</code> …</p>
<p>不断的触发刷新 -&gt; 更新动画值 -&gt; element.rebuild() -&gt; 触发刷新… 直到动画完成或停止。</p>
<h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>Dart Framework 触发 Engine 渲染管线开始绘制流程，回调给 Dart Framework，通过 <code>SchedulerBinding</code> 调度 UI 绘制。</p>
<p>其中的第一个操作是更新 <code>_transientCallbacks</code> 回调，该回调在动画过程中被使用。</p>
<p><code>Animation</code> 动画在 <code>SchedulerBinding</code>  和 <code>Ticker</code> 的驱动下，循环往复的不停运转，直到动画完成或被调用停止。</p>
<p>下一篇文章分析 element.rebuild() 的过程。</p>
<p>本文链接： <a href="http://w4lle.com/2020/11/13/flutter-ui-animate/">http://w4lle.com/2020/11/13/flutter-ui-animate/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;系列文章的第三篇，本篇文章主要分析下收到 VSync 信号回调后 Dart Framework 触发动画的过程及动画实现原理。&lt;/p&gt;
&lt;p&gt;基于 Android 平台，Flutter v1.20.4。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://w4lle.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter UI 渲染浅析（二）VSync 注册</title>
    <link href="http://w4lle.com/2020/11/11/flutter-ui-vsync/"/>
    <id>http://w4lle.com/2020/11/11/flutter-ui-vsync/</id>
    <published>2020-11-11T10:31:21.000Z</published>
    <updated>2021-01-15T10:43:41.749Z</updated>
    
    <content type="html"><![CDATA[<p>在 Flutter App 启动过程或者 State 刷新过程中，会请求注册 VSync 信号。</p>
<p>本篇文章主要分析下 VSync 信号注册以及回调过程。</p>
<p>基于 Android 平台，Flutter v1.20.4。</p>
<a id="more"></a>
<p>调用时序图</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter_vsync.png" alt=""></p>
<h2 id="1、Flutter-App-启动"><a href="#1、Flutter-App-启动" class="headerlink" title="1、Flutter App 启动"></a>1、Flutter App 启动</h2><p>Flutter App 启动过程中调用 <code>runApp()</code>方法</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/widgets/binding.dart</span></div><div class="line"><span class="keyword">void</span> runApp(Widget app) &#123;</div><div class="line">  WidgetsFlutterBinding.ensureInitialized()</div><div class="line">    ..scheduleAttachRootWidget(app)</div><div class="line">    ..scheduleWarmUpFrame();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetsFlutterBinding</span> <span class="keyword">extends</span> <span class="title">BindingBase</span> <span class="title">with</span> <span class="title">GestureBinding</span>, <span class="title">SchedulerBinding</span>, <span class="title">ServicesBinding</span>, <span class="title">PaintingBinding</span>, <span class="title">SemanticsBinding</span>, <span class="title">RendererBinding</span>, <span class="title">WidgetsBinding</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> WidgetsBinding ensureInitialized() &#123;</div><div class="line">    <span class="keyword">if</span> (WidgetsBinding.instance == <span class="keyword">null</span>)</div><div class="line">      WidgetsFlutterBinding();</div><div class="line">    <span class="keyword">return</span> WidgetsBinding.instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>runApp()</code>过程中初始化 <code>WidgetsFlutterBinding</code>，它是 Dart Framework 和 C++ Engine 之间的胶水层，并且混入了 7 个Binding 类，用于初始化 7 个 Binding 类。</p>
<p>上文中我们提到，<code>Window</code> 是 <code>dart:ui</code> 包中最重要的类，通过  <code>Window</code>  建立起了建立 Dart Framework 和 C++ Engine 的通讯连接，<code>Window</code> 在 Flutter Framework 和 C++ Engine 中分别存在，并通过 <code>ffi</code> 互相调用。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</div><div class="line">  <span class="comment">// 当窗口绘制区域变化时回调，比如[devicePixelRatio],</span></div><div class="line">  <span class="comment">/// [physicalSize], [padding], [viewInsets], or [systemGestureInsets]变化</span></div><div class="line">  VoidCallback? <span class="keyword">get</span> onMetricsChanged =&gt; _onMetricsChanged;</div><div class="line">  <span class="comment">// 当语言环境发生变化时回调</span></div><div class="line">  VoidCallback? <span class="keyword">get</span> onLocaleChanged =&gt; _onLocaleChanged;</div><div class="line">  <span class="comment">// 当系统字体缩放变化时回调</span></div><div class="line">  VoidCallback <span class="keyword">get</span> onTextScaleFactorChanged =&gt; _onTextScaleFactorChanged;</div><div class="line">  <span class="comment">// 绘制前回调，一般在收到 VSync 信号后回调，或者在App启动首帧主动调用</span></div><div class="line">  FrameCallback <span class="keyword">get</span> onBeginFrame =&gt; _onBeginFrame;</div><div class="line">  <span class="comment">// 绘制回调，一般在 onBeginFrame 和 microtask 执行完后执行，或者在App启动首帧主动调用</span></div><div class="line">  VoidCallback <span class="keyword">get</span> onDrawFrame =&gt; _onDrawFrame;</div><div class="line">  <span class="comment">// 绘制时间回调，用于计算fps</span></div><div class="line">  TimingsCallback? <span class="keyword">get</span> onReportTimings =&gt; _onReportTimings;</div><div class="line">  <span class="comment">// 点击或指针事件回调</span></div><div class="line">  PointerDataPacketCallback <span class="keyword">get</span> onPointerDataPacket =&gt; _onPointerDataPacket;</div><div class="line">  <span class="comment">// 触发 Engine Pipeline 渲染管线工作，注册 VSync 信号回调，当 VSync 信号到来时</span></div><div class="line">  <span class="comment">// onBeginFrame和onDrawFrame 会被调用</span></div><div class="line">  <span class="keyword">void</span> scheduleFrame() native <span class="string">'Window_scheduleFrame'</span>;</div><div class="line">  <span class="comment">// 触发 RasterThread 执行光栅化合成</span></div><div class="line">  <span class="keyword">void</span> render(Scene scene) native <span class="string">'Window_render'</span>;</div><div class="line">  <span class="comment">// 发送平台消息</span></div><div class="line">  <span class="keyword">void</span> sendPlatformMessage(<span class="built_in">String</span> name,</div><div class="line">                           ByteData data,</div><div class="line">                           PlatformMessageResponseCallback callback) ;</div><div class="line">  <span class="comment">// 平台通道消息处理回调  </span></div><div class="line">  PlatformMessageCallback <span class="keyword">get</span> onPlatformMessage =&gt; _onPlatformMessage;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>Window</code> 中存在一些回调方法，由 C++ Engine 触发回调方法，触发 Flutter Framework 执行相应动作。</p>
<p>这些回调方法分散注册在 7 个 Binding 类中。</p>
<ul>
<li>SchedulerBinding，渲染任务调度器，注册 <code>onBeginFrame</code> 、 <code>onDrawFrame</code> 、<code>onReportTimings</code> 等回调，用于调度渲染流程、计算绘制耗时</li>
<li>WidgetsBinding，是视图层和 Flutter Engine 之间的胶水层，用于管理三棵树的构建和更新操作；注册 <code>window.onLocaleChanged</code>、<code>onBuildScheduled</code> 回调；持有 BuilderOwner 对象</li>
<li>RendererBinding，是绘制树 (Render Tree) 和 Flutter Engine 之间的胶水层，用于布局和绘制，核心方法<code>drawFrame()</code>；注册 <code>window.onMetricsChanged</code> 、<code>window.onTextScaleFactorChanged</code>  等回调；持有 PipelineOwner 对象</li>
<li>PaintingBinding，绑定绘制库，主要用于处理图片缓存</li>
<li>ServicesBinding，注册<code>window.onPlatformMessage</code> 回调， 用于绑定平台消息通道（message channel），处理原生和 Flutter 通信</li>
<li>GestureBinding，注册 <code>window.onPointerDataPacket</code> 回调，绑定Framework手势子系统，是Framework事件模型与底层事件的绑定入口</li>
<li>SemanticsBinding，语义化层与Flutter engine的桥梁，主要是辅助功能的底层支持</li>
</ul>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesinternals_bindings.png" alt=""></p>
<p>重点关注 <code>SchedulerBinding</code>、<code>WidgetsBinding</code>、<code>RendererBinding</code> 及他们注册的回调方法。</p>
<h2 id="2、scheduleFrame"><a href="#2、scheduleFrame" class="headerlink" title="2、scheduleFrame"></a>2、scheduleFrame</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/widgets/binding.dart</span></div><div class="line"><span class="keyword">void</span> runApp(Widget app) &#123;</div><div class="line">  WidgetsFlutterBinding.ensureInitialized()</div><div class="line">    ..scheduleAttachRootWidget(app)</div><div class="line">    ..scheduleWarmUpFrame();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>runApp()</code> 启动方法中</p>
<ul>
<li><code>scheduleAttachRootWidget(app)</code> 首先构建三棵树，并且通过 <code>BuildOwner</code> 调用 <code>scheduleFrame()</code> 触发注册 VSync 信号</li>
<li><code>scheduleWarmUpFrame()</code> 准备第一帧的绘制工作，触发 <code>beginFrame()</code> 和 <code>drawFrame()</code> 执行方法，这样就不用等待 VSync 信号回调，可以尽快的绘制第一帧</li>
</ul>
<p>同样的，在 <code>State.setState()</code> 方法中也会触发 <code>ScheduleFrame()</code> 方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/widgets/framework.dart </span></div><div class="line"></div><div class="line"><span class="comment">// State</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span>&gt; <span class="title">with</span> <span class="title">Diagnosticable</span> </span>&#123;</div><div class="line">	<span class="keyword">void</span> setState(VoidCallback fn) &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 调用callback</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">dynamic</span> result = fn() <span class="keyword">as</span> <span class="keyword">dynamic</span>;</div><div class="line">    ...</div><div class="line">    <span class="comment">// element 标脏</span></div><div class="line">    _element.markNeedsBuild();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Element</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> <span class="keyword">implements</span> <span class="title">BuildContext</span> </span>&#123;</div><div class="line">  <span class="keyword">void</span> markNeedsBuild() &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 防止重复标脏</span></div><div class="line">    <span class="keyword">if</span> (dirty)</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    _dirty = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">// 触发绘制</span></div><div class="line">    owner.scheduleBuildFor(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// BuildOwner</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildOwner</span> </span>&#123;</div><div class="line">  <span class="keyword">void</span> scheduleBuildFor(<span class="built_in">Element</span> element) &#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> (!_scheduledFlushDirtyElements &amp;&amp; onBuildScheduled != <span class="keyword">null</span>) &#123;</div><div class="line">      _scheduledFlushDirtyElements = <span class="keyword">true</span>;</div><div class="line">      <span class="comment">// 调用scheduleFrame</span></div><div class="line">      onBuildScheduled();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 添加到 _dirtyElements 脏列表</span></div><div class="line">    _dirtyElements.add(element);</div><div class="line">    element._inDirtyList = <span class="keyword">true</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>最终会调用到 <code>BuildOwner.onBuildScheduled()</code> ，这个回调方法是在 <code>WidgetsBinding.initInstances()</code> 初始化过程中中注册的。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/widgets/binding.dart WidgetsBinding</span></div><div class="line">mixin WidgetsBinding on BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding &#123;</div><div class="line">  <span class="meta">@override</span></div><div class="line">  <span class="keyword">void</span> initInstances() &#123;</div><div class="line">    <span class="keyword">super</span>.initInstances();</div><div class="line">    _instance = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">//构造BuildeOwner，主要负责Widget的build过程</span></div><div class="line">    _buildOwner = BuildOwner();</div><div class="line">    <span class="comment">// 注册 onBuildScheduled 回调</span></div><div class="line">    buildOwner.onBuildScheduled = _handleBuildScheduled;</div><div class="line">    <span class="comment">//注册window相关回调</span></div><div class="line">    <span class="built_in">window</span>.onLocaleChanged = handleLocaleChanged;</div><div class="line">    <span class="built_in">window</span>.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged;</div><div class="line">  	<span class="comment">//导航channel  </span></div><div class="line">    SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation);</div><div class="line">    FlutterErrorDetails.propertiesTransformers.add(transformDebugCreator);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">void</span> _handleBuildScheduled() &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 交给 SchedulerBinding 调度处理</span></div><div class="line">    ensureVisualUpdate();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>交给 <code>SchedulerBinding</code> 调度处理</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/src/scheduler/binding.dart</span></div><div class="line">	<span class="keyword">void</span> ensureVisualUpdate() &#123;</div><div class="line">    <span class="keyword">switch</span> (schedulerPhase) &#123;</div><div class="line">      <span class="keyword">case</span> SchedulerPhase.idle:</div><div class="line">      <span class="keyword">case</span> SchedulerPhase.postFrameCallbacks:</div><div class="line">        <span class="comment">// 调用</span></div><div class="line">        scheduleFrame();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      <span class="keyword">case</span> SchedulerPhase.transientCallbacks:</div><div class="line">      <span class="keyword">case</span> SchedulerPhase.midFrameMicrotasks:</div><div class="line">      <span class="keyword">case</span> SchedulerPhase.persistentCallbacks:</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">void</span> scheduleFrame() &#123;</div><div class="line">    <span class="comment">//防止重复注册</span></div><div class="line">    <span class="keyword">if</span> (_hasScheduledFrame || !framesEnabled)</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    <span class="comment">// 注册回调方法</span></div><div class="line">    ensureFrameCallbacksRegistered();</div><div class="line">    <span class="comment">// 通过window，调用Engine scheduleFrame</span></div><div class="line">    <span class="built_in">window</span>.scheduleFrame();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">void</span> ensureFrameCallbacksRegistered() &#123;</div><div class="line">    <span class="comment">// 注册 onBeginFrame 、onDrawFrame 回调方法</span></div><div class="line">    <span class="built_in">window</span>.onBeginFrame ??= _handleBeginFrame;</div><div class="line">    <span class="built_in">window</span>.onDrawFrame ??= _handleDrawFrame;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>通过 <code>window</code>  调用Engine <code>Window ::scheduleFrame()</code> Native 方法，并注册 <code>onBeginFrame</code> 、<code>onDrawFrame</code>  回调方法。</p>
<p>看下 <code>SchedulerBinding</code> 的状态机，这里是和 C++ Engine 中的回调过程一一对应的，后面会看到。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> SchedulerPhase &#123;</div><div class="line">  <span class="comment">//空闲状态</span></div><div class="line">  idle,</div><div class="line"></div><div class="line">  <span class="comment">//调用瞬时回调状态，主要处理动画计算机更新等任务，由WidgetsBinding.scheduleFrameCallback注册回调</span></div><div class="line">  transientCallbacks,</div><div class="line"></div><div class="line">  <span class="comment">//处理transientCallbacks阶段注册的微任务microtasks</span></div><div class="line">  midFrameMicrotasks,</div><div class="line"></div><div class="line">  <span class="comment">//build/layout/paint阶段，同时处理WidgetsBinding.addPersistentFrameCallback注册的persistentCallbacks</span></div><div class="line">  persistentCallbacks,</div><div class="line"></div><div class="line">  <span class="comment">//绘制完成，处理一些清理工作，同时处理WidgetsBinding.addPostFrameCallback注册的postFrameCallbacks，App层可以在这里处理一些绘制完成后的工作</span></div><div class="line">  postFrameCallbacks,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3、dart-ffi"><a href="#3、dart-ffi" class="headerlink" title="3、dart:ffi"></a>3、dart:ffi</h2><p>在 Flutter 中，可以使用 <code>dart:ffi</code> 实现 Dart 方法和 Native 方法的互相调用绑定，类似于 Java 的 <code>JNI</code>。</p>
<p>在 Engine <code>Window</code> 类中，通过 <code>dart:ffi</code> 注册 <code>Native</code> 方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// flutter/lib/ui/window/window.cc</span></div><div class="line"><span class="keyword">void</span> Window::RegisterNatives(tonic::DartLibraryNatives* natives) &#123;</div><div class="line">  natives-&gt;Register(&#123;</div><div class="line">    	<span class="comment">// 默认路由 '/'</span></div><div class="line">      &#123;<span class="string">"Window_defaultRouteName"</span>, DefaultRouteName, <span class="number">1</span>, <span class="literal">true</span>&#125;,</div><div class="line">    	<span class="comment">// 触发绘制</span></div><div class="line">        &#123;<span class="string">"Window_scheduleFrame"</span>, ScheduleFrame, <span class="number">1</span>, <span class="literal">true</span>&#125;,</div><div class="line">    	<span class="comment">// 发送消息回调</span></div><div class="line">      &#123;<span class="string">"Window_sendPlatformMessage"</span>, _SendPlatformMessage, <span class="number">4</span>, <span class="literal">true</span>&#125;,</div><div class="line">    	<span class="comment">// 回调消息</span></div><div class="line">      &#123;<span class="string">"Window_respondToPlatformMessage"</span>, _RespondToPlatformMessage, <span class="number">3</span>, <span class="literal">true</span>&#125;,</div><div class="line">    	<span class="comment">// 光栅化合成</span></div><div class="line">      &#123;<span class="string">"Window_render"</span>, Render, <span class="number">2</span>, <span class="literal">true</span>&#125;,</div><div class="line">      &#123;<span class="string">"Window_updateSemantics"</span>, UpdateSemantics, <span class="number">2</span>, <span class="literal">true</span>&#125;,</div><div class="line">      &#123;<span class="string">"Window_setIsolateDebugName"</span>, SetIsolateDebugName, <span class="number">2</span>, <span class="literal">true</span>&#125;,</div><div class="line">    	<span class="comment">// 上报异常</span></div><div class="line">      &#123;<span class="string">"Window_reportUnhandledException"</span>, ReportUnhandledException, <span class="number">2</span>, <span class="literal">true</span>&#125;,</div><div class="line">      &#123;<span class="string">"Window_setNeedsReportTimings"</span>, SetNeedsReportTimings, <span class="number">2</span>, <span class="literal">true</span>&#125;,</div><div class="line">      ...</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>列表中的参数：</p>
<ul>
<li>第一个参数是 Dart 方法id</li>
<li>第二个参数是 Engine 中 <code>Native</code> 方法的指针，一般以 <code>_</code> 开头的方法是 Dart 注册的回调方法或者需要回调的方法</li>
<li>第三个参数是方法参数个数</li>
<li>第四个参数为是否自动注册</li>
</ul>
<p>在 <code>DartVM</code> 启动过程中，将 Native 方法注册到 <code>dart:ffi</code>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// flutter/lib/ui/dart_ui.cc</span></div><div class="line"><span class="keyword">using</span> tonic::ToDart;</div><div class="line"></div><div class="line"><span class="keyword">namespace</span> flutter &#123;</div><div class="line"><span class="keyword">namespace</span> &#123;</div><div class="line"></div><div class="line"><span class="comment">// 注册Native方法列表</span></div><div class="line"><span class="keyword">static</span> tonic::DartLibraryNatives* g_natives;</div><div class="line"></div><div class="line"><span class="comment">// 用的时候来查表</span></div><div class="line"><span class="function">Dart_NativeFunction <span class="title">GetNativeFunction</span><span class="params">(Dart_Handle name,</span></span></div><div class="line">                                      <span class="keyword">int</span> argument_count,</div><div class="line">                                      <span class="keyword">bool</span>* auto_setup_scope) &#123;</div><div class="line">  <span class="keyword">return</span> g_natives-&gt;GetNativeFunction(name, argument_count, auto_setup_scope);</div><div class="line">&#125;</div><div class="line"><span class="comment">//获取 Dart 方法id</span></div><div class="line"><span class="function"><span class="keyword">const</span> uint8_t* <span class="title">GetSymbol</span><span class="params">(Dart_NativeFunction native_function)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> g_natives-&gt;GetSymbol(native_function);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;  <span class="comment">// namespace</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> DartUI::InitForGlobal() &#123;</div><div class="line">  <span class="keyword">if</span> (!g_natives) &#123;</div><div class="line">    <span class="comment">// 构造DartLibraryNatives类，持有方法列表，分为dart方法id映射表，和Native方法映射表</span></div><div class="line">    g_natives = <span class="keyword">new</span> tonic::DartLibraryNatives();</div><div class="line">    Canvas::RegisterNatives(g_natives);</div><div class="line">    CanvasGradient::RegisterNatives(g_natives);</div><div class="line">    CanvasImage::RegisterNatives(g_natives);</div><div class="line">    CanvasPath::RegisterNatives(g_natives);</div><div class="line">    CanvasPathMeasure::RegisterNatives(g_natives);</div><div class="line">    Codec::RegisterNatives(g_natives);</div><div class="line">    ColorFilter::RegisterNatives(g_natives);</div><div class="line">    DartRuntimeHooks::RegisterNatives(g_natives);</div><div class="line">    EngineLayer::RegisterNatives(g_natives);</div><div class="line">    FontCollection::RegisterNatives(g_natives);</div><div class="line">    FrameInfo::RegisterNatives(g_natives);</div><div class="line">    ImageFilter::RegisterNatives(g_natives);</div><div class="line">    ImageShader::RegisterNatives(g_natives);</div><div class="line">    IsolateNameServerNatives::RegisterNatives(g_natives);</div><div class="line">    Paragraph::RegisterNatives(g_natives);</div><div class="line">    ParagraphBuilder::RegisterNatives(g_natives);</div><div class="line">    Picture::RegisterNatives(g_natives);</div><div class="line">    PictureRecorder::RegisterNatives(g_natives);</div><div class="line">    Scene::RegisterNatives(g_natives);</div><div class="line">    SceneBuilder::RegisterNatives(g_natives);</div><div class="line">    SemanticsUpdate::RegisterNatives(g_natives);</div><div class="line">    SemanticsUpdateBuilder::RegisterNatives(g_natives);</div><div class="line">    Vertices::RegisterNatives(g_natives);</div><div class="line">    Window::RegisterNatives(g_natives);</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(LEGACY_FUCHSIA_EMBEDDER)</span></div><div class="line">    SceneHost::RegisterNatives(g_natives);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// DartVM 初始化过程中会调用</span></div><div class="line"><span class="keyword">void</span> DartUI::InitForIsolate() &#123;</div><div class="line">  FML_DCHECK(g_natives);</div><div class="line">  Dart_Handle result = Dart_SetNativeResolver(</div><div class="line">      Dart_LookupLibrary(ToDart(<span class="string">"dart:ui"</span>)), GetNativeFunction, GetSymbol);</div><div class="line">  <span class="keyword">if</span> (Dart_IsError(result)) &#123;</div><div class="line">    Dart_PropagateError(result);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DartVM 初始化过程中会调用 <code>DartUI::InitForIsolate()</code> 进行方法注册。</p>
<p>上面的类都是 <code>dart:ui</code> 包下的类，通过 <code>dart:ffi</code> 将 Dart 方法和 Native 方法进行绑定。</p>
<p><code>dart:ffi</code> 的详细介绍见 <a href="https://flutter.dev/docs/development/platform-integration/c-interop" target="_blank" rel="external">Binding to native code using dart:ffi</a></p>
<h2 id="4、注册-VSync"><a href="#4、注册-VSync" class="headerlink" title="4、注册 VSync"></a>4、注册 VSync</h2><p>继续调用 <code>Window::ScheduleFrame()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/ui/window.cc</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ScheduleFrame</span><span class="params">(Dart_NativeArguments args)</span> </span>&#123;</div><div class="line">  UIDartState::ThrowIfUIOperationsProhibited();</div><div class="line">  UIDartState::Current()-&gt;window()-&gt;client()-&gt;ScheduleFrame();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// runtime/runtime_controller.cc</span></div><div class="line"><span class="comment">// |WindowClient|</span></div><div class="line"><span class="keyword">void</span> RuntimeController::ScheduleFrame() &#123;</div><div class="line">  client_.ScheduleFrame();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// shell/common/engine.cc</span></div><div class="line"><span class="keyword">void</span> Engine::ScheduleFrame(<span class="keyword">bool</span> regenerate_layer_tree) &#123;</div><div class="line">  animator_-&gt;RequestFrame(regenerate_layer_tree);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// shell/common/animator.cc</span></div><div class="line"><span class="keyword">void</span> Animator::RequestFrame(<span class="keyword">bool</span> regenerate_layer_tree) &#123;</div><div class="line">  <span class="keyword">if</span> (regenerate_layer_tree) &#123;</div><div class="line">    <span class="comment">// 默认值 true，决定是否重新生成layer tree</span></div><div class="line">    regenerate_layer_tree_ = <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 当调用 Animator::Stop() 停止请求</span></div><div class="line">  <span class="keyword">if</span> (paused_ &amp;&amp; !dimension_change_pending_) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!pending_frame_semaphore_.TryWait()) &#123;</div><div class="line">    <span class="comment">// 多次调用，只生效一次</span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 在 UIThread 执行 VSync 注册回调</span></div><div class="line">  task_runners_.GetUITaskRunner()-&gt;PostTask([self = weak_factory_.GetWeakPtr(),</div><div class="line">                                             frame_number = frame_number_]() &#123;</div><div class="line">    <span class="keyword">if</span> (!self.get()) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    TRACE_EVENT_ASYNC_BEGIN0(<span class="string">"flutter"</span>, <span class="string">"Frame Request Pending"</span>, frame_number);</div><div class="line">    <span class="comment">//注册 VSync</span></div><div class="line">    self-&gt;AwaitVSync();</div><div class="line">  &#125;);</div><div class="line">  <span class="comment">// 标记已经请求渲染</span></div><div class="line">  frame_scheduled_ = <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>这里方法的参数 <code>regenerate_layer_tree</code> 默认值是 true，当为 false 时不需要重绘</li>
<li>通过 <code>pending_frame_semaphore_</code> 信号量控制 <code>Animator::ScheduleFrame</code> 只需注册一次 VSync 信号，初始值为1，为0 时，这里 <code>pending_frame_semaphore_</code> -1，<code>Animator::beginFrame()</code> 被调用后 <code>pending_frame_semaphore_</code> + 1</li>
<li>在 UIThread 执行 VSync 注册回调</li>
</ul>
<h3 id="4-1、Animator-AwaitVSync"><a href="#4-1、Animator-AwaitVSync" class="headerlink" title="4.1、Animator::AwaitVSync()"></a>4.1、Animator::AwaitVSync()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// shell/common/animator.cc</span></div><div class="line"><span class="keyword">void</span> Animator::AwaitVSync() &#123;</div><div class="line">  waiter_-&gt;AsyncWaitForVsync(</div><div class="line">      [self = weak_factory_.GetWeakPtr()](fml::TimePoint frame_start_time,</div><div class="line">                                          fml::TimePoint frame_target_time) &#123;</div><div class="line">        <span class="comment">// VSync 信号的回调方法</span></div><div class="line">        <span class="comment">// frame_start_time 为接受到 VSync 信号时间点</span></div><div class="line">        <span class="comment">// frame_target_time 为这一帧渲染目标时间，超过这个时间即为掉帧</span></div><div class="line">        <span class="keyword">if</span> (self) &#123;</div><div class="line">          <span class="keyword">if</span> (self-&gt;CanReuseLastLayerTree()) &#123;</div><div class="line">            <span class="comment">// regenerate_layer_tree 为false，复用上一次生成的LayerTree，直接光栅化合成</span></div><div class="line">            self-&gt;DrawLastLayerTree();</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 触发渲染管线工作</span></div><div class="line">            self-&gt;BeginFrame(frame_start_time, frame_target_time);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">  delegate_.OnAnimatorNotifyIdle(dart_frame_deadline_);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>注册VSync 信号的回调</li>
<li><code>frame_start_time</code> 为接受到 VSync 信号时间点， <code>frame_target_time</code> 为这一帧渲染目标时间，超过这个时间点即为掉帧，下一帧就不会注册 VSync 信号回调</li>
<li>regenerate_layer_tree 为false，复用上一次生成的LayerTree，直接光栅化合成；为 false 继续触发渲染管线启动</li>
<li><code>waiter_</code> 为 <code>VsyncWaiter</code> 对象，在引擎启动过程中，初始化 <code>Shell</code> 时被创建，根据不同 Platform，构建出不同的对象，这里以 Android 为例，它是 <code>VsyncWaiterAndroid</code> 类的对象</li>
</ul>
<h3 id="4-2、VsyncWaiter-AsyncWaitForVsync"><a href="#4-2、VsyncWaiter-AsyncWaitForVsync" class="headerlink" title="4.2、VsyncWaiter::AsyncWaitForVsync"></a>4.2、VsyncWaiter::AsyncWaitForVsync</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// shell/common/async_waiter.cc</span></div><div class="line"><span class="keyword">void</span> VsyncWaiter::AsyncWaitForVsync(<span class="keyword">const</span> Callback&amp; callback) &#123;</div><div class="line">	...</div><div class="line">  TRACE_EVENT0(<span class="string">"flutter"</span>, <span class="string">"AsyncWaitForVsync"</span>);</div><div class="line"></div><div class="line">  &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="function">scoped_lock <span class="title">lock</span><span class="params">(callback_mutex_)</span></span>;</div><div class="line">    ...</div><div class="line">    callback_ = <span class="built_in">std</span>::move(callback);</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  AwaitVSync();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// shell/platform/android/vsync_waiter_android.cc</span></div><div class="line"><span class="keyword">void</span> VsyncWaiterAndroid::AwaitVSync() &#123;</div><div class="line">  <span class="keyword">auto</span>* weak_this = <span class="keyword">new</span> <span class="built_in">std</span>::weak_ptr&lt;VsyncWaiter&gt;(shared_from_this());</div><div class="line">  jlong java_baton = <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(weak_this);</div><div class="line"></div><div class="line">  task_runners_.GetPlatformTaskRunner()-&gt;PostTask([java_baton]() &#123;</div><div class="line">    JNIEnv* env = fml::jni::AttachCurrentThread();</div><div class="line">    env-&gt;CallStaticVoidMethod(g_vsync_waiter_class-&gt;obj(),     </div><div class="line">                              g_async_wait_for_vsync_method_,  </div><div class="line">                              java_baton                       </div><div class="line">    );</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 注册 JNI 方法</span></div><div class="line"><span class="keyword">bool</span> VsyncWaiterAndroid::Register(JNIEnv* env) &#123;</div><div class="line">  <span class="comment">// VSync 回调，Java 调用</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod methods[] = &#123;&#123;</div><div class="line">      .name = <span class="string">"nativeOnVsync"</span>,</div><div class="line">      .signature = <span class="string">"(JJJ)V"</span>,</div><div class="line">      .fnPtr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;OnNativeVsync),</div><div class="line">  &#125;&#125;;</div><div class="line"></div><div class="line">  jclass clazz = env-&gt;FindClass(<span class="string">"io/flutter/embedding/engine/FlutterJNI"</span>);</div><div class="line"></div><div class="line">  g_vsync_waiter_class = <span class="keyword">new</span> fml::jni::ScopedJavaGlobalRef&lt;jclass&gt;(env, clazz);</div><div class="line">  </div><div class="line">  g_async_wait_for_vsync_method_ = env-&gt;GetStaticMethodID(</div><div class="line">      g_vsync_waiter_class-&gt;obj(), <span class="string">"asyncWaitForVsync"</span>, <span class="string">"(J)V"</span>);</div><div class="line">  <span class="keyword">return</span> env-&gt;RegisterNatives(clazz, methods, fml::size(methods)) == <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在引擎启动过程中，已经通过 Java JNI 绑定了 C++ 和 Java 代码的映射，这里通过 JNI 调用 Android Java 代码</p>
<ul>
<li>JNIEnv 代表了 Java 在本线程的执行环境（在这里就是 Android 主线程），它的结构是一个函数表</li>
<li>注册 VSync 信号回调 <code>nativeOnVsync</code>  Native 方法 <code>OnNativeVsync</code></li>
<li>运行在 PlatformThread，即 Android 主线程</li>
<li><code>g_vsync_waiter_class</code> 与 <code>io/flutter/embedding/engine/FlutterJNI</code> Java 类绑定</li>
<li><code>g_async_wait_for_vsync_method_</code> 是 <code>io/flutter/embedding/engine/FlutterJNI.asyncWaitForVsync()</code> Java 方法的指针</li>
</ul>
<p>最终在 Android 主线程调用 <code>io/flutter/embedding/engine/FlutterJNI.asyncWaitForVsync()</code> 方法。</p>
<h3 id="4-3、Choreographer"><a href="#4-3、Choreographer" class="headerlink" title="4.3、Choreographer"></a>4.3、Choreographer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// io.flutter.embedding.engine.FlutterJNI</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">asyncWaitForVsync</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> cookie)</span> </span>&#123;</div><div class="line">    asyncWaitForVsyncDelegate.asyncWaitForVsync(cookie);</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">//io.flutter.view.VsyncWaiter</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VsyncWaiter</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> VsyncWaiter instance;</div><div class="line"></div><div class="line">  <span class="meta">@NonNull</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> VsyncWaiter <span class="title">getInstance</span><span class="params">(@NonNull WindowManager windowManager)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">      instance = <span class="keyword">new</span> VsyncWaiter(windowManager);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@NonNull</span> <span class="keyword">private</span> <span class="keyword">final</span> WindowManager windowManager;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FlutterJNI.AsyncWaitForVsyncDelegate asyncWaitForVsyncDelegate =</div><div class="line">      <span class="keyword">new</span> FlutterJNI.AsyncWaitForVsyncDelegate() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncWaitForVsync</span><span class="params">(<span class="keyword">long</span> cookie)</span> </span>&#123;</div><div class="line">          Choreographer.getInstance()</div><div class="line">            <span class="comment">// 注册 VSync 回调，只会回调一次</span></div><div class="line">              .postFrameCallback(</div><div class="line">                  <span class="keyword">new</span> Choreographer.FrameCallback() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">                      <span class="comment">// 获取屏幕刷新频率，例如60、90、120</span></div><div class="line">                      <span class="keyword">float</span> fps = windowManager.getDefaultDisplay().getRefreshRate();</div><div class="line">                      <span class="comment">// 根据刷新频率计算出每一帧绘制时间</span></div><div class="line">                      <span class="keyword">long</span> refreshPeriodNanos = (<span class="keyword">long</span>) (<span class="number">1000000000.0</span> / fps);</div><div class="line">                      <span class="comment">// 回调 Native 方法，frameTimeNanos 即为 frame_start_time</span></div><div class="line">                      FlutterJNI.nativeOnVsync(</div><div class="line">                          frameTimeNanos, frameTimeNanos + refreshPeriodNanos, cookie);</div><div class="line">                    &#125;</div><div class="line">                  &#125;);</div><div class="line">        &#125;</div><div class="line">      &#125;;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">VsyncWaiter</span><span class="params">(@NonNull WindowManager windowManager)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.windowManager = windowManager;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//设置 FlutterJNI delegate</span></div><div class="line">    FlutterJNI.setAsyncWaitForVsyncDelegate(asyncWaitForVsyncDelegate);</div><div class="line"></div><div class="line">    <span class="comment">// 获取屏幕刷新频率，例如60、90、120</span></div><div class="line">    <span class="keyword">float</span> fps = windowManager.getDefaultDisplay().getRefreshRate();</div><div class="line">    FlutterJNI.setRefreshRateFPS(fps);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在 App 启动过程中，<code>FlutterLoader.startInitialization()</code> 方法中初始化 <code>VsyncWaiter</code> 单例，设置 FlutterJNI delegate</li>
<li>通过 <code>Choreographer..postFrameCallback()</code> 注册 VSync 信号回调，只会回调一次，每用一次注册一次</li>
<li>根据屏幕刷新频率，计算 <code>frame_start_time</code> 和 <code>frame_target_time</code></li>
<li>收到 VSync 信号回调后，通过 JNI 回调 Native 方法</li>
</ul>
<p>Choreographer 通过 <code>SurfaceFlinger</code> 注册 VSync 信号回调 <code>FrameDisplayEventReceiver</code>，一旦 VSync 信号到来，<code>SurfaceFlinger</code> 通知 FrameDisplayEventReceiver 回调 <code>doFrame()</code> 方法.</p>
<p>注意只会回调一次，每用一次注册一次。所以当屏幕静止未刷新时，FPS 会一为未 0。</p>
<h3 id="4-4、OnNativeVsync"><a href="#4-4、OnNativeVsync" class="headerlink" title="4.4、OnNativeVsync"></a>4.4、OnNativeVsync</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// shell/platform/android/vsync_waiter_android.cc</span></div><div class="line"><span class="keyword">void</span> VsyncWaiterAndroid::OnNativeVsync(JNIEnv* env,</div><div class="line">                                       jclass jcaller,</div><div class="line">                                       jlong frameTimeNanos,</div><div class="line">                                       jlong frameTargetTimeNanos,</div><div class="line">                                       jlong java_baton) &#123;</div><div class="line">  <span class="keyword">auto</span> frame_time = fml::TimePoint::FromEpochDelta(</div><div class="line">      fml::TimeDelta::FromNanoseconds(frameTimeNanos));</div><div class="line">  <span class="keyword">auto</span> target_time = fml::TimePoint::FromEpochDelta(</div><div class="line">      fml::TimeDelta::FromNanoseconds(frameTargetTimeNanos));</div><div class="line"></div><div class="line">  ConsumePendingCallback(java_baton, frame_time, target_time);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// shell/common/async_waiter.cc</span></div><div class="line"><span class="keyword">void</span> VsyncWaiter::FireCallback(fml::TimePoint frame_start_time,</div><div class="line">                               fml::TimePoint frame_target_time) &#123;</div><div class="line">  Callback callback;</div><div class="line">  fml::closure secondary_callback;</div><div class="line"></div><div class="line">  &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="function">scoped_lock <span class="title">lock</span><span class="params">(callback_mutex_)</span></span>;</div><div class="line">    callback = <span class="built_in">std</span>::move(callback_);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (callback) &#123;</div><div class="line">    <span class="keyword">auto</span> flow_identifier = fml::tracing::TraceNonce();</div><div class="line">    TRACE_FLOW_BEGIN(<span class="string">"flutter"</span>, kVsyncFlowName, flow_identifier);</div><div class="line">		<span class="comment">// 运行在 UIThread </span></div><div class="line">    task_runners_.GetUITaskRunner()-&gt;PostTaskForTime(</div><div class="line">        [callback, flow_identifier, frame_start_time, frame_target_time]() &#123;</div><div class="line">          <span class="comment">// 执行回调方法</span></div><div class="line">          callback(frame_start_time, frame_target_time);</div><div class="line">          TRACE_FLOW_END(<span class="string">"flutter"</span>, kVsyncFlowName, flow_identifier);</div><div class="line">        &#125;,</div><div class="line">        frame_start_time);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行注册的回调方法，运行在 UIThread，回到 #4.1</p>
<h2 id="5、BeginFrame"><a href="#5、BeginFrame" class="headerlink" title="5、BeginFrame"></a>5、BeginFrame</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Animator::BeginFrame(fml::TimePoint frame_start_time,</div><div class="line">                          fml::TimePoint frame_target_time) &#123;</div><div class="line">  frame_scheduled_ = <span class="literal">false</span>;</div><div class="line">  notify_idle_task_id_++;</div><div class="line">  regenerate_layer_tree_ = <span class="literal">false</span>;</div><div class="line">  <span class="comment">//信号量 pending_frame_semaphore_ +1，可以继续接收 RequestFrame 请求</span></div><div class="line">  pending_frame_semaphore_.Signal();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!producer_continuation_) &#123;</div><div class="line">    <span class="comment">// producer_continuation_ 持有生产对象，并通过信号量控制管线任务</span></div><div class="line">    producer_continuation_ = layer_tree_pipeline_-&gt;Produce();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!producer_continuation_) &#123;</div><div class="line">      <span class="comment">// layer_tree_pipeline_ 管线任务已满（2个），忽略本次绘制</span></div><div class="line">      RequestFrame();</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  last_frame_begin_time_ = frame_start_time;</div><div class="line">  last_frame_target_time_ = frame_target_time;</div><div class="line">  dart_frame_deadline_ = FxlToDartOrEarlier(frame_target_time);</div><div class="line">  &#123;</div><div class="line">    delegate_.OnAnimatorBeginFrame(frame_target_time);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!frame_scheduled_) &#123;</div><div class="line">    <span class="comment">// Animator::RequestFrame() 方法最后置为 true，标记已经请求渲染</span></div><div class="line">    task_runners_.GetUITaskRunner()-&gt;PostDelayedTask(</div><div class="line">        [self = weak_factory_.GetWeakPtr(),</div><div class="line">         notify_idle_task_id = notify_idle_task_id_]() &#123;</div><div class="line">          <span class="keyword">if</span> (!self.get()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// 51ms 时间之内没有新的提交新的任务，通知Engine空闲可以进行 GC</span></div><div class="line">          <span class="keyword">if</span> (notify_idle_task_id == self-&gt;notify_idle_task_id_ &amp;&amp;</div><div class="line">              !self-&gt;frame_scheduled_) &#123;</div><div class="line">            self-&gt;delegate_.OnAnimatorNotifyIdle(Dart_TimelineGetMicros() +</div><div class="line">                                                 <span class="number">100000</span>);</div><div class="line">          &#125;</div><div class="line">        &#125;,</div><div class="line">      	<span class="comment">// 51ms，通知 Engine 空闲</span></div><div class="line">        kNotifyIdleTaskWaitTime);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>信号量 pending_frame<em>semaphore</em> +1，可以继续接收 RequestFrame 请求</li>
<li>regenerate_layer<em>tree</em> 赋值 false，在一些情况下调用 RequestFrame 可以复用这次生成的 <code>flutter::LayerTree</code></li>
<li><code>producer_continuation_</code> 是 <code>ProducerContinuation</code> 类的对象，持有生产对象，并通过信号量控制管线任务</li>
<li><code>layer_tree_pipeline_</code> 是 <code>LayerTreePipeline</code> 类的对象，在 Animator 初始化过程中被创建，<code>LayerTreePipeline</code> 是一个线程安全的生产者消费者队列， UIThread 负责生产 <code>flutter::LayerTree</code> 和 RasterThread 负责消费 <code>flutter::LayerTree</code>，<code>flutter::LayerTree</code> 持有 Dart Framework 生成的Layer Tree映射到 Engine 的 <code>flow::Layer</code> 的根节点</li>
<li>执行 <code>delegate_.OnAnimatorBeginFrame(frame_target_time)</code> ， delagate_ 的实现在 <code>Shell</code> 类</li>
</ul>
<h3 id="5-1、LayerTreePipeline"><a href="#5-1、LayerTreePipeline" class="headerlink" title="5.1、LayerTreePipeline"></a>5.1、LayerTreePipeline</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">	// shell/common/animator.h</div><div class="line">  using LayerTreePipeline = Pipeline&lt;flutter::LayerTree&gt;;</div><div class="line">...</div><div class="line">// shell/common/animator.cc</div><div class="line">Animator::Animator(Delegate&amp; delegate,</div><div class="line">                   TaskRunners task_runners,</div><div class="line">                   std::unique_ptr&lt;VsyncWaiter&gt; waiter)</div><div class="line">    : delegate_(delegate),</div><div class="line">      task_runners_(std::move(task_runners)),</div><div class="line">      waiter_(std::move(waiter)),</div><div class="line">      last_frame_begin_time_(),</div><div class="line">      last_frame_target_time_(),</div><div class="line">      dart_frame_deadline_(0),</div><div class="line">#if FLUTTER_SHELL_ENABLE_METAL</div><div class="line">			// 支持 Metal 深度为2</div><div class="line">      layer_tree_pipeline_(fml::MakeRefCounted&lt;LayerTreePipeline&gt;(2)),</div><div class="line">#else   </div><div class="line">			// 这里在一些情况下有bug，后续版本会写死深度为2 </div><div class="line">      layer_tree_pipeline_(fml::MakeRefCounted&lt;LayerTreePipeline&gt;(</div><div class="line">          task_runners.GetPlatformTaskRunner() ==</div><div class="line">                  task_runners.GetRasterTaskRunner()</div><div class="line">              ? 1</div><div class="line">              : 2)),</div><div class="line">#endif  // FLUTTER_SHELL_ENABLE_METAL </div><div class="line">			// pending_frame_semaphore_ 初始化为1，可以接受一个 RequestFrame 请求</div><div class="line">      pending_frame_semaphore_(1),</div><div class="line">...</div><div class="line">	// shell/common/pipeline.h</div><div class="line">  explicit Pipeline(uint32_t depth)</div><div class="line">      : depth_(depth), empty_(depth), available_(0), inflight_(0) &#123;&#125;</div><div class="line">  fml::Semaphore empty_; // 默认为2</div><div class="line">  fml::Semaphore available_ // 默认为0</div></pre></td></tr></table></figure>
<p>构建深度为 2 的 <code>Pipeline</code> 对象，可以持有 <code>flutter::LayerTree</code> 对象。</p>
<p>Pipeline 持有两个信号量 <code>empty_</code> 和 <code>available_</code>，用来控制管线任务调度。</p>
<p>当调用 <code>layer_tree_pipeline_-&gt;Produce()</code> 方法时</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// shell/common/pipeline.h</span></div><div class="line"><span class="function">ProducerContinuation <span class="title">Produce</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!empty_.TryWait()) &#123;</div><div class="line">     <span class="comment">// 信号量 empty_ 为0时，返回空</span></div><div class="line">     <span class="keyword">return</span> &#123;&#125;;</div><div class="line">   &#125;</div><div class="line">   ++inflight_;</div><div class="line">   </div><div class="line">   <span class="keyword">return</span> ProducerContinuation&#123;</div><div class="line">     <span class="comment">// 持有 Pipeline::ProducerCommit 方法引用</span></div><div class="line">       <span class="built_in">std</span>::bind(&amp;Pipeline::ProducerCommit, <span class="keyword">this</span>, <span class="built_in">std</span>::placeholders::_1,</div><div class="line">                 <span class="built_in">std</span>::placeholders::_2),  <span class="comment">// continuation</span></div><div class="line">       GetNextPipelineTraceID()&#125;;         <span class="comment">// trace id</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>生成一个 <code>ProducerContinuation</code> 类的对象 <code>producer_continuation_</code>，<code>continuation_</code> 对象持有 <code>Pipeline::ProducerCommit()</code> 方法引用。</p>
<p>当 UIThread 在 Dart Framework 生成 Layer Tree，并通过 <code>SceneBuilder</code> 构建出 <code>Scene</code> 对象，持有 <code>flutter:LayerTree</code>，调用 <code>window.render()</code> 方法开启光栅化合成之前，会调用<code>Pipeline::ProducerCommit()</code> 方法，并将 <code>flutter:LayerTree</code> 绑定到 <code>producer_continuation_</code>对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// shell/common/pipeline.h</span></div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">ProducerCommit</span><span class="params">(ResourcePtr resource, <span class="keyword">size_t</span> trace_id)</span> </span>&#123;</div><div class="line">    &#123;</div><div class="line">      <span class="built_in">std</span>::<span class="function">scoped_lock <span class="title">lock</span><span class="params">(queue_mutex_)</span></span>;</div><div class="line">      <span class="comment">//resource 是 flutter:LayerTree 对象，添加到队列</span></div><div class="line">      queue_.emplace_back(<span class="built_in">std</span>::move(resource), trace_id);</div><div class="line">    &#125;</div><div class="line">		<span class="comment">// available_ + 1，触发 RasterThread 光栅化</span></div><div class="line">    available_.Signal();</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>整个 Pipeline 管线的流程为：</p>
<ul>
<li><p><code>Animator::RequestFrame()</code>方法触发绘制开始<code>_empty</code> -1，开始生成 <code>flutter::LayerTree</code>，运行在 UIThread</p>
</li>
<li><p>当 UIThread 准备好 Engine <code>flutter::LayerTree</code>， <code>available_</code> +1</p>
</li>
<li><p>当 <code>available_</code> &gt; 0 时，触发 Raster Thread 工作，拿到 <code>flutter:LayerTree</code> 进行光栅化合成</p>
</li>
<li><p>当 RasterThread 处理完成， <code>_empty</code> + 1，下次 <code>Animator::RequestFrame()</code> 可以正常开始处理生成 <code>flutter::LayerTree</code> 工作</p>
</li>
<li><p>当 <code>_empty</code> 为 0 时，管线任务已满，忽略本次 <code>Animator::RequestFrame()</code> 请求，直到下一次 VSync 信号到来</p>
</li>
</ul>
<p>通过两个信号量来管理管线的调度，这种调度机制可以确保 RasterThread 不至于过载（2个任务），同时也可以避免 UIThread 不必要的资源消耗。</p>
<p>所以不论在 UIThread 还是在 RasterThread 耗时太久，都可能会导致 Flutter 应用卡顿，因为会导致延迟接受 VSync 信号，导致掉帧。</p>
<h3 id="5-2、OnAnimatorBeginFrame"><a href="#5-2、OnAnimatorBeginFrame" class="headerlink" title="5.2、OnAnimatorBeginFrame"></a>5.2、OnAnimatorBeginFrame</h3><p>继续调用 <code>delegate_.OnAnimatorBeginFrame(frame_target_time)</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// shell/common/shell.cc</span></div><div class="line"><span class="comment">// |Animator::Delegate|</span></div><div class="line"><span class="keyword">void</span> Shell::OnAnimatorBeginFrame(fml::TimePoint frame_target_time) &#123;</div><div class="line">  FML_DCHECK(is_setup_);</div><div class="line">  FML_DCHECK(task_runners_.GetUITaskRunner()-&gt;RunsTasksOnCurrentThread());</div><div class="line"></div><div class="line">  <span class="comment">// record the target time for use by rasterizer.</span></div><div class="line">  &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="function">scoped_lock <span class="title">time_recorder_lock</span><span class="params">(time_recorder_mutex_)</span></span>;</div><div class="line">    <span class="comment">// 记录frame_target_time</span></div><div class="line">    latest_frame_target_time_.emplace(frame_target_time);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (engine_) &#123;</div><div class="line">    engine_-&gt;BeginFrame(frame_target_time);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// shell/common/engine.cc</span></div><div class="line"><span class="keyword">void</span> Engine::BeginFrame(fml::TimePoint frame_time) &#123;</div><div class="line">  TRACE_EVENT0(<span class="string">"flutter"</span>, <span class="string">"Engine::BeginFrame"</span>);</div><div class="line">  runtime_controller_-&gt;BeginFrame(frame_time);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// runtime/runtime_controller.cc</span></div><div class="line"><span class="keyword">bool</span> RuntimeController::BeginFrame(fml::TimePoint frame_time) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span>* window = GetWindowIfAvailable()) &#123;</div><div class="line">    window-&gt;BeginFrame(frame_time);</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// lib/ui/window/window.cc</span></div><div class="line"><span class="keyword">void</span> Window::DidCreateIsolate() &#123;</div><div class="line">  library_.Set(tonic::DartState::Current(),</div><div class="line">               Dart_LookupLibrary(tonic::ToDart(<span class="string">"dart:ui"</span>)));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Window::BeginFrame(fml::TimePoint frameTime) &#123;</div><div class="line">  tonic::DartState::<span class="function">Scope <span class="title">scope</span><span class="params">(dart_state)</span></span>;</div><div class="line"></div><div class="line">  <span class="keyword">int64_t</span> microseconds = (frameTime - fml::TimePoint()).ToMicroseconds();</div><div class="line">	<span class="comment">// 通过 fii 回调 Dart Framework window._beginFrame()</span></div><div class="line">  tonic::LogIfError(tonic::DartInvokeField(library_.value(), <span class="string">"_beginFrame"</span>,</div><div class="line">                                           &#123;</div><div class="line">                                               Dart_NewInteger(microseconds),</div><div class="line">                                           &#125;));</div><div class="line">	<span class="comment">// 执行 microtasks</span></div><div class="line">  UIDartState::Current()-&gt;FlushMicrotasksNow();</div><div class="line">  <span class="comment">// 通过 ffi 回调 Dart Framework window._drawFrame()</span></div><div class="line">  tonic::LogIfError(tonic::DartInvokeField(library_.value(), <span class="string">"_drawFrame"</span>, &#123;&#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 Shell::OnAnimatorBeginFrame -&gt; Engine::BeginFrame -&gt; RuntimeController::BeginFrame -&gt; Window::BeginFrame 层层调用，通过 ffi 回调 Dart Framework 继续绘制流程。</p>
<p>做三件事情：</p>
<ul>
<li>执行 Dart Framework <code>dart:ui</code> 包下的 <code>_beginFrame()</code></li>
<li>执行 microtasks 任务</li>
<li>执行 Dart Framework <code>dart:ui</code> 包下的  <code>_drawFrame()</code></li>
</ul>
<p>这个流程和文章开头提到的 <code>SchedulerBinding</code> 的状态机 <code>SchedulerPhase</code> 中声明的状态一一对应，接下来回调到 Dart Framework 后，由 <code>SchedulerBinding</code> 进行绘制调度。</p>
<p>到这里，VSync 注册流程结束，接下来回到 Dart Framework 中继续进行。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.flutterchina.club/chapter14/flutter_app_startup.html" target="_blank" rel="external">14.4 Flutter运行机制-从启动到显示</a></p>
<p><a href="http://gityuan.com/2019/06/15/flutter_ui_draw/" target="_blank" rel="external">Flutter渲染机制—UI线程</a></p>
<p>本文链接： <a href="http://w4lle.com/2020/11/11/flutter-ui-vsync/">http://w4lle.com/2020/11/11/flutter-ui-vsync/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Flutter App 启动过程或者 State 刷新过程中，会请求注册 VSync 信号。&lt;/p&gt;
&lt;p&gt;本篇文章主要分析下 VSync 信号注册以及回调过程。&lt;/p&gt;
&lt;p&gt;基于 Android 平台，Flutter v1.20.4。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://w4lle.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter UI 渲染浅析（一）总览</title>
    <link href="http://w4lle.com/2020/11/09/flutter-ui-overview/"/>
    <id>http://w4lle.com/2020/11/09/flutter-ui-overview/</id>
    <published>2020-11-09T11:43:02.000Z</published>
    <updated>2020-11-11T10:33:21.559Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter UI 渲染系列文章，基于 Flutter v1.20.4</p>
<a id="more"></a>
<p>我们知道屏幕显示的基本单位是像素，每个像素点显示不同的颜色值，按一定规则排列就形成了图像。</p>
<p>显示器按一定频率从 GPU 获取数据，就可以完成图像的更新。现在手机屏幕一般有60HZ、90HZ、120HZ，以60HZ为例，屏幕每秒会发出 60 个 VSync 垂直同步信号。</p>
<p>VSync 信号用于协调显示器、CPU 和 GPU 的工作。</p>
<p>GPU 每秒可以绘制的帧数叫做帧速率，如果帧速率大于屏幕刷新率，屏幕上显示的内容就有可能是两个图像的不完全内容，造成图像撕裂。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imageswithout_sync.png" alt=""></p>
<p>VSync 垂直信号可以保证刷新频率的统一。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imageswith_sync.png" alt=""></p>
<p>在 VSync 信号的调度下，UI 系统把逻辑代码变成图像显示到屏幕上，一般需要经过以下几个阶段：</p>
<ol>
<li>View，构建 View/DOM 节点</li>
<li>Layout，计算样式(Style)、布局(Layout)</li>
<li>ViewTree，将 View 节点按一定规则归属到不同的图层，构建或更新 ViewTree</li>
<li>Paint，绘制，输出绘制指令到 DisplayList</li>
<li>Rasterization，光栅化，执行 DisplayList 中的绘图指令，生成图层区域的像素数据</li>
<li>Composite，合成，把各图层光栅化后的数据进行叠加和特性处理，输出到屏幕上</li>
</ol>
<p>简单来说就是做了两件事情：</p>
<ol>
<li>构建 UI 描述规则，用于构建或刷新图像，并把绘制指令保存起来用于绘制，即 1-4</li>
<li>光栅化和合成，对硬件绘制 API 做了统一封装，屏蔽底层绘制细节，即 5-6</li>
</ol>
<p>Android 和 iOS 基本都是按照这个流程来构建UI的。</p>
<p>以 Android 为例，Android 通过 XML 来描述 UI 结构，用 DisplayList 保存绘制指令信息，通过 Skia 封装底层细节实现光栅化合成。</p>
<p>Flutter 作为一款跨端 UI 开发框架，它的渲染流程也是类似的。</p>
<p>这个系列的文章主要分析下 Flutter UI 渲染流程，涉及到的中间过程会分部解析，基于 Flutter v1.20.4 版本源码，主要分为以下几个部分：</p>
<ol>
<li>总览</li>
<li>VSync 注册</li>
<li>Animate 及动画实现原理</li>
<li>Build</li>
<li>Layout</li>
<li>Paint &amp; RepaintBoundary</li>
<li>CompositeFrame</li>
<li>RasterThread 光栅化及合成</li>
</ol>
<h2 id="1、Flutter-架构"><a href="#1、Flutter-架构" class="headerlink" title="1、Flutter 架构"></a>1、Flutter 架构</h2><p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter_archdiagram.png" alt=""></p>
<p>Flutter 架构分为三层：Dart Framework、C++ Engine、 Platform Embedder。</p>
<p>Dart Framework 提供了响应式的开发框架，使用 Dart 开发，它对渲染逻辑做了统一封装，屏蔽了底层实现，对底层 C++ Engine 提供双向通信能力，开发者只需要组合 Widgets 用于构建 App 视图即可。</p>
<ul>
<li>最底层的 Foundation 层提供一些最基础的抽象类或定义，基于此， Animation 动画、Painting 绘制、Gestures 手势等构建出通用抽象能力</li>
<li>Rendering 层，构建出渲染树 Render Tree，也即 RenderObject Tree，用于具体绘制，RenderObject 会自动随着数据改变而动态改变</li>
<li>Widgets 层，提供了一套非常丰富的 Widget 组件库，用于构建 Widgets Tree 和 Element Tree，这是响应式编程的基础实现，每一个 RenderObject 都有一个对应的 Widget 及 Element</li>
<li>Materail 层和 Cupertino 层使用 Widgets 组件库，构建 Android Materail 或者 iOS Cupertino 风格的应用视图，开发者基于这些 Widgets 即可构建出效果一致的跨端应用</li>
</ul>
<p>C++ Engine 是 Flutter 的核心部分，大部分使用 C++ 开发，它的主要职责是光栅化合成上屏用于显示绘制内容，同时它也提供低层次的核心能力，比如Skia图形化绘制（graphics）、TextLayout、文件系统、网络 I/O、无障碍支持、插件体系、Dart运行时（DartVM）和 GC、编译链。</p>
<p>Engine 层对 App 层暴露 <code>dart:ui</code> 包，<code>dart:ui</code> 包是 Flutter App 的构建基础，其中的 dart 类对 C++ Engine 层中的实现类做了包装，它提供了基础能力，诸如交互系统、图形图像处理、渲染子系统等。</p>
<p>其中最重要的一个类是包下的 <code>Window</code>，它向上提供了最核心的一些服务，比如任务Scheduler API、绘制 API、输入事件响应等等。</p>
<p>Platform Embedder 是平台嵌入层，把 Flutte 代码打包嵌入到具体的实现平台，提供运行入口，并对上层提供最基础的能力，比如提供渲染画布、插件系统、无障碍、交互管理、消息循环管理等。</p>
<p>Flutter 分层架构使得平台相关性大大降低。</p>
<p>Dart Framework 对上提供统一的基于 dart 的响应式 UI 描述框架。</p>
<p>C++ Engine 向下对 Skia 绘制引擎对下统一封装，屏蔽了平台实现。</p>
<p>ReactNative / Weex 作为跨端框架 ，虽然走的也是是原生渲染，但是需要通过 js 来组织和描述 UI，中间需要做一层转换，才可以变成原生的 UI 描述结构，进而原生渲染。</p>
<p>中间多了一层转换过程。</p>
<p>而 Flutter 自建渲染引擎，不依赖平台实现，并且 Dart 可以直接被编译成机器码，从架构上来说，性能相比 ReactNative / Weex 会更好。</p>
<h2 id="2、Flutter-渲染管线"><a href="#2、Flutter-渲染管线" class="headerlink" title="2、Flutter 渲染管线"></a>2、Flutter 渲染管线</h2><p>Flutter 渲染管线的设计是类似的，流程参考下图</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter_graphics_pipeline1.png" alt=""></p>
<p>首先看下用到的线程：</p>
<p>UIThread 是 Platform 创建的子线程，DartVM Root Isolate 所有的 dart 代码都运行在该线程。</p>
<p>阻塞UIThread 会直接导致 Flutter 应用卡顿掉帧、</p>
<p>RasterThread 原本叫做 GPUThread，也是 Platform 创建的子线程，由于很多人误认为运行在 GPU 上，但其实它是运行在 CPU  用于处理数据提交给 GPU，所以 Flutter 团队将其名字改为 Raster，表明它的作用是光栅化。</p>
<p>C++ Engine 中的光栅化和合成过程运行在该线程。</p>
<p>整个流程会经过以下几个过程：</p>
<ul>
<li>C++ Engine 触发 Platform 注册 VSync 垂直信号回调，通过 Platform -&gt; C++ Engine -&gt; Dart Framework 触发整个绘制流程</li>
<li>Dart Framework 构建出四棵树，Widget Tree、Element Tree、RenderObject Tree、Layer Tree，布局、记录绘制区域及绘制指令信息生成 <code>flutter::LayerTree</code>，并保存在 <code>Scene</code> 对象用以光栅化，这个过程运行在  UIThread</li>
<li>通过 Flutter 自建引擎 Skia 进行光栅化和合成操作， 将 <code>flutter::LayerTree</code> 转换为 GPU 指令，并发送给 GPU 完成光栅化合成上屏显示操作，这个过程执行在 RasterThread</li>
</ul>
<p>整个调度过程是生产者消费者模型，它的实现在 Engine 的 <code>LayerTreePipeline</code>。</p>
<p>UIThread 负责生产 <code>flutter::Layer Tree</code>，RasterThread 负责消费 <code>flutter::Layer Tree</code>。</p>
<p>这种调度机制可以确保 RasterThread 不至于过载（2个任务），同时也可以避免 UIThread 不必要的资源消耗。</p>
<p>所以不论在 UIThread 还是在 RasterThread 耗时太久，都可能会导致 Flutter 应用卡顿，因为会导致延迟接受 VSync 信号，导致掉帧。</p>
<p>这个调度过程会在下一篇文章中详细分析。</p>
<h2 id="3、Flutter-UI-绘制管线"><a href="#3、Flutter-UI-绘制管线" class="headerlink" title="3、Flutter UI 绘制管线"></a>3、Flutter UI 绘制管线</h2><p>其中在 UIThread 生成 Layer Tree 的过程，我们将其称为 <code>Rendering Pipeline</code> 绘制管线。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter_rendering_pipeline.png" alt=""></p>
<p>主要过程为：</p>
<ul>
<li>Animate，触发动画更新下一帧的值</li>
<li>Build，触发构建或刷新 Widget Tree、Element Tree、RenderObject Tree</li>
<li>Layout，触发布局操作，确定布局大小和位置信息</li>
<li>CompositeBits，更新需要合成的 Layer 层标记</li>
<li>Paint，触发 RenderObject Tree 的绘制操作，构建 Layer Tree</li>
<li>Composite，触发 Layer Tree 发送到 Engine，生成 Engine LayerTree</li>
</ul>
<p>在 UIThread 构建出四棵树，并在 Engine 生成 Scene，最后提交给 RasterThread，对 LayerTree 做光栅化合成上屏。</p>
<p>下一篇文章分析下 VSync 注册。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/78758247" target="_blank" rel="external">渲染流水线中的光栅化（一）</a></p>
<p><a href="https://developer.aliyun.com/article/770384" target="_blank" rel="external">从架构到源码：一文了解Flutter渲染机制</a></p>
<p><a href="http://gityuan.com/2019/06/15/flutter_ui_draw/" target="_blank" rel="external">Flutter渲染机制—UI线程</a></p>
<p>本文链接： <a href="http://w4lle.com/2020/11/09/flutter-ui-overview/">http://w4lle.com/2020/11/09/flutter-ui-overview/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter UI 渲染系列文章，基于 Flutter v1.20.4&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://w4lle.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 工程架构</title>
    <link href="http://w4lle.com/2019/11/23/flutter-project-manage/"/>
    <id>http://w4lle.com/2019/11/23/flutter-project-manage/</id>
    <published>2019-11-23T14:11:04.000Z</published>
    <updated>2019-11-24T03:41:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍Android视角下在已有 App 中嵌入 Flutter 应用的实践，iOS 的方案思路基本一致。</p>
<a id="more"></a>
<p>系列文章：</p>
<ul>
<li><a href="http://w4lle.com/2019/11/22/flutter-hybrid-stack/">Flutter 混合栈管理</a></li>
<li><a href="http://w4lle.com/2019/11/23/flutter-project-manage/">Flutter 工程架构</a></li>
</ul>
<h1 id="Flutter-工程类型"><a href="#Flutter-工程类型" class="headerlink" title="Flutter 工程类型"></a>Flutter 工程类型</h1><p>Flutter工程中，通常有以下几种工程类型，下面分别简单概述下：</p>
<p><strong>1. Flutter Application</strong></p>
<p>​    纯净的Flutter App工程，包含标准的Dart层与Native平台层(android/&amp;ios/)</p>
<p><strong>2. Flutter Module</strong></p>
<p>​    Flutter模块工程，仅包含Dart层实现，Native平台子工程的作用是构建Flutter产物，是通过Flutter自动生成的隐藏工程（.android/&amp;.ios/）</p>
<p><strong>3. Flutter Plugin</strong></p>
<p>​    Flutter平台插件工程，包含Dart层与Native平台层的实现(android/&amp;ios/)，往外提供API接口</p>
<p><strong>4. Flutter Package</strong></p>
<p>​    Flutter纯Dart插件工程，仅包含Dart层的实现，往往定义一些公共Widget</p>
<p>接入Flutter工程的两种方式：</p>
<ol>
<li>源码集成，在原生项目中Flutter作为lib直接嵌入Flutter代码，编译过程需要依赖Flutter环境，每个开发都需要配置Flutter开发环境，适合全新项目</li>
<li>Flutter项目作为子项目module，生成aar后由原生App依赖，对于App来说屏蔽了Flutter开发环境，在原有环境中即可打包，对App开发来说屏蔽了Flutter环境，适合已经App嵌入Flutter应用</li>
</ol>
<p>本文主要介绍第二种方式，由于Flutter官方并未提供完整的解决方案，所以接入过程中会碰到一些问题，这里给出一些解决思路供参考。</p>
<p>创建一个flutter module：</p>
<p>flutter create -t module –org com.example my_flutter</p>
<p>工程结构：</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesD099FCC6-82A2-4170-A8A1-43C90F44CB65.png" alt=""></p>
<h1 id="FlutterModule-构建-Aar"><a href="#FlutterModule-构建-Aar" class="headerlink" title="FlutterModule 构建 Aar"></a>FlutterModule 构建 Aar</h1><p>flutter build aar</p>
<p>但是这个命令在Flutter v1.7.8版本中会提示找不到这个命令，估计是dev版本新加入的，还没有stable。</p>
<p>不久前加入的 <a href="https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps/_compare/1f606754ee0b18d9970e5fdd7b14d8a6df8d2d72...d648f6b063a0ab7ad4eaf0546e90b1cc75b9d58b" target="_blank" rel="external">https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps/_compare/1f606754ee0b18d9970e5fdd7b14d8a6df8d2d72...d648f6b063a0ab7ad4eaf0546e90b1cc75b9d58b</a></p>
<p>即使没有这个命令，也可以使用./gradlew assembleDebug进行编译，结果是一样的。</p>
<p>如果使用flutter build aar命令，Flutter官方给出的结果是，本地作为localmaven，生成的结构如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">build/host/outputs/repo</div><div class="line"></div><div class="line">└── com</div><div class="line"></div><div class="line">└── example</div><div class="line"></div><div class="line">└── my_flutter</div><div class="line"></div><div class="line">└── flutter_release</div><div class="line"></div><div class="line">├── 1.0</div><div class="line"></div><div class="line">│   ├── flutter_release-1.0.aar</div><div class="line"></div><div class="line">│   ├── flutter_release-1.0.aar.md5</div><div class="line"></div><div class="line">│   ├── flutter_release-1.0.aar.sha1</div><div class="line"></div><div class="line">│   ├── flutter_release-1.0.pom</div><div class="line"></div><div class="line">│   ├── flutter_release-1.0.pom.md5</div><div class="line"></div><div class="line">│   └── flutter_release-1.0.pom.sha1</div><div class="line"></div><div class="line">├── maven-metadata.xml</div><div class="line"></div><div class="line">├── maven-metadata.xml.md5</div><div class="line"></div><div class="line">└── maven-metadata.xml.sha1</div></pre></td></tr></table></figure>
<p>Flutter v1.2版本之后Flutter产物自动会打包到aar中，具体脚本见 flutter.gradle，主要做了三件事情：</p>
<ol>
<li>选择符合对应架构的Flutter引擎（flutter.so）</li>
<li>解析 .flutter-plugins文件，把Flutter对应的android module动态添加到Native工程的依赖中，即动态添加implementation依赖，这块后面会详细讲</li>
<li>Hook mergeAssets/processResources Task，预先执行FlutterTask，调用flutter命令编译Dart层代码构建出flutter_assets产物，并拷贝到assets目录下</li>
</ol>
<p>基于Flutter v1.7.8，编译产物 Debug版本</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images0517FC2D-73DC-4597-A471-8F87E51420B0.png" alt=""></p>
<p>Release版本 </p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesCB70BFBA-A021-4D0C-9614-395D366BF292.png" alt=""></p>
<p>在Flutter v1.7之前，Release的产物如下：</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagese21cd2440bca39a70b30abedaaba4e3be5e090e4.png" alt=""></p>
<p>也就是说Flutter的编译产物，<strong>从四个二进制文件变成了一个 libapp.so 文件</strong>。</p>
<p>这里也涉及到so兼容arm的问题，之前把libflutter.so拷贝到arm目录下即可，现在编译出的libapp.so拷贝过去是有问题的，解决办法可以参考 <a href="https://github.com/lizhangqu/plugin-flutter-armeabi" target="_blank" rel="external">这个项目</a>。</p>
<p>如果在Flutter module 中依赖了Flutter Plugin，那么在App中依赖Flutter module编译出的aar时，会报错，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ERROR: Unable to resolve dependency <span class="keyword">for</span> <span class="string">':app@debug/compileClasspath'</span>: Could not resolve io.flutter.plugins.sharedpreferences:shared_preferences:<span class="number">1.0</span>-SNAPSHOT. </div><div class="line"></div><div class="line">Show Details</div><div class="line"></div><div class="line">Affected Modules: app</div></pre></td></tr></table></figure>
<p>下面会分析下为什么会报错。</p>
<h1 id="Flutter-Plugin依赖原理"><a href="#Flutter-Plugin依赖原理" class="headerlink" title="Flutter Plugin依赖原理"></a>Flutter Plugin依赖原理</h1><p>以Flutter Module为例，看下Flutter Plugin依赖的原理。</p>
<h2 id="flutter-package-get"><a href="#flutter-package-get" class="headerlink" title="flutter package get"></a>flutter package get</h2><p>当Flutter Module在pub中依赖了Flutter Plugin，并且在 flutter package get后，会从远程pubserver拉取依赖的Flutter Plugin，并生成一个文件记录依赖了哪些Flutter Plugin，名字为： <code>.flutter-plugins</code>，内容为 k-v，如：</p>
<p><code>flutter_webview_plugin=/Users/wanglinglong/Develop/flutter/.pub-cache/hosted/pub.flutter-io.cn/flutter_webview_plugin-0.3.5/</code></p>
<p>被拉取到本地后的Flutter Plugin目录如下</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesimage2019-8-6%2011-51-21.png" alt=""></p>
<h2 id="动态依赖"><a href="#动态依赖" class="headerlink" title="动态依赖"></a>动态依赖</h2><p>然后在.android/app/settings.gradle 文件中添加配置脚本，使其在Gradle初始化之后执行解析操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rootProject.name = <span class="string">'android_generated'</span></div><div class="line">setBinding(<span class="keyword">new</span> Binding([gradle: <span class="keyword">this</span>]))</div><div class="line">evaluate(<span class="keyword">new</span> File(settingsDir, <span class="string">'include_flutter.groovy'</span>))</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesimage2019-8-2%2015-19-48.png" alt=""></p>
<p>这个脚本的作用是控制配置(evaluate)顺序，操作是解析.flutter-plugins，得到各个插件的android工程，使其在.android/Flutter 配置完成之后再进行配置解析。Gradle配置阶段的目标是解析每个project中的build.gradle。</p>
<p>然后在.android/Flutter/build.gradle中依赖 </p>
<p><code>apply from: &quot;$flutterRoot/packages/flutter_tools/gradle/flutter.gradle&quot;</code></p>
<p>这个文件中同样解析.flutter-plugins文件，遍历后一个一个 implementation 到./android/Flutter module工程里完成依赖。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesimage2019-8-2%2015-22-42.png" alt=""></p>
<p>所以在Native层面来看这种依赖其实是本地依赖，只不过Flutter Plugin工程路径都在Flutter的环境变量下的缓存目录中。留个思考题，这里用 <code>api</code> 代替 <code>implementation</code> 行不行？</p>
<p>这里的依赖分成两个部分，一部分是原生Native依赖，一部分是Dart依赖。</p>
<p>对于原生部分，Flutter Plugin作为lib被Flutter Module本地依赖，根据Android 编译常识，在打包Aar后，这些<strong>本地依赖的工程lib不能被一起打到Aar中</strong>。</p>
<p>所以当App中依赖Flutter Module的产物Aar时，不能获得Flutter Module 中依赖的Flutter Plugin Android原生依赖，最终会报错。</p>
<p>对于Dart部分，通过pub进行管理依赖，相当于源码依赖，在打包时，这些Plugin的Dart源码部分都参与打包，最终生成Flutter的构建产物。</p>
<p>Flutter Module打包成Aar后，Aar中包含Android原生部分编译产物和Flutter Dart部分编译产物，后面App依赖该Aar后就可以脱离Flutter的编译环境，直接进行apk打包了。</p>
<p>那么如何解决Aar报错的问题？</p>
<h1 id="Flutter-module-依赖-Flutter-Plugin"><a href="#Flutter-module-依赖-Flutter-Plugin" class="headerlink" title="Flutter module 依赖 Flutter Plugin"></a>Flutter module 依赖 Flutter Plugin</h1><p>已有方案大致原理都是收集Flutter Plugin 的Aar文件，然后进一步处理。</p>
<p><strong>方案一：</strong></p>
<p>使用 fat-aar，大致原理就是将所有的Flutter Plugin打包到同一个Aar中，这个方案比较臃肿，还可能涉及到gradle版本适配，而且可能产生多次依赖的问题。不建议使用。</p>
<p><strong>方案二：</strong></p>
<p>遍历所有依赖的Flutter Plugin，搜集Plugin Android工程下的Aar产物并copy到Flutter Module指定目录下，然后再push maven。</p>
<p><strong>方案三：</strong></p>
<p>遍历所有依赖的Flutter Plugin，根据Plugin版本信息，挨个打包成上传到maven。</p>
<p>由于公司内之前碰到到相关需求场景，即同一工程下多个Module如何统一管理的问题，最后解决方案就是使用的方案三，这里依然采用方案三，相比其他两种方案更稳定。</p>
<p>iOS 思路相同，打包成framework后上传到CDN，通过Pod进行依赖管理。</p>
<p>看下实现：</p>
<p>首先在.andorid/Flutter/build.gradle中依赖脚本 <code>apply from: &#39;./publish_flutter_plugin.gradle&#39;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">def flutterUpload = gradle.rootProject.project(<span class="string">':flutter'</span>).tasks.getByName(uploadTaskName)</div><div class="line">gradle.rootProject.ext.pluginList.each &#123; name -&gt;</div><div class="line">    project.afterEvaluate &#123;</div><div class="line">        project.apply plugin: <span class="string">'com.u51.publish'</span></div><div class="line">        <span class="comment">// 修改插件库对插件库的本地依赖为pom依</span></div><div class="line">        modifyPom &#123; pom -&gt;</div><div class="line">            pom.dependencies.findAll &#123; dep -&gt;</div><div class="line">                <span class="keyword">if</span> (rootProject.ext.pluginList.contains(dep.artifactId)) &#123;</div><div class="line">                    dep.groupId = rootProject.ext.groupId</div><div class="line">                    dep.version = rootProject.ext.pluginMap[dep.artifactId]</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 设定插件本地库发布坐标版本号</span></div><div class="line">        project.publish &#123;</div><div class="line">            groupId rootProject.ext.groupId</div><div class="line">            version rootProject.ext.pluginMap[name]</div><div class="line">            artifactId name</div><div class="line">            compileEnvCheck <span class="keyword">false</span></div><div class="line">            sources <span class="keyword">true</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// flutter库 upload在插件本地库均upload完成后</span></div><div class="line">        <span class="keyword">if</span> (pluginUploadTask != <span class="keyword">null</span>&amp;&amp;node==<span class="keyword">null</span>) &#123;</div><div class="line">            flutterUpload.dependsOn(pluginUploadTask)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外这种方案兼容持续集成环境，对于Native层面来讲，无需做任何改动。</p>
<h1 id="Flutter-Plugin-依赖-Flutter-Plugin"><a href="#Flutter-Plugin-依赖-Flutter-Plugin" class="headerlink" title="Flutter Plugin 依赖 Flutter Plugin"></a>Flutter Plugin 依赖 Flutter Plugin</h1><p>上面提到的是Flutter module依赖Flutter Plugin的情况，那么如果是Flutter Plugin工程依赖Flutter Plugin工程有没有问题？</p>
<p>先看下Flutter Plugin的项目结构 <code>flutter create --template=plugin -i swift -a kotlin flutter_plugin</code></p>
<p>在example下运行 flutter run命令，就可以跑起来了。</p>
<p>看下编译产物，其中Aar中只有原生的编译产物，并无Dart编译产物。</p>
<p>所以Flutter Plugin需要被pub依赖，pub将发布到远程的库下载到本地，然后在工程中</p>
<ul>
<li>原生部分，Flutter Module通过上述方案动态添加maven 依赖</li>
<li>Dart部分，Flutter Module通过pub依赖找到Dart源码，在Flutter Module中import引入，相当于源码依赖，共同参与编译，生成最终的 Dart产物</li>
</ul>
<p>上面的场景都是Flutter Module(Flutter Application)依赖Flutter Plugin的情况，那么Flutter Plugin能不能依赖Flutter Plugin，会不会有问题？</p>
<p>首先Dart部分由于是pub依赖，相当于源码依赖，是没有问题的。</p>
<p>原生部分，由于Flutter Plugin在原生部分没有引入include_flutter.groovy(Android)，所以宿主Flutter Pugin无法动态include到子Flutter Plugin，找不到依赖。</p>
<p>解决办法就是再给它加上，方法同上。</p>
<h1 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h1><p>总结来说，对于 Flutter 来讲只有 Flutter Module 和 Flutter Application编译会生成Dart编译产物，而Flutter Application我们基本不用考虑。</p>
<p>所以很自然的得出结论，我们可以把Flutter Module作为隔离层，作为Flutter层的聚合统一输出给 App，App 工程只需通过 maven or Pod 依赖Flutter Module即可。</p>
<p>其余的Flutter相关依赖操作都交给Flutter Module，通过Pub进行管理即可。</p>
<p>这样通过若干个独立工程 Flutter Module、App、Flutter Plugin，就把整个构建流程建立起来了。</p>
<p>更进一步的，如果业务需要，可以在Flutter层进行更细化的划分，把Native组件化的思路对应到Flutter层。</p>
<p>每个Flutter Plugin可以作为独立的业务模块或基础组件，业务组件向下依赖基础组件，在打包时通过Pub传递依赖一起参与打包。</p>
<p>我们期望业务组件之间不互相依赖，就像之前的文章 <a href="http://w4lle.com/2018/11/16/51credit-android-architecture/">51信用卡 Android 架构演进实践</a> 中讲的那样，业务组件不互相依赖只是约定，但不是强制约束，所以要通过一些手段达到强制约束的目的，由于架构还没有演进到这一步，所以没还没有调研方案，后面有需要再研究。</p>
<p>另外还有持续集成 Flutter 环境怎么配置？</p>
<p>以及Flutter版本管理的问题，Flutter版本升级API可能有变动，怎么保证开发同学使用同一版本的Flutter？</p>
<p>参考主流方案使用flutterw进行管理，不详细阐述。</p>
<p>整体结构借用一张图</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter_hybrid_arch.jpg" alt=""></p>
<h2 id="Pub-私服"><a href="#Pub-私服" class="headerlink" title="Pub 私服"></a>Pub 私服</h2><p>参考 <a href="https://github.com/dart-lang/pub_server" target="_blank" rel="external">pub_server</a> 搭建私服。</p>
<h1 id="工程模板"><a href="#工程模板" class="headerlink" title="工程模板"></a>工程模板</h1><p>当依照上面的思路愉快的开发时，会发现当触发<code>flutter package get</code> 命令，.android/&amp;.ios/ 目录就都被还原了，里面的修改都被删除了。</p>
<p>这段操作在 flutter_tools 中进行，官方这么做的目的可能是不希望开发者直接修改.android&amp;.ios/目录，因为这两个目录仅仅是参与编译的中间过渡。</p>
<p>而通过上面的分析，这两个目录是一定要修改的，不然跑不起来。</p>
<p>除此之外还有一个问题，上面提到远程依赖和本地依赖切换，在开发过程中选择本地依赖进行打包，此时Flutter是跑在App中的，需要调试时发现没有入口。</p>
<p>这里可以通过在Flutter Module 中 <code>flutter attach</code>，然后重启App就可以连上Flutter的调试服务，才可以使用hot reload的功能，但是整个流程还是很长，并且hot reload并不是全能的，有些情况下并不能生效，还是要触发全量编译，有没有办法缩短构建路径？</p>
<p>上面的两个问题其实都可以通过自定义工程模板来解决，首先我们修改flutter_tools中的关键代码，使得不覆盖目录。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">packages/flutter_tools/lib/src/commands/packages.dart</div><div class="line">  <span class="meta">@override</span></div><div class="line">  Future&lt;FlutterCommandResult&gt; runCommand() <span class="keyword">async</span> &#123;</div><div class="line">    <span class="comment">// await rootProject.ensureReadyForPlatformSpecificTooling(checkProjects: true);</span></div><div class="line">    logger.startProgress(</div><div class="line">      <span class="string">'这是修改过的 flutter_tools 不会去修改.android 和 .ios 目录下的代码'</span>,</div><div class="line">    );</div><div class="line">    refreshPluginsList(rootProject);</div><div class="line">  	...</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>然后我们修改flutter_tools/template下的模板代码，使其满足我们的需求。这样新建的Flutter Module都是通过模板工程创建的，开发环境一致。</p>
<p>更进一步的，我们可以把<strong>完整可运行</strong>的Module模板放到仓库中使用submodule进行管理，这样每次模板更新后，Module可以实时更新。这部分可以放在flutterw中进行管理。</p>
<p>这里的完整可运行包含两个部分：</p>
<ul>
<li>修改 .android/Flutter/ Module，使其可以满足编译构建需要</li>
<li>修改 .android/app，使其<strong>拥有和工程App同样的运行时环境</strong>，包括登陆注册环境、Hybrid Plugin环境(非Flutter Plugin，这里可以理解为不依赖Flutter环境的、更加通用的Hybrid插件系统)、调试环境、网络环境等等</li>
</ul>
<p>当然这个方案也并不完美，因为涉及到修改flutter_tools，虽然改动不大，但每次Flutter版本还是要做版本兼容。</p>
<p>更好的方案是重写Dart构建流程，将flutter_tools中的流程串起来而不是修改它们，这样就不用做版本迁移了。</p>
<p>好在本身Flutter开发环境就是由flutterw动态配置的，我们把FlutterSDK放在内部仓库进行维护，通过统一管理入口进行管理，对开发来讲透明、无感知。</p>
<p>另外在App中，我们可以通过一些配置来切换远程依赖和本地依赖。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">gradle.properties</div><div class="line"># flutter模块项目开关</div><div class="line">includeFlutterProject=false</div><div class="line">flutterProjectPath=../U51XiaoLanBenFlutter</div><div class="line"></div><div class="line">setting.gradle</div><div class="line">// flutter lib</div><div class="line">if (includeFlutterProject == 'true') &#123;</div><div class="line">    setBinding(new Binding([gradle: this]))</div><div class="line">    evaluate(new File(</div><div class="line">            settingsDir,</div><div class="line">            "$&#123;flutterProjectPath&#125;/.android/include_flutter.groovy"</div><div class="line">    ))</div><div class="line">&#125;</div><div class="line"></div><div class="line">build.gradle</div><div class="line">if (includeFlutterProject == 'true') &#123;</div><div class="line">	implementation project(':flutter')</div><div class="line">  implementation project(':flutter_shell')</div><div class="line">&#125; else &#123;</div><div class="line">	implementation 'com.u51.android:xiaolanben-flutter:0.0.1-SNAPSHOT'</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样可以更方便的进行调试。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章以Android为例子，主要介绍了在接入Flutter过程中碰到的一些问题及解决方案，实际上对于iOS来说也思路基本一致，我们的iOS方案也已经落地。</p>
<p>我们目前只在一个App中进行了实践，实际上对于另外的一个App工程，业务相同的Flutter Plugin应该做到通用性，只需要新建一个Flutter Module做中转就可以集成。</p>
<p>各个App的Flutter运行时环境应该是统一的，目前来看，这个工程架构可以满足多业务组开发并行Flutter的情况。</p>
<p><strong>注：另外这篇文章成文时间较久了，大概几个月前写的，方案对于目前的Flutter v1.9版本依然是适用的。</strong></p>
<p>参考：</p>
<ul>
<li><a href="https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps" target="_blank" rel="external">https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps</a></li>
<li><a href="https://tech.meituan.com/2018/08/09/waimai-flutter-practice.html" target="_blank" rel="external">Flutter原理与实践</a></li>
<li><a href="http://zhengxiaoyong.com/2018/12/16/Flutter%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%9E%B6%E6%9E%84/" target="_blank" rel="external">Flutter混合开发组件化与工程化架构</a></li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2019/11/23/flutter-project-manage/">http://w4lle.com/2019/11/23/flutter-project-manage/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍Android视角下在已有 App 中嵌入 Flutter 应用的实践，iOS 的方案思路基本一致。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://w4lle.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 混合栈管理</title>
    <link href="http://w4lle.com/2019/11/22/flutter-hybrid-stack/"/>
    <id>http://w4lle.com/2019/11/22/flutter-hybrid-stack/</id>
    <published>2019-11-22T10:42:54.000Z</published>
    <updated>2019-11-24T02:58:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flutter-混合栈管理"><a href="#Flutter-混合栈管理" class="headerlink" title="Flutter 混合栈管理"></a>Flutter 混合栈管理</h1><p>本文主要聊一下 Flutter 混合栈，由于 Flutter 版本跨度较大，所以 Flutter API 也有很大变化，下文中前几个方案的实现看看就好，不用深究。重点关注兼容目前 Flutter 版本(v1.9.1) 的实现。本文以 Android 平台为例进行讲解。</p>
<a id="more"></a>
<p>系列文章：</p>
<ul>
<li><a href="http://w4lle.com/2019/11/22/flutter-hybrid-stack/">Flutter 混合栈管理</a></li>
<li><a href="http://w4lle.com/2019/11/23/flutter-project-manage/">Flutter 工程架构</a></li>
</ul>
<h1 id="为什么需要混合栈？"><a href="#为什么需要混合栈？" class="headerlink" title="为什么需要混合栈？"></a>为什么需要混合栈？</h1><p>在讨论 Flutter 之前，先看下 Weex 及 H5 Hybrid 如何处理多实例问题的。</p>
<p>对于Weex，其引入了 JavaScript 通过JS Runtime 完成动态运算，再把运算结果和Native客户端进行通信，完成真实ViewTree的构建、渲染等操作指令。</p>
<p>而当客户端面对多个 Weex 页面时，为了性能方面的考虑，并没有为每个 Weex 页面提供各自独立的 JS Runtime，相反只有一个 JS Runtime，这意味着所有的 Weex 页面共享同一份 JS Runtime，共用全局环境、变量、内存、和外界通信的接口等等。</p>
<p>所以我们可以看到，Weex初始化过程中，只需要初始化一次 JS Framework(weex-jsfm.js)，后面每次打开新的Weex页面都不必重新初始化。</p>
<p>为了隔离Weex独立页面的运行环境，在Native层面，每打开一个Weex页面，都会有一个唯一的WXSDKInstance，其中持有唯一InstanceId，在与JS双向通信过程中，每端都要携带InstanceId，例如声明周期调用：</p>
<ul>
<li><code>createInstance(id, code, ...)</code>：：创建一个新的 Weex 页面，通过一整段 Weex JS Bundle 的代码，在 JS Runtime 开辟一块新的空间用来存储、记录和运算</li>
<li><code>refreshInstance(id, data)</code>：更新这个 Weex 页面的“顶级”根组件的数据</li>
<li><code>destroyInstance(id)</code>：销毁</li>
</ul>
<p>指令调用：</p>
<ul>
<li><code>sendTasks(id, tasks)</code>：发送指令</li>
<li><code>receiveTasks(id, tasks)</code>：接受指令</li>
</ul>
<p>而在 JS Runtime中，每个InstanceId都有一份独立的运算和数据状态等与客户端相对应，JS通过闭包将其隔离在不同的闭包里，达到隔离的目的。</p>
<p>对于需要共享的数据，则不用InstanceId做对应，如WeexSDK初始化过程中的各种 registe：</p>
<ul>
<li><code>registerComponents(xxcomponent)</code> ： 注册视图组件</li>
<li><code>registerModules(xxmodule)</code>：注册功能模块</li>
</ul>
<p>对应Native端代码 <code>mWXBridge.execJS(&quot;&quot;, null, METHOD_REGISTER_XX, args);</code> ，第一个字段即InstanceId为空。这样即可在全局范围内查找并使用已测试的组件和模块，而不需要每个实例分别注册。</p>
<p>再看下 H5 Hybrid 混合开发，H5的容器是webview，可以在一个webview中管理所有H5页面，有点类似目前Flutter的方式；性能方面，Android平台来讲，从 Android 7.0开始，webview可选作为独立进程，Android8.0开始默认开启多进程模式，所以，即使App内打开多个webview也不会导致性能下降的很厉害。</p>
<p>而Flutter一开始的设计就是为了纯净的Flutter应用设计的，纯Flutter应用整个运行生命周期都只有一个FlutterView和Root Isolate，依靠Flutter Framework自身Route支持在FlutterView内部完成界面跳转，类似webview。借用一张图，在新版上有些变化，但大体相通。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20191123170804.png" alt=""></p>
<p>而 Isolate 之间在内存上是隔离的，这个隔离跟上面讲的Weex Instance隔离是两回事情。</p>
<p>Weex Instance隔离可以认为是两个内部类之间的隔离关系（实际是闭包），它们可以通过共同的外部类（一个比喻）来进行通信，可以共用同一份全局变量，也就是说它们之间是可以做到共用内存进行通信的。</p>
<p>而Isolate则是彻底的内存隔离，两个Isolate之间不存在内存上通信的可能性，只能通过第三方介入才可以通信。</p>
<p>试想一种情况，我们在多个页面Widget之间不能直接通信，并且像InheritedWidget也不能做到多Widget数据共享，而我们知道Flutter中的状态管理很大一部分方案都是依赖InheritedWidget来做数据共享的，这就相当于直接废弃了Flutter原生状态管理，得从Native绕道过来通信啦，这对开发来说体验太糟糕。</p>
<p>更重要的是对资源的占用，FlutterEngine运行环境初始就会占用很大内存，通信通道也会创建多个，缓存空间也会有多份，而且每个Engine会存在四个线程（实际是三个）：</p>
<ul>
<li>Platform Task Runner 相当于主线程，跟Flutter Engine的所有交互（接口调用）必须发生在这里，所有Engine实例共享同一个Platform Runner</li>
<li>UI Task Runner 用于执行 Root Isolate，对创建的对象和Widgets进行Layout并生成一个Layer Tree，处理来自Native Plugins的消息响应，Timers，Microtasks</li>
<li>GPU Task Runner 被用于执行GPU指令调用</li>
<li>IO Runner用于 IO 读写</li>
</ul>
<h1 id="Flutter-混合栈方案"><a href="#Flutter-混合栈方案" class="headerlink" title="Flutter 混合栈方案"></a>Flutter 混合栈方案</h1><p>总体来讲有几种种方案：</p>
<ol>
<li>多 Activity 多 FlutterView 方案，即多引擎方案</li>
<li>共享 FlutterView，代表为闲鱼 <a href="https://github.com/FlutterRepo/hybrid_stack_manager" target="_blank" rel="external">hybrid_stack_manager</a></li>
<li>共享 FlutterNativieView，代表为 <a href="https://juejin.im/post/5c419c07f265da616f703aa1" target="_blank" rel="external">微店</a></li>
<li>共享 FlutterView升级版，代表为闲鱼 <a href="https://github.com/alibaba/flutter_boost" target="_blank" rel="external">Flutter_Boost</a></li>
<li>共享 Isolate，代表为 <a href="https://www.msup.com.cn/share/details?id=226" target="_blank" rel="external">头条</a></li>
</ol>
<p>其实核心思想都是公用同一个 FlutterEngine，避免不必要的资源浪费，优化性能及页面跳转体验，并实现多端逻辑统一。</p>
<p>下面会深入理解每个框架的实现细节。</p>
<h2 id="多引擎方案"><a href="#多引擎方案" class="headerlink" title="多引擎方案"></a>多引擎方案</h2><p>多引擎方案即一系列连续Flutter页面对应一个Activity(VC)，类似于webview中打开h5，但是存在着本质上的区别。</p>
<p>例如，我们进行下面一组导航操作：</p>
<p><code>Flutter Page1 -&gt; Flutter Page2 -&gt; Native Page1 -&gt; Flutter Page3</code></p>
<p>我们只需要在Flutter Page1和Flutter Page3创建不同的Flutter实例即可。</p>
<p>这个方案的好处就是简单易懂，逻辑清晰，但是该方案也存在显著的问题：</p>
<ul>
<li>性能问题，每个FlutterView对应一个FlutterEngine，FlutterEngine随着FlutterView的增多而线性增多，而FlutterEngine本身是一个较重的对象。包括线程数量、图片缓存、内存缓存、消息通道等都是存在多份的</li>
<li>通信问题，每个FlutterView对应的Isolate在内存上隔离，也就是说跨FlutterView的Widget间通信需要原生介入支持</li>
<li>转场动画问题，Native之间的跳转动画和Flutter Widget间的跳转动画不同，使用体验不太好</li>
</ul>
<p>总结起来就是多引擎方案不适合在生产环境中使用。</p>
<h2 id="hybrid-stack-manager"><a href="#hybrid-stack-manager" class="headerlink" title="hybrid_stack_manager"></a>hybrid_stack_manager</h2><p>这个框架实现思路很简单，即用XFlutterView包装FlutterView，进而代理 FlutterNativeView。</p>
<p>并且替重写了 FlutterWrapperActivity 用于替换了FlutterActivity，里面的逻辑是相似的，只不过把其中的FlutterView和FlutterActivityDelegate都换成了代理类。</p>
<p>其中的FlutterView是唯一的，全局共用一个FlutterView。</p>
<p>当发生跳转时，有几种情况：</p>
<p><strong>当原生跳转Flutter时</strong></p>
<ul>
<li>原生跳转Flutter其实是跳转到FlutterWrapperActivity</li>
<li>在FlutterWrapperActivity.onCreate方法中动态绑定FlutterView，并将参数通过MethodChannel传递给Flutter</li>
<li>Flutter通过Navigator管理页面widget，并且在Flutter层唯一确定一个FlutterWrapperActivity</li>
<li>在FlutterWrapperActivity.onResume方法中更新curFlutterActivity，代表当前的FlutterWrapperActivity</li>
</ul>
<p><strong>当Flutter跳转Flutter时</strong></p>
<ul>
<li>Flutter跳转Flutter通过MethodChannel传值给原生，调用curFlutterActivity.openUrl方法</li>
<li>原生这边接收到参数后，再开启一个FlutterWrapperActivity2</li>
<li>截屏保存bitmap，绑定到对应的FlutterWrapperActivity1，并将截图显示出来</li>
<li>FlutterActivity1.onStop方法，移除FlutterView</li>
<li>其余逻辑同上</li>
</ul>
<p><strong>当Flutter跳转原生时</strong></p>
<ul>
<li>Flutter跳原生通过MethodChannel传值给原生，调用curFlutterActivity.openUrl方法</li>
<li>原生这边接收到参数后会返回一个Class，通过startActivity实现页面跳转</li>
<li>截屏保存bitmap，绑定到对应FlutterWrapperActivity，这种情况截屏不需要显示</li>
</ul>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20191122170546.png" alt=""></p>
<p>该方案基于一个事实：<strong>任何时候我们最多只能看到一个页面。（特殊情况不在考虑范围内）</strong></p>
<p>如图所示，当从FlutterActivity跳转到另一个FlutterActivity时，FlutterView从FlutterActivity1移除，并动态绑定到FlutterActivity2。</p>
<p>此时，为了保证切换在显示上的统一，避免FlutterView从FlutterActivity1移除时页面出现白屏的情况，需要对FlutterActivity1进行截屏操作，并且将截屏显示出来。</p>
<p>上面只描述了打开页面的情况，对于返回操作是一样的，在onResume和onStop中分别做处理。</p>
<p>该方案可取之处：</p>
<ul>
<li>每一个页面都有一个VC(Activity)，保证所有基于VC(Activity)生命周期的逻辑(如埋点等)照常工作</li>
<li>不同的Flutter页面之间可以正常通信，共享数据</li>
<li>Native可以调起任意的Flutter页面，无论是首次打开还是之后</li>
</ul>
<p>这种方案的缺点：</p>
<ul>
<li>需要反射FlutterSDK，<strong>侵入性强</strong></li>
<li>单例的HybridStackManager持有context上下文，容易造成内存泄露</li>
<li><strong>强依赖Flutter版本</strong>，实现基于Flutter v0.x</li>
<li>依赖FlutterSDK NavigatorState history属性，新版该属性已经私有化，所以 <a href="https://github.com/FlutterRepo/hybrid_stack_manager/issues/5" target="_blank" rel="external">新版不可用</a></li>
<li>同级的Flutter页面无法实现，例如tab中的同级Flutter页面</li>
<li>每个FlutterActivity都持有一张截屏的bitmap，占用内存空间</li>
</ul>
<h2 id="共享FlutterNativeView方案"><a href="#共享FlutterNativeView方案" class="headerlink" title="共享FlutterNativeView方案"></a>共享FlutterNativeView方案</h2><p>跟方案2类似，只不过从全局共用FlutterView变为全局共用一个FlutterNativeView，保持一个Flutter页面对应一个原生Activity(VC)。<a href="https://juejin.im/post/5c419c07f265da616f703aa1" target="_blank" rel="external">原理解析</a>及部分<a href="https://github.com/voiddog/hybrid_stack_manager" target="_blank" rel="external">源码</a></p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesflutter_weidian.jpg" alt=""></p>
<p>在实现上跟方案二类似，但是要更简洁，废弃了FlutterActivity，重写了FlutterWrapperActivity，仍然复用Delegate用于管理生命周期，在onCreate方法中判断FlutterNativeView是否已经attach过，如果已经attach，那么就先detach操作，detach操作是重点。</p>
<p>同样的，在FlutterWrapperActivity的onDestroy方法中，也需要detach操作。</p>
<p>FlutterNativeView的声明是static，所以是全局唯一的，可以与任何FlutterWrapperActivity对应的FlutterView绑定。</p>
<p>因为在初始化时，getFlutterView和getFlutterNativeView都被ViewFactory的实现类FlutterWrapperActivity所重写，在构造FlutterView时，将唯一的FlutterNativeView当做参数，传进去就完成了FlutterView和FlutterNativeView的绑定。</p>
<p>并且FlutterNativeView绑定的context是ApplicationContext，所以不存在context内容泄露的风险。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">FlutterWrapperActivity</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> FlutterView <span class="title">createFlutterView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    FlutterNativeView flutterNativeView = createFlutterNativeView();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FlutterView(<span class="keyword">this</span>, <span class="keyword">null</span>, flutterNativeView);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> FlutterNativeView <span class="title">createFlutterNativeView</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sFlutterNativeView == <span class="keyword">null</span>) &#123;</div><div class="line">        isCreatePage = <span class="keyword">true</span>;</div><div class="line">        sFlutterNativeView = <span class="keyword">new</span> FlutterNativeView(getApplicationContext());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sFlutterNativeView;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面提到的detach方法是重点，是因为这是该方案唯一hook FlutterSDK的地方，实际上这里不能说是严格意义上的detach，最终调用的是 FlutterView.nativeSurfaceDestroyed()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onSurfaceDestroyed</span><span class="params">(FlutterView flutterView, FlutterNativeView flutterNativeView)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//Flutter 较旧版本，新版本已不兼容</span></div><div class="line">        Method nativeSurfaceDestroyed = FlutterView.class.getDeclaredMethod(<span class="string">"nativeSurfaceDestroyed"</span>, <span class="keyword">long</span>.class);</div><div class="line">        nativeSurfaceDestroyed.setAccessible(<span class="keyword">true</span>);</div><div class="line">        nativeSurfaceDestroyed.invoke(flutterView, flutterNativeView.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">//对应的老版本engine代码 FlutterView.java</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</div><div class="line">            assertAttached();</div><div class="line">            nativeSurfaceDestroyed(mNativeView.get());</div><div class="line">        &#125;</div><div class="line"> </div><div class="line"> </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeSurfaceDestroyed</span><span class="params">(<span class="keyword">long</span> nativePlatformViewAndroid)</span></span>;</div></pre></td></tr></table></figure>
<p>为了兼容新版本，只需要替换反射那里的实现即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Flutter v1.7.8</span></div><div class="line">Field mFlutterJNI = flutterNativeView.getClass().getDeclaredField(<span class="string">"mFlutterJNI"</span>);</div><div class="line">mFlutterJNI.setAccessible(<span class="keyword">true</span>);</div><div class="line">Object o = mFlutterJNI.get(flutterNativeView);</div><div class="line"> </div><div class="line">Method onSurfaceDestroyed = o.getClass().getDeclaredMethod(<span class="string">"onSurfaceDestroyed"</span>);</div><div class="line">onSurfaceDestroyed.invoke(o);</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">//对应的 FlutterSDK 代码 FlutterView.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</div><div class="line">    FlutterView.<span class="keyword">this</span>.assertAttached();</div><div class="line">    FlutterView.<span class="keyword">this</span>.mNativeView.getFlutterJNI().onSurfaceDestroyed();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改后在Flutter v1.7.8版本上可以顺利运行。</p>
<p>其中，<a href="https://github.com/flutter/engine" target="_blank" rel="external">Flutter Engine代码地址</a>，平台代码目录在 shell/platform/android</p>
<p>该方案最大的特点是不需要截屏，是因为FlutterView是和FlutterActivity绑定的，当切换FlutterActivity时，FlutterNativeView 从 FlutterView1 detach，此时FlutterActivity1中的FlutterView1显示的内容不再更新，所以显示内容不变，不用担心白屏的问题。</p>
<p>iOS 如果支持滑动返回的话可能还是需要截屏，因为在侧滑的时候，页面不一定结束。</p>
<p>总结一下，该方案的优点：</p>
<ul>
<li>hook 少，侵入性较少，就一处</li>
<li>不需要截屏，内存占用会稍微好一点</li>
<li>单例的FlutterNativeView不持有Activity的context，没有内存泄露的风险</li>
<li>支持页面间数据传递，切是await 的方式，非通知形式</li>
</ul>
<p>缺点：</p>
<ul>
<li>首次进入白屏时间较长</li>
<li>不支持平级的FlutterView展示，比如tab中的Flutter界面</li>
</ul>
<p>总体来说，这个方案还是有很大的参考价值的。</p>
<h2 id="FlutterBoost"><a href="#FlutterBoost" class="headerlink" title="FlutterBoost"></a>FlutterBoost</h2><p><a href="https://github.com/alibaba/flutter_boost" target="_blank" rel="external">项目地址</a></p>
<p>该方案是多Navigator方案，要研究这个方案的实现，首先要先读下Flutter中路由管理和Widget层级关系的相关代码，可以看<a href="https://juejin.im/post/5c8db8e8f265da2d864b889f" target="_blank" rel="external">这篇文章</a>。</p>
<p>具体原理即Flutter层通过封装过的Widget，即ContainerManagerWidget，管理多个Navigator，每个Navigator对应一个（或多个）具体的业务Widget，并且支持当前Navigator中正常的push Widget的操作。</p>
<p>原生层和Flutter层的容器通过唯一id对应起来，并通过消息通道进行生命周期同步和数据交互。</p>
<p>这里原生层是驱动方，所有的页面级别的操作都是统一发送到原生层处理，然后再次分发同步给Flutter层依次处理。</p>
<h3 id="多Navigator实现"><a href="#多Navigator实现" class="headerlink" title="多Navigator实现"></a>多Navigator实现</h3><p>这个方案的精髓在于，从FlutterView中的单Navigator栈级别的导航，进化到了多Navigator平级导航，即可以随时随地找到任意一个Flutter页面，它们之间的关系是同级的。这在之前的方案中是做不到的。</p>
<p>下面主要分析下多Navigator的实现。</p>
<p>首先，在Flutter中，万事皆Widget。</p>
<p>Navigator也不例外。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20191122173237.png" alt=""></p>
<p>对于Navigator的页面管理，比如 Navigator.of(context).push(route); 默认从当前控件的context依次向上寻找距离自己最近的NavigatorState，然后调用它的push方法入栈。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> NavigatorState of(</div><div class="line">    BuildContext context, &#123;</div><div class="line">      <span class="built_in">bool</span> rootNavigator = <span class="keyword">false</span>,</div><div class="line">      <span class="built_in">bool</span> nullOk = <span class="keyword">false</span>,</div><div class="line">    &#125;) &#123;</div><div class="line">    <span class="keyword">final</span> NavigatorState navigator = rootNavigator</div><div class="line">        ? context.rootAncestorStateOfType(<span class="keyword">const</span> TypeMatcher&lt;NavigatorState&gt;())</div><div class="line">        : context.ancestorStateOfType(<span class="keyword">const</span> TypeMatcher&lt;NavigatorState&gt;());</div><div class="line">    <span class="keyword">return</span> navigator;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@override</span></div><div class="line">State ancestorStateOfType(TypeMatcher matcher) &#123;</div><div class="line">  <span class="comment">///向父节点寻找类型匹配的对象</span></div><div class="line">  <span class="keyword">assert</span>(_debugCheckStateIsActiveForAncestorLookup());</div><div class="line">  <span class="built_in">Element</span> ancestor = _parent;</div><div class="line">  <span class="keyword">while</span> (ancestor != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (ancestor <span class="keyword">is</span> StatefulElement &amp;&amp; matcher.check(ancestor.state))</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    ancestor = ancestor._parent;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">final</span> StatefulElement statefulAncestor = ancestor;</div><div class="line">  <span class="keyword">return</span> statefulAncestor?.state;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以只要在Navigator中再插入一个ContainerManagerWidget，进行拦截页面跳转的操作，用来管理多个Navigator，这样就实现了Flutter页面的扁平化操作，规避掉了原有Navigator的栈结构。</p>
<p>Flutter层的整体架构图如下</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20191122173608.png" alt=""></p>
<p>其中，ContainerManager自己维护了一个Overlay，用于管理多Navigator的上下文切换。</p>
<p>由于OverlayState在遍历entry过程中是倒叙的，所以只要保证列表结构的 _leastEntries 在添加_ContainerOverlayEntry时，始终保持onstage需要前台展示的最后添加即可。</p>
<p>上面提到原生层和Flutter层的容器通过唯一id对应起来，并通过消息通道进行生命周期同步和数据交互。</p>
<p>而在Flutter层，每个Widget之间是共享内存的，它们之间可以共用同一套运行环境、全局变量、内存、通信接口等。所以他们之间可以正常通信，</p>
<p>这样看是不是和Weex JS 层有点像了。</p>
<p>实际上当深入了解后，会发现在DOM处理、View的映射关系上Flutter和Weex有很多相似支持。</p>
<p>比如Flutter中的三棵树 —— Widget、Element、RenderObject 和 Weex Native 中的三棵树—— WxDomObject、WXComponent、NativeView 之间的相似性等等。</p>
<h3 id="原生层实现"><a href="#原生层实现" class="headerlink" title="原生层实现"></a>原生层实现</h3><p>对于原生层有两种实现，我们分别来看：</p>
<ol>
<li>共享FlutterView</li>
<li>共享FlutterEngine</li>
</ol>
<p><strong>共享 FlutterView ：</strong></p>
<p>分析的代码基于master分支，当前版本0.420，适用于<strong>Flutter v1.5</strong>之前的版本。</p>
<p>整体上来说，该方案使用了较为复杂的FlutterView共享管理方案，FlutterView仍然是单例的，但是相对于方案二hybrid_stack_manager有了长足的进步，逻辑复杂度也提高了不少。</p>
<p>下图是官方提供的原理图</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20191122173908.png" alt=""></p>
<p>对于原生层和Flutter层来说，分别有一个ContainerManager用于管理调度Flutter容器，这个容器的概念，在原生层就是包装过的FlutterActivity，在Flutter层是Navigator。</p>
<p>简单来说，原生层通过ContainerManager管理包装过的FlutterActivity，从而共享单例的FlutterView。</p>
<p>这里为了避免切换过程中出现白屏的问题，依然需要截屏。</p>
<p>由于截屏，这里可能依然会出现闪动、黑屏的出现，见 <a href="https://github.com/alibaba/flutter_boost/issues/221" target="_blank" rel="external">issue</a></p>
<p><strong>共享 FlutterEngine：</strong></p>
<p>分支：flutter_1.5_upgrade_opt 适配了<strong>Flutter v1.5</strong>版本。</p>
<p>该方案是多FlutterView，单FlutterEngine的方案，有点类似于共享FlutterNativeView方案。</p>
<p>实际上这里的<strong>FlutterEngine就是Flutter v1.5版本之后用于替代FlutterNativeView的。</strong></p>
<p><strong>高版本的FlutterSDK，提供了embedding包，该包下提供了新的容器实现及TextureView的支持。</strong></p>
<p>该方案仍然是废弃了FlutterActivity，而自己组装了一个BoostFlutterActivity，并且废弃了delegate相关声明周期管理，所有的声明周期管理都是自己来管理。</p>
<p>不同点在于共享FlutterNativeView方案 detach过程中需要反射拿到FlutterJNI，进而调用onSurfaceDestroyed方法，而这个方案不需要，最终在FlutterView的detach过程中，调用路径 FlutterView.detach()-&gt;FlutterRender.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">detachFromRenderSurface()-&gt;</div><div class="line">FlutterRender.surfaceDestroyed()-&gt;</div><div class="line">flutterJNI.onSurfaceDestroyed()-&gt;</div><div class="line">FlutterJNI.nativeSurfaceDestroyed()</div></pre></td></tr></table></figure>
<p>可以看到最终需要调用的方法是一致的，都需要调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flutterJNI.nativeSurfaceDestroyed().</div></pre></td></tr></table></figure>
<p>以Flutter v1.5为界限简单对比如下：</p>
<p><strong>Flutter v1.5 之前的 Android SDK：</strong></p>
<p>io.flutter.view.FlutterView: 与FlutterNativeView关联，FlutterNativeView通过DartExecutor对FlutterJNI下jni方法进行消息通道传递；</p>
<p>视图渲染实际实现为SurfaceView；</p>
<p>视图销毁与创建通过embedding包下的FlutterJNI通知native</p>
<p>核心成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private final DartExecutor dartExecutor;</div><div class="line">private final FlutterRenderer flutterRenderer;</div><div class="line">private final NavigationChannel navigationChannel;</div><div class="line">private final KeyEventChannel keyEventChannel;</div><div class="line">private final LifecycleChannel lifecycleChannel;</div><div class="line">private final LocalizationChannel localizationChannel;</div><div class="line">private final PlatformChannel platformChannel;</div><div class="line">private final SettingsChannel settingsChannel;</div><div class="line">private final SystemChannel systemChannel;</div><div class="line">private final InputMethodManager mImm;</div><div class="line">private final TextInputPlugin mTextInputPlugin;</div><div class="line">private final AndroidKeyProcessor androidKeyProcessor;</div><div class="line">private final AndroidTouchProcessor androidTouchProcessor;</div></pre></td></tr></table></figure>
<p><strong>Flutter 1.5之后的 Android SDK提供了embedding包，废弃了io包：</strong></p>
<p>io.flutter.embedding.android.FlutterView 与FlutterEngine关联，废弃了FlutterNativeView；</p>
<p>视图渲染实际为FlutterSurefaceView或FlutterTextureView；</p>
<p>视图销毁与创建通过embedding包下的FlutterJNI通知native；</p>
<p>核心成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private FlutterView.RenderMode renderMode;</div><div class="line">private FlutterView.TransparencyMode transparencyMode;</div><div class="line">private RenderSurface renderSurface;</div><div class="line">private FlutterEngine flutterEngine;</div><div class="line">private TextInputPlugin textInputPlugin;</div><div class="line">private AndroidKeyProcessor androidKeyProcessor;</div><div class="line">private AndroidTouchProcessor androidTouchProcessor;</div><div class="line">private AccessibilityBridge accessibilityBridge;</div></pre></td></tr></table></figure>
<p>Flutter Engine核心成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private final AccessibilityChannel accessibilityChannel;</div><div class="line">private final KeyEventChannel keyEventChannel;</div><div class="line">private final LifecycleChannel lifecycleChannel;</div><div class="line">private final LocalizationChannel localizationChannel;</div><div class="line">private final NavigationChannel navigationChannel;</div><div class="line">private final PlatformChannel platformChannel;</div><div class="line">private final SettingsChannel settingsChannel;</div><div class="line">private final SystemChannel systemChannel;</div><div class="line">private final TextInputChannel textInputChannel;</div></pre></td></tr></table></figure>
<p>另外，在最新版本 Flutter v1.9.1 已经提供了FlutterEngineProvider相关接口，即官方有意提供混合栈的管理方案，但现在只是个半成品，如果直接用的话，会发现返回键点不动，跟了下发现是把PlatformChannel的Handler给置空了，除此之外还有一些其他的问题。</p>
<p>具体实现参见最新版的Flutter_Boost，已经做好了Flutter v1.9.1的适配，总体上实现已经跟embedding差别不大，有差别的点在于FlutterEngine的attach和detach的时机不同、FlutterPlugin的生命周期做了下同步，感兴趣的自己去阅读，这里不详细说了。</p>
<p>总结一下：</p>
<p>优点：</p>
<ul>
<li>Flutter层多Navigator方案，支持同级Flutter Widget随意切换</li>
<li>提供了一种新的思路，理论上Flutter跳转可以仍然使用官方api，可以在中间拦截</li>
<li>多FlutterView，不需要截屏</li>
</ul>
<p>缺点：</p>
<ul>
<li>略有侵入性，各个Flutter版本需要适配</li>
</ul>
<h2 id="共享Isolate"><a href="#共享Isolate" class="headerlink" title="共享Isolate"></a>共享Isolate</h2><p>头条的方案，多FlutterView，多FlutterEngine，单Isolate方案</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20191122175942.png" alt=""></p>
<p>该方案需要修改Flutter engine源码，暂不考虑。</p>
<p>多FlutterEngine在同一运行环境下可以做到内存共享，但同时也需要注意内存同步的问题，毕竟每个FlutterEngine都各自持有UITaskRunner，可以同时操作同一份内存的，头条的解决方案是把这些线程全部做成共享的了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分析了上面几种混合栈管理方案，整体上来说闲鱼的共享FlutterEngine方案比较主流，其中的多Navigator有很大的参考价值。</p>
<p>对于51信用卡来说，可以以此为基础，建设符合公司内部使用的混合栈管理方案。主要有几个事情：</p>
<ul>
<li>Plugin 管理问题，Plugin 是指每条指令对应在Native（Android、iOS）上的实现，得益于Hybrid的基础设施建设，公司内部目前有200+ Plugin可以直接使用，这也就意味着大部分需要Native参与的功能，都已经实现好了，Flutter 端直接调用即可，这块可以参考之前的文章 <a href="http://w4lle.com/2018/11/16/51credit-android-architecture/">51信用卡 Android 架构演进实践</a> </li>
<li>路由管理，接入已有路由框架</li>
<li>Flutter v1.9.1兼容</li>
</ul>
<p>经过几个版本的迭代，目前已经完成了上面的几件事情，并在业务中使用。</p>
<p><strong>注：此篇文章成文时间较久，近期做了一些修改，主要增加了Flutter v1.9.1 及相关的内容。</strong></p>
<p>参考</p>
<ul>
<li><p><a href="https://jiongks.name/blog/weex-multi-instance-runtime/" target="_blank" rel="external">Weex 在 JS Runtime 内的多实例管理</a></p>
</li>
<li><p><a href="https://www.jiqizhixin.com/articles/2019-03-07-15" target="_blank" rel="external">Flutter混合开发——FlutterBoost</a></p>
</li>
<li><p><a href="https://juejin.im/post/5b764acb51882532dc1812b1" target="_blank" rel="external">Flutter新锐专家之路：混合开发篇</a></p>
</li>
<li><p><a href="https://juejin.im/post/5c419c07f265da616f703aa1" target="_blank" rel="external">微店的Flutter混合栈管理技术实践</a></p>
</li>
<li><p><a href="https://www.msup.com.cn/share/details?id=226" target="_blank" rel="external">让Flutter真正支持View级别的混合开发</a></p>
</li>
<li><a href="https://zhuanlan.zhihu.com/p/38026271" target="_blank" rel="external">为追求高性能，我必须告诉你Flutter引擎线程的事实</a></li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2019/11/22/flutter-hybrid-stack/">http://w4lle.com/2019/11/22/flutter-hybrid-stack/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Flutter-混合栈管理&quot;&gt;&lt;a href=&quot;#Flutter-混合栈管理&quot; class=&quot;headerlink&quot; title=&quot;Flutter 混合栈管理&quot;&gt;&lt;/a&gt;Flutter 混合栈管理&lt;/h1&gt;&lt;p&gt;本文主要聊一下 Flutter 混合栈，由于 Flutter 版本跨度较大，所以 Flutter API 也有很大变化，下文中前几个方案的实现看看就好，不用深究。重点关注兼容目前 Flutter 版本(v1.9.1) 的实现。本文以 Android 平台为例进行讲解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://w4lle.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>UI2Code（三）imgcook</title>
    <link href="http://w4lle.com/2019/04/08/UI2Code-2/"/>
    <id>http://w4lle.com/2019/04/08/UI2Code-2/</id>
    <published>2019-04-08T11:30:15.000Z</published>
    <updated>2019-11-24T02:58:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>imgcook是阿里实现的基于sketch或Ps设计稿，自动生成布局代码的工具，支持生成支持flexbox布局的代码，包括JARVIS、Vue、微信小程序、React、H5、Rax等等。由两部分组成，一个是sketch(Ps)插件，另外一部分是<a href="https://imgcook.taobao.org/" target="_blank" rel="external">imgcook平台</a>。</p>
<a id="more"></a>
<p>系列文章：</p>
<ul>
<li><a href="http://w4lle.com/2019/03/13/UI2Code-0/">UI2Code（一）pix2code</a></li>
<li><a href="http://w4lle.com/2019/03/22/UI2Code-1/">UI2Code（二）pixeltoapp</a></li>
<li><a href="http://w4lle.com/2019/04/08/UI2Code-2/">UI2Code（三）imgcook</a></li>
</ul>
<p>经过前面的研究，我们知道，UI2Code作为可以从UI截图生成布局代码的工作，其构建流程大致如下：</p>
<ol>
<li>版面分析，包含背景分析和前景分析</li>
<li>提取GUI元素</li>
<li>组件识别</li>
<li>属性提取</li>
<li>布局推导</li>
<li>DSL 推导</li>
<li>编译，得到目标平台代码</li>
</ol>
<p>其中难点是版面分析和布局推导。</p>
<p>版面分析，目的是得到相对准确的背景和前景，通过传统的计算机图像计算和机器学习，将UI图片拆分并分层，得到相对独立的控件，为下一步控件识别和属性提取做准备。可以说，这部分做的好坏直接影响到后面所有的流程。</p>
<p>而对于线上业务逻辑来说，UI图千变万化，背景和前景可能存在很复杂的耦合关系，没有统一的规则约束，这就导致版面分析的难度较大。</p>
<ol>
<li>通过纯图像计算，版面分析不准确，组件间的提取不够独立或被隔断，泛化能力不够</li>
<li>通过机器学习识别，控件属性信息不全，没有坐标、宽度等信息，且准确度不够</li>
</ol>
<p>所以将图像计算与机器学习相结合，通过上述1、2、3、4步骤得到一定泛化能力且相对准确的版面结构和控件信息。</p>
<p>而对于我们来说，1、2、3、4步想要得到的内容，在Sketch设计稿里面都是有提供的，我们只需要想办法将其提取处理就可以，然后进行下一步操作。</p>
<p>所以经过优化后，整个流程如下：</p>
<ol>
<li>提取 Sketch 设计稿信息</li>
<li>布局推导</li>
<li>DSL 推导</li>
<li>编译</li>
</ol>
<p>imgcook 做的就是这样的事情。</p>
<h1 id="实际效果"><a href="#实际效果" class="headerlink" title="实际效果"></a>实际效果</h1><p>页面级别 ：</p>
<p>设计稿 </p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1bpzqptv3j30k2120wh6.jpg" alt=""> </p>
<p>运行效果 </p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1gfnovz73j30u01rcmys.jpg" alt=""> </p>
<p>卡片级别 ：</p>
<p>设计稿 </p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1gfb9ubk6j30ku098my0.jpg" alt=""> </p>
<p>运行效果 </p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1gfe6muckj30tu0glmz3.jpg" alt=""></p>
<h1 id="实现拆解"><a href="#实现拆解" class="headerlink" title="实现拆解"></a>实现拆解</h1><p>主要分为几个大的过程：</p>
<ol>
<li>Sketch -&gt; Json</li>
<li>Json -&gt; DSL</li>
<li>DSL -&gt; Code</li>
</ol>
<p>分别来看下。</p>
<h2 id="sketchToJson"><a href="#sketchToJson" class="headerlink" title="sketchToJson"></a>sketchToJson</h2><p>在sketch中选中图层，或者symbol，选中imgcook插件导出，当从sketch导出时，会产生一个json文件，以上面第二个卡片为例，信息如下 </p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1gg7w0xdqj31440u0wk9.jpg" alt=""> </p>
<p>其中包含的信息包括： </p>
<ul>
<li><p>artboardImg，选中symbol的渲染图，如<a href="https://ai-sample.oss-cn-hangzhou.aliyuncs.com/test/b4dd75404f6e11e9b26815c07ac4b122.png" target="_blank" rel="external">https://ai-sample.oss-cn-hangzhou.aliyuncs.com/test/b4dd75404f6e11e9b26815c07ac4b122.png</a> </p>
</li>
<li><p>控件唯一id </p>
</li>
<li><p>控件类型，比如Text、Image、Shape、Repeat </p>
</li>
<li><p>控件属性props，包括xy坐标、宽高、背景色、背景圆角、溢出处理(overflow)、图片内容、文字内容、字体和大小、字体颜色、行高、行数等等 </p>
</li>
<li><p>children属性，这个一般都是铺平的，当时Type是Repeat时会有该值 </p>
</li>
</ul>
<p>而在插件处理过程中，可能会有以下过程：</p>
<ul>
<li><p>没有图层信息，图层信息都被过滤掉 </p>
</li>
<li><p>平铺的数组，没有层级关系和兄弟关系 </p>
</li>
<li><p>Repeat包含多个children，内容是Text </p>
</li>
<li><p>完全被遮挡或者不可见的控件被过滤 </p>
</li>
<li><p>复杂的mask计算，对于遮罩的处理 </p>
</li>
<li><p>控件类型和属性都是依次解析 </p>
</li>
</ul>
<p>相当于把sketch文件中的所有信息都处理过后，得到一份期望的json文件，其中基本没有布局层次属性，仅有控件属性，包括大小、位置、控件特有属性等。</p>
<p>布局层次关系及位置关系由下一步来具体确定。</p>
<h2 id="JsonToDSL"><a href="#JsonToDSL" class="headerlink" title="JsonToDSL"></a>JsonToDSL</h2><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1ghk5j5h0j31iw0u0aim.jpg" alt=""> </p>
<p>把上面的json复制到imgcook平台，会发起gen-layout-process请求，该请求会把json文件当做请求参数上传，并返回一个dsl的Response，请求抓包文件结果经过缩减后大概如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"type"</span>: <span class="string">"Block"</span>,</div><div class="line">  <span class="attr">"id"</span>: <span class="string">"Block-661077"</span>,</div><div class="line">  <span class="attr">"__VERSION__"</span>: <span class="string">"2.0"</span>,</div><div class="line">  <span class="attr">"mask"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">"props"</span>: &#123;</div><div class="line">    <span class="attr">"style"</span>: &#123;</div><div class="line">      <span class="attr">"display"</span>: <span class="string">"flex"</span>,</div><div class="line">      <span class="attr">"alignItems"</span>: <span class="string">"flex-start"</span>,</div><div class="line">      <span class="attr">"flexDirection"</span>: <span class="string">"column"</span>,</div><div class="line">      <span class="attr">"width"</span>: <span class="number">375</span>,</div><div class="line">      <span class="attr">"height"</span>: <span class="number">164</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"attrs"</span>: &#123;</div><div class="line">      <span class="attr">"x"</span>: <span class="number">0</span>,</div><div class="line">      <span class="attr">"y"</span>: <span class="number">0</span>,</div><div class="line">      <span class="attr">"className"</span>: <span class="string">"block-661077"</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"children"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"__VERSION__"</span>: <span class="string">"2.0"</span>,</div><div class="line">      <span class="attr">"props"</span>: &#123;</div><div class="line">        <span class="attr">"style"</span>: &#123;</div><div class="line">          <span class="attr">"display"</span>: <span class="string">"flex"</span>,</div><div class="line">          <span class="attr">"alignItems"</span>: <span class="string">"flex-start"</span>,</div><div class="line">          <span class="attr">"flexDirection"</span>: <span class="string">"row"</span>,</div><div class="line">          <span class="attr">"backgroundColor"</span>: <span class="string">"#ffffff"</span>,</div><div class="line">          <span class="attr">"width"</span>: <span class="number">375</span>,</div><div class="line">          <span class="attr">"height"</span>: <span class="number">68</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">"attrs"</span>: &#123;</div><div class="line">          <span class="attr">"x"</span>: <span class="number">0</span>,</div><div class="line">          <span class="attr">"y"</span>: <span class="number">0</span>,</div><div class="line">          <span class="attr">"className"</span>: <span class="string">"shape-0"</span></div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      <span class="attr">"children"</span>: [</div><div class="line">        &#123;</div><div class="line">          <span class="attr">"__VERSION__"</span>: <span class="string">"2.0"</span>,</div><div class="line">          <span class="attr">"props"</span>: &#123;</div><div class="line">            <span class="attr">"style"</span>: &#123;</div><div class="line">              <span class="attr">"marginTop"</span>: <span class="number">6</span>,</div><div class="line">              <span class="attr">"marginLeft"</span>: <span class="number">6</span>,</div><div class="line">              <span class="attr">"width"</span>: <span class="number">23</span>,</div><div class="line">              <span class="attr">"height"</span>: <span class="number">23</span></div><div class="line">            &#125;,</div><div class="line">            <span class="attr">"attrs"</span>: &#123;</div><div class="line">              <span class="attr">"x"</span>: <span class="number">22</span>,</div><div class="line">              <span class="attr">"y"</span>: <span class="number">22</span>,</div><div class="line">              <span class="attr">"source"</span>: <span class="string">"https://ai-sample.oss-cn-hangzhou.aliyuncs.com/test/b46d27404f6e11e98785ebe830f6201d.png"</span>,</div><div class="line">              <span class="attr">"src"</span>: <span class="string">"https://ai-sample.oss-cn-hangzhou.aliyuncs.com/test/b46d27404f6e11e98785ebe830f6201d.png"</span>,</div><div class="line">              <span class="attr">"className"</span>: <span class="string">"image-7"</span></div><div class="line">            &#125;</div><div class="line">          &#125;,</div><div class="line">          <span class="attr">"children"</span>: [],</div><div class="line">          <span class="attr">"type"</span>: <span class="string">"Image"</span>,</div><div class="line">          <span class="attr">"id"</span>: <span class="string">"Image-7"</span>,</div><div class="line">          <span class="attr">"componentType"</span>: <span class="string">"picture"</span>,</div><div class="line">          <span class="attr">"_jsonId"</span>: <span class="string">"Image-7"</span>,</div><div class="line">          <span class="attr">"_jsonElementId"</span>: <span class="string">"Image-7"</span>,</div><div class="line">          <span class="attr">"title"</span>: <span class="string">"Image"</span>,</div><div class="line">          <span class="attr">"semantic"</span>: &#123;</div><div class="line">            <span class="attr">"dvc_default"</span>: [</div><div class="line">              &#123;</div><div class="line">                <span class="attr">"name"</span>: <span class="string">"dvc_default"</span>,</div><div class="line">                <span class="attr">"level"</span>: <span class="number">100</span>,</div><div class="line">                <span class="attr">"result"</span>: <span class="string">"img"</span>,</div><div class="line">                <span class="attr">"prefix"</span>: <span class="string">""</span>,</div><div class="line">                <span class="attr">"id"</span>: <span class="number">262862</span></div><div class="line">              &#125;</div><div class="line">            ],</div><div class="line">            <span class="attr">"dvc_picture"</span>: [</div><div class="line">              &#123;</div><div class="line">                <span class="attr">"name"</span>: <span class="string">"dvc_picture"</span>,</div><div class="line">                <span class="attr">"level"</span>: <span class="number">88</span>,</div><div class="line">                <span class="attr">"result"</span>: <span class="string">"zhaoshangbank"</span>,</div><div class="line">                <span class="attr">"prefix"</span>: <span class="string">""</span>,</div><div class="line">                <span class="attr">"id"</span>: <span class="number">953603</span>,</div><div class="line">                <span class="attr">"choose"</span>: <span class="literal">true</span></div><div class="line">              &#125;</div><div class="line">            ]</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      ],</div><div class="line">      <span class="attr">"type"</span>: <span class="string">"Shape"</span>,</div><div class="line">      <span class="attr">"id"</span>: <span class="string">"Shape-0"</span>,</div><div class="line">      <span class="attr">"__ADAPT__"</span>: <span class="literal">true</span>,</div><div class="line">      <span class="attr">"componentType"</span>: <span class="string">"view"</span>,</div><div class="line">      <span class="attr">"_jsonId"</span>: <span class="string">"Shape-0"</span>,</div><div class="line">      <span class="attr">"_jsonElementId"</span>: <span class="string">"Shape-0"</span>,</div><div class="line">      <span class="attr">"title"</span>: <span class="string">"Shape"</span>,</div><div class="line">      <span class="attr">"semantic"</span>: &#123;</div><div class="line">        <span class="attr">"dvc_layout"</span>: []</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  <span class="attr">"artboardImg"</span>: <span class="string">"https://ai-sample.oss-cn-hangzhou.aliyuncs.com/test/b4dd75404f6e11e9b26815c07ac4b122.png"</span>,</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"可提1 copy"</span>,</div><div class="line">  <span class="attr">"componentType"</span>: <span class="string">"view"</span>,</div><div class="line">  <span class="attr">"_jsonId"</span>: <span class="string">"Block-661077"</span>,</div><div class="line">  <span class="attr">"_jsonElementId"</span>: <span class="string">"Block-661077"</span>,</div><div class="line">  <span class="attr">"title"</span>: <span class="string">"Block"</span>,</div><div class="line">  <span class="attr">"semantic"</span>: &#123;</div><div class="line">    <span class="attr">"dvc_default"</span>: [</div><div class="line">      &#123;</div><div class="line">        <span class="attr">"name"</span>: <span class="string">"dvc_default"</span>,</div><div class="line">        <span class="attr">"level"</span>: <span class="number">100</span>,</div><div class="line">        <span class="attr">"result"</span>: <span class="string">"block"</span>,</div><div class="line">        <span class="attr">"prefix"</span>: <span class="string">""</span>,</div><div class="line">        <span class="attr">"id"</span>: <span class="number">613351</span></div><div class="line">      &#125;</div><div class="line">    ],</div><div class="line">    <span class="attr">"dvc_layout"</span>: [</div><div class="line">      &#123;</div><div class="line">        <span class="attr">"name"</span>: <span class="string">"dvc_layout"</span>,</div><div class="line">        <span class="attr">"level"</span>: <span class="number">100</span>,</div><div class="line">        <span class="attr">"result"</span>: <span class="string">"box"</span>,</div><div class="line">        <span class="attr">"prefix"</span>: <span class="string">""</span>,</div><div class="line">        <span class="attr">"id"</span>: <span class="number">803050</span>,</div><div class="line">        <span class="attr">"choose"</span>: <span class="literal">true</span></div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仔细观察该json文件，得出信息： </p>
<ul>
<li><p>完整的DomTree，嵌套关系明确 </p>
</li>
<li><p>控件属性props中多了一些信息，包括布局方式(“display”: “flex”)、flex布局方向(flexDirection)、主轴对齐方式(justifyContent)、副轴对齐方式(alignItems)、文本过长处理(text-overflow)、className、margin定位信息(marginTop、marginLeft) </p>
</li>
<li><p>语义semantic，是一个数组，最终产生一个className </p>
</li>
<li><p>组件类型componentType，包括view、text、picture </p>
</li>
</ul>
<p>这一步完成后，基本就得到了完整可用的布局DSL。</p>
<p>下一步就是compile的过程。</p>
<h2 id="DSL2Code"><a href="#DSL2Code" class="headerlink" title="DSL2Code"></a>DSL2Code</h2><p>DSL compile目标代码的过程，imgcook支持比较多的代码模板，JARVIS、Vue、微信小程序、React、H5、Rax。 </p>
<p>以Vue为例，发起请求，Response 结果这里不再列出，感兴趣的读者可以自行查看。</p>
<p>其中renderCode包含3部分内容： </p>
<ul>
<li><p>template，DOMTree，完整的布局信息，支持动态数据绑定 </p>
</li>
<li><p>script，需要绑定的方法逻辑</p>
</li>
<li><p>style，需要绑定的css样式</p>
</li>
</ul>
<p>分别对应vue中的代码块 </p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1ghaq0z2wj315e068401.jpg" alt=""> </p>
<p>实际的vue代码： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bd"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"zhaoshangbank-wrap"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">img</span></span></div><div class="line">          <span class="attr">class</span>=<span class="string">"zhaoshangbank"</span></div><div class="line">          <span class="attr">src</span>=<span class="string">"https://ai-sample.oss-cn-hangzhou.aliyuncs.com/test/b46d27404f6e11e98785ebe830f6201d.png"</span></div><div class="line">          @<span class="attr">click</span>=<span class="string">"onClick_2"</span></div><div class="line">        /&gt;</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"organization"</span>&gt;</span>招商银行 6889 <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"info"</span>&gt;</span>当前额度 <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>110,000<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      ...</div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"DvcComponent"</span>,</div><div class="line">  <span class="attr">methods</span>: &#123;</div><div class="line">    onClick_2()&#123;</div><div class="line">    	<span class="built_in">console</span>.log(<span class="string">"test"</span>)</div><div class="line">    &#125;,</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></div><div class="line">.box &#123;</div><div class="line">  display: flex;</div><div class="line">  align-items: flex-start;</div><div class="line">  flex-direction: column;</div><div class="line">  width: 375px;</div><div class="line">  height: 164px;</div><div class="line">...</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
<p>从生成的代码中可以看出，div一般使用flex布局。 这里的图片也已经被上传的图床，虽然不可线上使用，但是可以即时的预览。后面可以通过插件导出到本地。</p>
<p>到这里生成的代码基本是可用的，并且在imgcook平台上可以调整样式，绑定方法等操作。</p>
<p>这里的分析是很早以前进行的，数据结构可能已经变更，但大体上应该是相同的。</p>
<h1 id="实现难点"><a href="#实现难点" class="headerlink" title="实现难点"></a>实现难点</h1><p>经过上面的分析，基本知道了imgcook的大致流程，个人其中的难点在如下几个方面：</p>
<p>一是布局推导的过程，这块也是整个UI2Code的核心内容。</p>
<p>从准确性和还原过程中的可选项来看，应该是通过计算得到的，其中的布局细节较多，这块也是最重要的点，其结果直接导致页面布局的好坏。</p>
<p>imgcook平台对于这块的实现猜测是基于切割规则加算法来实现flex布局的，整体上来说基本能够实现设计稿上所体现的布局变化，但是有时候也会显得不够灵活，下面会详细说到。</p>
<p>具体如何实现布局推导，可以期待imgcook官方后续有没有说明。</p>
<p>这里只是引用一下闲鱼之前关于切割方面的论述，基本就是先横切再竖切，递归这个过程，在切割之前可以处理坐标嵌套，得到父子信息，然后在父布局中递归切割过程，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="string">'''</span></div><div class="line">切割方法</div><div class="line">---------------------------|</div><div class="line">|                          | </div><div class="line">|    --------- 30          | </div><div class="line">|    |        |            | </div><div class="line">|    --------- 60          | </div><div class="line">|                          | </div><div class="line">|    —————————— 120        | </div><div class="line">|    |         |           | </div><div class="line">|    ---------- 130        | </div><div class="line">|                          | </div><div class="line">|__________________________|</div><div class="line"></div><div class="line">如上图所示，第一个切线是60，第二个切线是130</div><div class="line">'''</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cut_by_col</span><span class="params">(cut_num, _im_mask)</span>:</span></div><div class="line">    zero_start = <span class="keyword">None</span></div><div class="line">    zero_end = <span class="keyword">None</span></div><div class="line">    end_range = len(_im_mask)</div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, end_range):</div><div class="line">        im = _im_mask[x]</div><div class="line">        <span class="keyword">if</span> len(np.where(im == <span class="number">255</span>)[<span class="number">0</span>]) == len(im):</div><div class="line">            <span class="comment"># 判断是否贯穿整个区域</span></div><div class="line">            <span class="keyword">if</span> zero_start == <span class="keyword">None</span>:</div><div class="line">                zero_start = x</div><div class="line">        <span class="keyword">elif</span> zero_start != <span class="keyword">None</span> <span class="keyword">and</span> zero_end == <span class="keyword">None</span>:</div><div class="line">            zero_end = x</div><div class="line">        <span class="keyword">if</span> zero_start != <span class="keyword">None</span> <span class="keyword">and</span> zero_end != <span class="keyword">None</span>:</div><div class="line">            start = zero_start</div><div class="line">            <span class="keyword">if</span> start &gt; <span class="number">0</span>:</div><div class="line">                <span class="comment"># 首次非联通区域过滤掉</span></div><div class="line">                cut_num.append(start)</div><div class="line">            zero_start = <span class="keyword">None</span></div><div class="line">            zero_end = <span class="keyword">None</span></div><div class="line">        <span class="keyword">if</span> x == end_range - <span class="number">1</span> <span class="keyword">and</span> zero_start != <span class="keyword">None</span> <span class="keyword">and</span> zero_end == <span class="keyword">None</span> <span class="keyword">and</span> zero_start &gt; <span class="number">0</span>:</div><div class="line">            zero_end = x</div><div class="line">            start = zero_start</div><div class="line">            <span class="keyword">if</span> start &gt; <span class="number">0</span>:</div><div class="line">                cut_num.append(start)</div><div class="line">            zero_start = <span class="keyword">None</span></div><div class="line">            zero_end = <span class="keyword">None</span></div></pre></td></tr></table></figure>
<p>切割过后，根据各种优化算法得到实际的布局信息。</p>
<p>当然，实际生产过程肯定要比我猜测的要复杂的多得多。比如什么时候适合flex布局，什么时候适合相对布局，以及谁是优先级更高的，还有是否可以阈值控制来使相对布局变成flex布局等等。</p>
<p>第二个难点是ClassName的语义分析。</p>
<p>猜测是通过机器学习进行OCR图片识别和NLP自然语言处理翻译，这块属于易用性方面的优化。</p>
<p>第三个难点是配套设施，上面分析的都是如何得到一个相对准确的布局DSL，imgcook平台除了这个核心之外，平台给开发者提供了更好的拓展，根据得到的DSL信息，开发者可以根据自己的喜好编译成各种平台、各种语言。另外还有工程化配套的工具，比如导出插件，可以把生成的文件全部导出到本地，不依赖线上图床服务等等。</p>
<h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><ul>
<li><p>数据绑定，需要手动绑定数据，并且data名字要先想好 </p>
</li>
<li><p>图床问题，默认是上传至阿里的图床，不可以直接使用，可以使用导出的zip包中包含所有的icon </p>
</li>
<li><p>界面布局，简版 flex，基本只有方向，默认margin定位 </p>
</li>
<li><p>flex 的对齐方式，比如justify-content: space-between属性阈值较低，大概2个像素，不容易被触发 </p>
</li>
</ul>
<p>不过imgcook团队一直在做优化工作，相信可以做的越来越好用，造福开发者。</p>
<h1 id="u51-weex"><a href="#u51-weex" class="headerlink" title="u51-weex"></a>u51-weex</h1><p>基于以上的分析，和imgcook平台的开放能力，我这边第一时间体验了自定义DSL的功能，由于我们团队内使用weex较多，所以做了一个自定义weex DSL的功能，地址在：<a href="https://github.com/imgcook-dsl/u51-weex" target="_blank" rel="external">https://github.com/imgcook-dsl/u51-weex</a></p>
<p>具体的使用方式可以参考官方文档：<a href="https://imgcook.taobao.org/docs?slug=dsl-dev" target="_blank" rel="external">https://imgcook.taobao.org/docs?slug=dsl-dev</a></p>
<p>理论上来说可以对任意平台的布局进行拓展。</p>
<p>这块也在团队内部做了一些推广，整体上来说可以提高UI方面的开发效率，当然也存在着一些问题，这里就不具体展开了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整体来讲imgcook是一个基本可用的布局代码生成平台，对于提升工作效率方面有一些帮助。</p>
<p>同时，对于拓展平台支持的兼容性也比较不错。</p>
<p>虽然对于页面级别也可以生成，但是对于代码层级关系、后期代码维护上都不太建议直接上页面级别；比较建议的方式是生成卡片item的布局，导出作为一个component使用。 </p>
<p>最后希望更多开发者可以使用imgcook，提出一些建议，使得他们团队可以进行更多的优化。</p>
<p>这篇文章写的时间比较久，当文章发布的时候发现imgcook平台又新添加了<a href="https://imgcook.taobao.org/labs" target="_blank" rel="external">Lab</a>，期待更多有意思的产品。</p>
<p>本文链接： <a href="http://w4lle.com/2019/04/08/UI2Code-2/">http://w4lle.com/2019/04/08/UI2Code-2/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;imgcook是阿里实现的基于sketch或Ps设计稿，自动生成布局代码的工具，支持生成支持flexbox布局的代码，包括JARVIS、Vue、微信小程序、React、H5、Rax等等。由两部分组成，一个是sketch(Ps)插件，另外一部分是&lt;a href=&quot;https://imgcook.taobao.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;imgcook平台&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://w4lle.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>UI2Code（二）pixeltoapp</title>
    <link href="http://w4lle.com/2019/03/22/UI2Code-1/"/>
    <id>http://w4lle.com/2019/03/22/UI2Code-1/</id>
    <published>2019-03-22T09:36:57.000Z</published>
    <updated>2019-11-24T02:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://pixeltoapp.com/" target="_blank" rel="external">pixeltoapp</a> 是一个通过传统图像处理把屏幕截图转换为 Android 代码的项目，使用python实现，提供在线服务，具体实现在<a href="https://github.com/soumikmohianuta/pixtoapp" target="_blank" rel="external">项目源码地址</a></p>
<a id="more"></a>
<p>系列文章：</p>
<ul>
<li><a href="http://w4lle.com/2019/03/13/UI2Code-0/">UI2Code（一）pix2code</a></li>
<li><a href="http://w4lle.com/2019/03/22/UI2Code-1/">UI2Code（二）pixeltoapp</a></li>
<li><a href="http://w4lle.com/2019/04/08/UI2Code-2/">UI2Code（三）imgcook</a></li>
</ul>
<h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1bjfidsnoj30ku1940wr.jpg" alt="原图"> </p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1bjglum9yj30ly118wgz.jpg" alt="代码渲染图"> </p>
<p>生成的布局代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div></pre></td><td class="code"><pre><div class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">             android:layout_width=&quot;250.0dip&quot;</div><div class="line">             android:layout_height=&quot;541.3333333333334dip&quot;</div><div class="line">             android:layout_gravity=&quot;center_vertical|center_horizontal&quot;</div><div class="line">             android:background=&quot;@color/color_0&quot;&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/ImageView_0&quot;</div><div class="line">        android:layout_width=&quot;10.333333333333334dip&quot;</div><div class="line">        android:layout_height=&quot;10.333333333333334dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;74.33333333333333dip&quot;</div><div class="line">        android:layout_marginTop=&quot;499.3333333333333dip&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;</div><div class="line">        android:src=&quot;@drawable/img_0&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/ImageView_1&quot;</div><div class="line">        android:layout_width=&quot;10.333333333333334dip&quot;</div><div class="line">        android:layout_height=&quot;10.0dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;41.333333333333336dip&quot;</div><div class="line">        android:layout_marginTop=&quot;499.3333333333333dip&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;</div><div class="line">        android:src=&quot;@drawable/img_2&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/ImageView_2&quot;</div><div class="line">        android:layout_width=&quot;31.666666666666668dip&quot;</div><div class="line">        android:layout_height=&quot;18.0dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;198.0dip&quot;</div><div class="line">        android:layout_marginTop=&quot;491.3333333333333dip&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;</div><div class="line">        android:src=&quot;@drawable/img_5&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/ImageView_3&quot;</div><div class="line">        android:layout_width=&quot;10.333333333333334dip&quot;</div><div class="line">        android:layout_height=&quot;10.333333333333334dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;52.666666666666664dip&quot;</div><div class="line">        android:layout_marginTop=&quot;499.0dip&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;</div><div class="line">        android:src=&quot;@drawable/img_6&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/ImageView_4&quot;</div><div class="line">        android:layout_width=&quot;9.333333333333334dip&quot;</div><div class="line">        android:layout_height=&quot;11.0dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;188.0dip&quot;</div><div class="line">        android:layout_marginTop=&quot;498.6666666666667dip&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;</div><div class="line">        android:src=&quot;@drawable/img_7&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/ImageView_5&quot;</div><div class="line">        android:layout_width=&quot;10.666666666666666dip&quot;</div><div class="line">        android:layout_height=&quot;11.0dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;176.33333333333334dip&quot;</div><div class="line">        android:layout_marginTop=&quot;498.6666666666667dip&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;</div><div class="line">        android:src=&quot;@drawable/img_8&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/ImageView_6&quot;</div><div class="line">        android:layout_width=&quot;10.666666666666666dip&quot;</div><div class="line">        android:layout_height=&quot;10.666666666666666dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;165.33333333333334dip&quot;</div><div class="line">        android:layout_marginTop=&quot;498.6666666666667dip&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;</div><div class="line">        android:src=&quot;@drawable/img_9&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/ImageView_7&quot;</div><div class="line">        android:layout_width=&quot;1.6666666666666667dip&quot;</div><div class="line">        android:layout_height=&quot;14.666666666666666dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;124.33333333333333dip&quot;</div><div class="line">        android:layout_marginTop=&quot;496.6666666666667dip&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;</div><div class="line">        android:src=&quot;@drawable/img_10&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/ImageView_8&quot;</div><div class="line">        android:layout_width=&quot;250.0dip&quot;</div><div class="line">        android:layout_height=&quot;1.6666666666666667dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;0.0dip&quot;</div><div class="line">        android:layout_marginTop=&quot;489.0dip&quot;</div><div class="line">        android:scaleType=&quot;fitXY&quot;</div><div class="line">        android:src=&quot;@drawable/img_11&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;FrameLayout</div><div class="line">        android:id=&quot;@+id/FrameLayout_9&quot;</div><div class="line">        android:layout_width=&quot;229.66666666666666dip&quot;</div><div class="line">        android:layout_height=&quot;101.0dip&quot;</div><div class="line">        android:layout_marginLeft=&quot;10.0dip&quot;</div><div class="line">        android:layout_marginTop=&quot;383.3333333333333dip&quot;</div><div class="line">        android:background=&quot;@color/color_0&quot;&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_9&quot;</div><div class="line">            android:layout_width=&quot;22.0dip&quot;</div><div class="line">            android:layout_height=&quot;7.666666666666667dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;70.0dip&quot;</div><div class="line">            android:layout_marginTop=&quot;78.33333333333333dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_12&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_10&quot;</div><div class="line">            android:layout_width=&quot;22.0dip&quot;</div><div class="line">            android:layout_height=&quot;7.666666666666667dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;48.0dip&quot;</div><div class="line">            android:layout_marginTop=&quot;78.33333333333333dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_13&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_11&quot;</div><div class="line">            android:layout_width=&quot;7.0dip&quot;</div><div class="line">            android:layout_height=&quot;7.333333333333333dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;40.666666666666664dip&quot;</div><div class="line">            android:layout_marginTop=&quot;78.33333333333333dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_14&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_12&quot;</div><div class="line">            android:layout_width=&quot;14.666666666666666dip&quot;</div><div class="line">            android:layout_height=&quot;7.333333333333333dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;26.0dip&quot;</div><div class="line">            android:layout_marginTop=&quot;78.33333333333333dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_15&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_13&quot;</div><div class="line">            android:layout_width=&quot;14.666666666666666dip&quot;</div><div class="line">            android:layout_height=&quot;7.666666666666667dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;11.333333333333334dip&quot;</div><div class="line">            android:layout_marginTop=&quot;78.33333333333333dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_16&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_14&quot;</div><div class="line">            android:layout_width=&quot;44.666666666666664dip&quot;</div><div class="line">            android:layout_height=&quot;20.0dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;174.33333333333334dip&quot;</div><div class="line">            android:layout_marginTop=&quot;72.0dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_18&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_15&quot;</div><div class="line">            android:layout_width=&quot;49.0dip&quot;</div><div class="line">            android:layout_height=&quot;8.333333333333334dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;24.333333333333332dip&quot;</div><div class="line">            android:layout_marginTop=&quot;40.333333333333336dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_21&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_16&quot;</div><div class="line">            android:layout_width=&quot;12.333333333333334dip&quot;</div><div class="line">            android:layout_height=&quot;7.0dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;11.666666666666666dip&quot;</div><div class="line">            android:layout_marginTop=&quot;41.0dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_22&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_17&quot;</div><div class="line">            android:layout_width=&quot;8.666666666666666dip&quot;</div><div class="line">            android:layout_height=&quot;8.0dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;210.33333333333334dip&quot;</div><div class="line">            android:layout_marginTop=&quot;40.666666666666664dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_23&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_18&quot;</div><div class="line">            android:layout_width=&quot;24.0dip&quot;</div><div class="line">            android:layout_height=&quot;8.333333333333334dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;184.0dip&quot;</div><div class="line">            android:layout_marginTop=&quot;40.333333333333336dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_24&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_19&quot;</div><div class="line">            android:layout_width=&quot;8.0dip&quot;</div><div class="line">            android:layout_height=&quot;5.666666666666667dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;210.66666666666666dip&quot;</div><div class="line">            android:layout_marginTop=&quot;29.0dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_25&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_20&quot;</div><div class="line">            android:layout_width=&quot;37.333333333333336dip&quot;</div><div class="line">            android:layout_height=&quot;9.333333333333334dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;49.0dip&quot;</div><div class="line">            android:layout_marginTop=&quot;25.333333333333332dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_26&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_21&quot;</div><div class="line">            android:layout_width=&quot;37.333333333333336dip&quot;</div><div class="line">            android:layout_height=&quot;9.333333333333334dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;11.333333333333334dip&quot;</div><div class="line">            android:layout_marginTop=&quot;25.333333333333332dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_27&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_22&quot;</div><div class="line">            android:layout_width=&quot;7.666666666666667dip&quot;</div><div class="line">            android:layout_height=&quot;12.666666666666666dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;200.0dip&quot;</div><div class="line">            android:layout_marginTop=&quot;22.0dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_28&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;ImageView</div><div class="line">            android:id=&quot;@+id/ImageView_23&quot;</div><div class="line">            android:layout_width=&quot;4.333333333333333dip&quot;</div><div class="line">            android:layout_height=&quot;12.333333333333334dip&quot;</div><div class="line">            android:layout_marginLeft=&quot;193.33333333333334dip&quot;</div><div class="line">            android:layout_marginTop=&quot;22.0dip&quot;</div><div class="line">            android:scaleType=&quot;fitXY&quot;</div><div class="line">            android:src=&quot;@drawable/img_29&quot;/&gt;</div><div class="line">    &lt;/FrameLayout&gt;</div><div class="line">    ...</div></pre></td></tr></table></figure>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1bmgzbb4rj31o90u00z4.jpg" alt=""> </p>
<p>整体处理过程： </p>
<p>原图 -&gt; 灰度处理 - 降噪 - 边缘探测，提取边缘轮廓 - 膨胀处理 - 框选边缘轮廓 - 遍历轮廓构建ViewTree - 删除重复元素，合并Layout布局，梳理ViewTree - 判断控件类型，目前支持Text和Image - 切割图像、文本识别，绑定控件属性 - 构建XML布局 </p>
<p>整体分为三个大的过程：背景分析、前景分析和布局构建 </p>
<p>- 背景分析：通过机器视觉算法，得到图像轮廓 </p>
<p>- 前景分析：对轮廓碎片进行整理，合并，识别 </p>
<p>- 布局构建：基于以上信息构建布局 </p>
<p>下面依次看下 </p>
<h2 id="背景分析"><a href="#背景分析" class="headerlink" title="背景分析"></a>背景分析</h2><p>包含 灰度处理、降噪、边缘探测、膨胀处理、框选边缘轮廓等几个步骤 </p>
<h3 id="灰度处理"><a href="#灰度处理" class="headerlink" title="灰度处理"></a>灰度处理</h3><p>二值化处理，作用是得到相对干净的背景底色 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">img_gray = cv2.cvtColor(img_color, cv2.COLOR_BGR2GRAY)</div></pre></td></tr></table></figure>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1bkowh846j30ku194q53.jpg" alt=""> </p>
<h3 id="降噪"><a href="#降噪" class="headerlink" title="降噪"></a>降噪</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cv2.fastNlMeansDenoising(img_gray)</div></pre></td></tr></table></figure>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1bkraa5qfj30ku194jtm.jpg" alt=""> </p>
<h3 id="边缘探测"><a href="#边缘探测" class="headerlink" title="边缘探测"></a>边缘探测</h3><p>使用Canny进行边缘探测，Canny算子是一种经典的边缘检测算子，它能得到精确的边缘位置。</p>
<p>Canny检测的一般步骤为：</p>
<ol>
<li>用高斯滤波进行降噪</li>
<li>用一阶偏导的有限差分计算梯度的幅值和方向 </li>
<li>对梯度幅值进行非极大值抑制</li>
<li>用双阈值检测和连接边缘。实验过程中，需要多次尝试选择较好的双阈值参数。 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cv2.Canny(imgData,self.lowThreshold,self.highThreshold)</div></pre></td></tr></table></figure>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1bksbdqhgj30ku194dgj.jpg" alt=""> #20-40 </p>
<h3 id="形态学膨胀"><a href="#形态学膨胀" class="headerlink" title="形态学膨胀"></a>形态学膨胀</h3><p>检测出来的边缘在某些局部地方会断开，可以采用特定形状和尺寸的结构元素对二值化图像进行形态学膨胀处理来连接断开的边缘。 </p>
<p>使用大小为(3，3)的十字线进行膨胀处理 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ratio =<span class="number">2</span>; </div><div class="line"></div><div class="line">kernel = np.ones((<span class="number">2</span> * dilationSize + <span class="number">1</span>, <span class="number">2</span> * dilationSize + <span class="number">1</span>), np.uint8) </div><div class="line"></div><div class="line">img_dilation = cv2.dilate(imgData, kernel, iterations=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1bkvi7ng4j30ku194t9b.jpg" alt=""> </p>
<h3 id="框选轮廓"><a href="#框选轮廓" class="headerlink" title="框选轮廓"></a>框选轮廓</h3><p>为了直观的看到轮廓形状，我们用红色把轮廓框起来，其中可以看到很多相同控件内的文字并没有联通，所以上一步的膨胀处理的参数仍然有调整空间 </p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1bkz5o1mbj30ku194jyb.jpg" alt=""> </p>
<p>背景分析基本就这些，下面看前景分析。</p>
<h2 id="前景分析"><a href="#前景分析" class="headerlink" title="前景分析"></a>前景分析</h2><p>前景分析包括对轮廓碎片进行整理并构建ViewTree、ViewTree优化合并、控件识别。</p>
<h3 id="构建ViewTree"><a href="#构建ViewTree" class="headerlink" title="构建ViewTree"></a>构建ViewTree</h3><p>得到轮廓参数后遍历操作，contours自带层级关系，按照该层级关系依次递归遍历，得到粗糙的ViewTree </p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1bl2vf5naj31lm0u0gv0.jpg" alt=""> </p>
<h3 id="ViewTree优化"><a href="#ViewTree优化" class="headerlink" title="ViewTree优化"></a>ViewTree优化</h3><p>包括如下几个方面：</p>
<ul>
<li>删除重叠区域view </li>
<li>合理划分父子关系 </li>
<li>合并无意义的Layout控件 </li>
</ul>
<h3 id="控件识别"><a href="#控件识别" class="headerlink" title="控件识别"></a>控件识别</h3><p>到这一步就得到了每一个View的坐标属性及轮廓属性了，根据这些数据进行抠图并识别控件类型，<strong>这里只支持两种控件</strong>：TextView 和 ImageView，但是生成的代码只包含ImageView，猜测是因为OCR识别中文有问题，所以控件类型识别错误导致。 </p>
<ul>
<li><p>控件识别 </p>
</li>
<li><p>属性提取，图像、文字、颜色 </p>
</li>
</ul>
<p>这里作者还提供了ListView的实现，但是应该不是完整的，所以被注释掉了。</p>
<p>到这一步，根据上面的工作，就可以得到整个ViewTree的描述信息了，相当于得到了布局的DSL，但是这里并没有输出DSL，仅仅是在内存中数据结构的表现。</p>
<h1 id="布局构建"><a href="#布局构建" class="headerlink" title="布局构建"></a>布局构建</h1><p>背景分析和前景分析都做完之后，就可以根据以上信息进行布局生成工作 ：</p>
<ul>
<li><p>根布局是FrameLayout </p>
</li>
<li><p>子布局有两种FrameLayout和RelativeLayout </p>
</li>
<li><p>控件都是相对父布局的绝对布局，layout_marginLeft，layout_marginTop </p>
</li>
<li><p>代码中看 RelativeLayout 中有相对布局，不过看生成的代码没有看到 </p>
</li>
</ul>
<p>这一步处理之后就可以得到布局代码了，生成布局代码后，这里也有一个compile的过程，根据提供的template工程，将布局代码带入，就可以得到可以运行的Android工程了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于设计稿是iOS，宽度750px的设计稿，所以出来的布局代码在Android上是没有适配的，不过这个关系都不大。 </p>
<p>这个项目提供了通过传统的机器视觉图像算法生成布局的思路。但是也存在一些问题： </p>
<ul>
<li>对于复杂界面处理能力有限</li>
<li>传统图像处理的方式，对于不同场景阈值可能需要频繁的调整，典型的如膨胀参数</li>
<li>泛化能力较弱，支持控件类型太少，并且识别准确率确实不行</li>
<li>布局能力有限，基本都是绝对坐标，布局比较死板 </li>
</ul>
<p>现在回过头来翻看闲鱼关于<a href="https://www.jiqizhixin.com/articles/2019-02-27-14" target="_blank" rel="external">版面分析的文章</a>，其中的主要流程跟pixtoapp基本一致，并且一些参数都是一样的，比如膨胀参数，猜测闲鱼团队应该也是参考过这个项目，并在这基础上做了一些优化。 </p>
<p>结合pix2code项目，pixtoapp进行版面分析，切割控件、得到布局，pix2code使用ML进行控件识别，最后进行组装，得到一个完整的布局，这种思路是可行的，猜测闲鱼也是基于这样的思路来做的。 </p>
<p>这种方案其中的一个最重要的点，也是最难的点，就是布局能力太弱，闲鱼文中提到的布局方式也是规则实现，那么就是类似pixtoapp中的实现方式，但是有一点不同的是，切割方式不同，所以闲鱼有row和col，而pixtoapp没有，RNN前置反馈这个还没有了解到，后面再看下。 </p>
<blockquote>
<p>前期我们采用4层LSTM网络进行训练学习，由于样本量比较小，我们改为规则实现。规则实现也比较简单，我们在第一步切图时5刀切割的顺序就是row和col。缺点是布局比较死板，需要结合RNN进行前置反馈。 </p>
</blockquote>
<p>通过两篇文章的分析，UI2Code的大体思路是通了的，但是核心点构建布局还没有很好的解决方案，还需要再详细思考下实现方案。 </p>
<p>参考 ：</p>
<p><a href="https://www.jiqizhixin.com/articles/2018-12-29-5" target="_blank" rel="external">基于AI的移动端自动化测试框架的设计</a> </p>
<p><a href="https://www.jiqizhixin.com/articles/2019-02-27-14" target="_blank" rel="external">UI2Code智能生成Flutter代码——版面分析篇</a></p>
<p>本文链接： <a href="http://w4lle.com/2019/03/22/UI2Code-1/">http://w4lle.com/2019/03/22/UI2Code-1/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://pixeltoapp.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pixeltoapp&lt;/a&gt; 是一个通过传统图像处理把屏幕截图转换为 Android 代码的项目，使用python实现，提供在线服务，具体实现在&lt;a href=&quot;https://github.com/soumikmohianuta/pixtoapp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;项目源码地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://w4lle.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>UI2Code（一）pix2code</title>
    <link href="http://w4lle.com/2019/03/13/UI2Code-0/"/>
    <id>http://w4lle.com/2019/03/13/UI2Code-0/</id>
    <published>2019-03-13T08:27:22.000Z</published>
    <updated>2019-11-24T02:57:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>pix2code 项目通过机器学习，支持输入一张图片输出实际的布局代码，同时支持生成三端(Android、iOS、web)布局代码。</p>
<p>pix2code作为UI2Code的先驱项目，后续的相关项目或多或少的都有参考该项目的实现。</p>
<a id="more"></a>
<p>系列文章：</p>
<ul>
<li><a href="http://w4lle.com/2019/03/13/UI2Code-0/">UI2Code（一）pix2code</a></li>
<li><a href="http://w4lle.com/2019/03/22/UI2Code-1/">UI2Code（二）pixeltoapp</a></li>
<li><a href="http://w4lle.com/2019/04/08/UI2Code-2/">UI2Code（三）imgcook</a></li>
</ul>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="https://github.com/tonybeltramelli/pix2code" target="_blank" rel="external">项目地址</a><br><a href="https://arxiv.org/abs/1705.07962" target="_blank" rel="external">论文地址</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650728064&amp;idx=1&amp;sn=adb744e599299916faa23545c2ab436e&amp;chksm=871b22feb06cabe83ba0e3268a7a8c0c486cf6f42427ab41814e69242f919b25bc7de06ea258&amp;scene=21#wechat_redirect" target="_blank" rel="external">论文翻译</a></p>
<p>使用双显卡服务器跑出模型，耗时大概1.5小时，模型数量1500张图片，1500个对应DSL，模型大小450M左右</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20191115164209.png" alt=""></p>
<p>然后使用验证集生成DSL，比对原始DSL</p>
<p>对比1：</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images03BC80FA-5959-4432-9622-19958492D0E7.png" alt=""></p>
<p>对比2：</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images61B2D439-EC8E-4574-8BB9-D7D427B1BDF0.png" alt=""></p>
<p>对比3：</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images77658E09-48B9-489D-B69A-69C6DB57AD75.png" alt=""></p>
<p>验证集共生成了250张图片对应的DSL，总体来看不能做到100%还原DSL，作者称可以做到77%左右的准确率。</p>
<p>以其中一个图片为例</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/imagesCD7F3D19-3D1B-4070-833C-54AE57B6AC9E.png" alt=""></p>
<p>生成的DSL </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">stack&#123; </div><div class="line"></div><div class="line">  row&#123; </div><div class="line"></div><div class="line">    label,slider,label </div><div class="line"></div><div class="line">  &#125; </div><div class="line">&#125; </div><div class="line"></div><div class="line">footer&#123; </div><div class="line"></div><div class="line">	btn-search,btn-search,btn-search,btn-search </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译compile后生成的Android xml 布局文件</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images7B1049AC-A185-4F64-945D-32CDB2EF7C57.png" alt=""></p>
<p>结果是有10个控件，其中的8个是正确的，2个是识别错误的。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>基于图像标记（image caption）构建一种把图像和文本连接在一起的模型，用于生成源图像内容的描述。 </p>
<p>pix2code是一个基于卷及神经网络(CNN)和循环神经网络(LSTM，长短时神经单元)能够由单个GUI屏幕截图生成源代码的项目。 </p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images20191115163604.png" alt=""></p>
<p>模型采用监督学习，有连个输入，一个数GUI截图，另外一个是对应的布局DSL。这些布局文件都足够简单，DSL也仅仅对控件进行了描述，不涉及位置信息和控件属性。<br>首先将GUI图像 I 通过CNN网络生成特征向量P，然后DSL 符号T 描述切割成一个序列 X（xt, t ∈ {0 . . . T − 1}）通过第一个语言模型得到特征向量qt（该语言模型由两个 LSTM 层、每层带有128个神经单元来实现），视觉编码向量 p 和语言编码向量 qt 可以级联为单一向量 rt，该级联向量 rt 随后可以投送到基于 LSTM 的模型来解码。因此解码器就学到了输入 GUI 图像中的对象和 DSL 代码中的符号间的关系，因此也就可以对这一关系进行建模。我们的解码器由两个 LSTM 层、每层带有 512 个单元的堆栈而实现。最后通过一个softmax进行一个分类对当前项进行预测，并把结果作为下一项的输入。</p>
<p>核心代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">image_model = Sequential()</div><div class="line">image_model.add(Conv2D(32, (3, 3), padding=&apos;valid&apos;, activation=&apos;relu&apos;, input_shape=input_shape))</div><div class="line">image_model.add(Conv2D(32, (3, 3), padding=&apos;valid&apos;, activation=&apos;relu&apos;))</div><div class="line">image_model.add(MaxPooling2D(pool_size=(2, 2)))</div><div class="line">image_model.add(Dropout(0.25))</div><div class="line"></div><div class="line">image_model.add(Conv2D(64, (3, 3), padding=&apos;valid&apos;, activation=&apos;relu&apos;))</div><div class="line">image_model.add(Conv2D(64, (3, 3), padding=&apos;valid&apos;, activation=&apos;relu&apos;))</div><div class="line">image_model.add(MaxPooling2D(pool_size=(2, 2)))</div><div class="line">image_model.add(Dropout(0.25))</div><div class="line"></div><div class="line">image_model.add(Conv2D(128, (3, 3), padding=&apos;valid&apos;, activation=&apos;relu&apos;))</div><div class="line">image_model.add(Conv2D(128, (3, 3), padding=&apos;valid&apos;, activation=&apos;relu&apos;))</div><div class="line">image_model.add(MaxPooling2D(pool_size=(2, 2)))</div><div class="line">image_model.add(Dropout(0.25))</div><div class="line"></div><div class="line">image_model.add(Flatten())</div><div class="line">image_model.add(Dense(1024, activation=&apos;relu&apos;))</div><div class="line">image_model.add(Dropout(0.3))</div><div class="line">image_model.add(Dense(1024, activation=&apos;relu&apos;))</div><div class="line">image_model.add(Dropout(0.3))</div><div class="line"></div><div class="line">image_model.add(RepeatVector(CONTEXT_LENGTH))</div><div class="line"></div><div class="line">visual_input = Input(shape=input_shape)</div><div class="line">encoded_image = image_model(visual_input)</div><div class="line"></div><div class="line">language_model = Sequential()</div><div class="line">language_model.add(LSTM(128, return_sequences=True, input_shape=(CONTEXT_LENGTH, output_size)))</div><div class="line">language_model.add(LSTM(128, return_sequences=True))</div><div class="line"></div><div class="line">textual_input = Input(shape=(CONTEXT_LENGTH, output_size))</div><div class="line">encoded_text = language_model(textual_input)</div><div class="line"></div><div class="line">decoder = concatenate([encoded_image, encoded_text])</div><div class="line"></div><div class="line">decoder = LSTM(512, return_sequences=True)(decoder)</div><div class="line">decoder = LSTM(512, return_sequences=False)(decoder)</div><div class="line">decoder = Dense(output_size, activation=&apos;softmax&apos;)(decoder)</div><div class="line"></div><div class="line">self.model = Model(inputs=[visual_input, textual_input], outputs=decoder)</div><div class="line"></div><div class="line">optimizer = RMSprop(lr=0.0001, clipvalue=1.0)</div><div class="line">self.model.compile(loss=&apos;categorical_crossentropy&apos;, optimizer=optimizer)</div></pre></td></tr></table></figure>
<p>具体原理参考<a href="https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650728064&amp;idx=1&amp;sn=adb744e599299916faa23545c2ab436e&amp;chksm=871b22feb06cabe83ba0e3268a7a8c0c486cf6f42427ab41814e69242f919b25bc7de06ea258&amp;scene=21#wechat_redirect" target="_blank" rel="external">论文翻译</a>。</p>
<p>生成 DSL 后，通过compiler编译成三端代码 UI -&gt; DSL -&gt; Code。</p>
<p>其中compile过程，就是替换DSL描述到实际控件的过程，这些实际控件的属性和布局位置信息全是写死的，存在放dsl-mapping文件中，以其中一个控件为例，对照关系如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;check&quot;: </div><div class="line">&quot;&lt;CheckBox android:id=\&quot;@+id/[ID]\&quot; </div><div class="line">	android:layout_width=\&quot;wrap_content\&quot; </div><div class="line">	android:layout_height=\&quot;wrap_content\&quot; </div><div class="line">	android:paddingRight=\&quot;10dp\&quot; </div><div class="line">	android:text=\&quot;[TEXT]\&quot;/&gt;&quot;,</div></pre></td></tr></table></figure>
<p>所以pix2code的核心是通过机器学习得到对应布局的DSL，compiler 是规则替换的过程。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>pix2code具有70%左右的准确率， 基于该项目，西安交大通过一些优化使准确率进一步提高。</p>
<p><img src="https://raw.githubusercontent.com/w4lle/developnote/images/images4E51A20B-550F-4016-94FF-9C718DDA2B2F.png" alt=""></p>
<p>参考文章 <a href="https://www.jiqizhixin.com/articles/2018-11-05-12?from=synced&amp;keyword=pix2Code" target="_blank" rel="external">https://www.jiqizhixin.com/articles/2018-11-05-12?from=synced&amp;keyword=pix2Code</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>pix2code项目本身作为一个实验性质的项目，论证了GUI截图通过AI手段自动生成布局代码的可行性。 </p>
<p>但是由于其也存在一些问题： </p>
<ul>
<li>模型准确率不高，修改模型或者重新构建模型成本高 </li>
<li>中间过程不允许人工干预，其结果就是完整的DSL，人工干预是在DSL生成后 </li>
<li>训练素材标准成本高，这也是深度学习都会碰到的一个实际问题 </li>
<li>切割精准度不够，实际上它是以CNN网络提取图片特征，精准度不大达到像素级别的要求 </li>
<li>控件位置和属性信息缺失，不能准确还原布局 </li>
</ul>
<p>基于以上调研分析，pix2code项目仅仅作为一个研究性项目进行开源，并不能实际使用在生产环境中，作者明确表述该项目和论文仅仅作为实验，并且不会再进行进一步的平台拓展。 </p>
<p>我们可以探索在pix2code基础上，通过图像分析+pix2code控件识别 来进行UI2Code的工作。 </p>
<p>后面会去调研下pixelToApp这个项目，其基于传统的计算机视觉识别技术进行代码生成。 </p>
<p>论文：</p>
<p><a href="https://cs.anu.edu.au/courses/CSPROJECTS/18S2/initialTalks/u6013787.pdf" target="_blank" rel="external">UI Design to Code Skeleton</a></p>
<p>参考文章：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650728064&amp;idx=1&amp;sn=adb744e599299916faa23545c2ab436e&amp;chksm=871b22feb06cabe83ba0e3268a7a8c0c486cf6f42427ab41814e69242f919b25bc7de06ea258&amp;scene=21#wechat_redirect" target="_blank" rel="external">深度学习助力前端开发：自动生成GUI图代码</a></li>
<li><a href="https://www.jiqizhixin.com/articles/2018-12-29-5" target="_blank" rel="external">基于AI的移动端自动化测试框架的设计</a> </li>
<li><a href="https://www.jiqizhixin.com/articles/2018-11-05-12?from=synced&amp;keyword=pix2Code" target="_blank" rel="external">前端设计图转代码，西安交大表示复杂界面也能一步步搞定</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIzNjc1NzUzMw==&amp;mid=2247496681&amp;idx=3&amp;sn=885b227400bdc8c81d74feffcb1b6c5c&amp;scene=0#wechat_redirect" target="_blank" rel="external">前端利器！让AI根据手绘原型生成HTML | 教程+代码</a></li>
<li><a href="https://medium.freecodecamp.org/how-you-can-train-an-ai-to-convert-your-design-mockups-into-html-and-css-cc7afd82fed4" target="_blank" rel="external">How you can train an AI to convert your design mockups into HTML and CSS</a></li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2019/03/13/UI2Code-0/">http://w4lle.com/2019/03/13/UI2Code-0/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pix2code 项目通过机器学习，支持输入一张图片输出实际的布局代码，同时支持生成三端(Android、iOS、web)布局代码。&lt;/p&gt;
&lt;p&gt;pix2code作为UI2Code的先驱项目，后续的相关项目或多或少的都有参考该项目的实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://w4lle.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>51信用卡 Android 架构演进实践</title>
    <link href="http://w4lle.com/2018/11/16/51credit-android-architecture/"/>
    <id>http://w4lle.com/2018/11/16/51credit-android-architecture/</id>
    <published>2018-11-16T03:24:10.000Z</published>
    <updated>2019-11-15T07:40:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着业务的快速扩张，原本小作坊式的单个工程的开发模式越来与不能满足实际需求。早在两年多以前，51信用卡管家就向下沉淀出了单独的公用基础库，一些通用的功能组件和个别独立的业务被拆分成 SDK，形成了一套中型项目、多人并行的开发模式，也为未来组件化拆分做准备。</p>
<a id="more"></a>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwi9479hnhj31g00uk49x.jpg" alt="image-20181023162224348"></p>
<p>这套框架运行了一段时间之后，伴随着单应用内业务需求的增加、开发人员数量的增多、基础库数量的膨胀，导致了一些问题：</p>
<ul>
<li>主工程代码耦合严重，牵一发而动全身</li>
<li>需求测试影响面大，不能聚焦单一业务模块</li>
<li>主工程代码越来越多，编译耗时</li>
<li>依赖倒置，业务代码依赖App工程</li>
<li>SDK 界限模糊，基础库和业务库界限不明确</li>
<li>业务模块间可以任意依赖调用，依赖规则不明确</li>
<li>类库越来越多，不好管理</li>
</ul>
<p>除了以上问题，动态化需求也越来越强烈，依赖 Hybrid + H5 打开页面慢的问题也凸显出来。</p>
<p>这些问题推动我们更进一步的升级开发构架。</p>
<h1 id="组件化-or-插件化"><a href="#组件化-or-插件化" class="headerlink" title="组件化 or 插件化"></a>组件化 or 插件化</h1><h2 id="动态化"><a href="#动态化" class="headerlink" title="动态化"></a>动态化</h2><p>最近两年，插件化框架层出不穷，各大厂都放出了自家开源的插件化框架。作为 Native 动态化与性能兼顾的插件化方案，很多公司选择插件化作为动态化技术方案。动态性通常有两部分的作用：一是动态热修复；二是动态下发业务插件。对于第一点，我们有热修复框架可以完成这部分工作；对于第二点，我们使用了 Hybrid 加载H5的方式实现，虽然性能上有所欠缺，但完全切到 Native 来做有点推倒重来的意思，并且跟业界同学交流后，对于动态下发业务插件用到的情况也不多，业务更新主要还是依靠 App 升级来实现。技术方案没有最优解，选择适合自己的才是最好的。</p>
<p>由于插件化也存在一些弊端，比如不可避免的 hook framework、修改 aapt、包装 Gradle Plugin、代理组件等等非常规操作，日常维护也是一笔不小的开销，稳定性、兼容性、新版本适配等等问题都需要考虑进去。对于 Android 端是否使用插件化，公司内部做过一些讨论，结论是不急着上，边走边看，先把业务组件拆分出来再说。</p>
<p>如今回过头看，自从 Android P发布以来，限制 hook framework 后，插件化逐渐开始式微，后面走向大概率是维护成本越来越高，成本收益比逐渐降低，最终弃坑不用。</p>
<p>除了插件化外，动态化方案近两年比较火的就是以 ReactNative、Weex 为代表的大前端方向，结合51信用卡的实际情况，最终选择拥抱大前端， Weex 作为动态化方案，以 Native 为主， Hybrid 离线化方案为辅，Weex 逐步迭代的架构开发模式。</p>
<p>Weex 的基础建设和前端同学合作，历经大半年时间，目前已经稳定应用在51信用卡各个 App 上，Weex 作为动态化页面的首选方案，已经完成了线上数百个页面的开发需求。配合离线化方案，各项性能指标也都达到要求。</p>
<h2 id="组件分离"><a href="#组件分离" class="headerlink" title="组件分离"></a>组件分离</h2><p>代码解耦与代码隔离，最有效的方案是工程隔离。审视我们最初的方案，每个 SDK 对应单独的仓库，通过 maven 依赖，通过工程分离隔离代码，这种方案没有问题，只不过需要往前更近一步，各个业务模块也需要独立主工程，拆分成独立的业务组件。</p>
<p>同时，划分清楚代码边界，控制依赖关系，梳理清楚层次结构，最终形成如下图所示的架构。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwrpnjc8xdj31hc0u0gt5.jpg" alt="组件化层次.001"></p>
<p>整体架构上提供三种容器：</p>
<ul>
<li>Native 容器，采用组件化架构，用于原生业务开发</li>
<li>Hybrid 容器，webview 加载 H5，配合离线化方案</li>
<li>Weex 容器，用于编写常规的页面，js 动态转化成 Native 控件，天然具有动态化特性，配合离线化方案，达到页面秒开的效果，同时共用 Hybrid 沉淀出的比较完善的 PG 方法</li>
</ul>
<p>同时，Hybrid 和 Weex 依赖于原生提供的方法，通过 JsBridge 进行通信，目前共有 200 多个 PG 方法供 js 调用。长远来看，这三种容器并不会互相取代，相反地，它们应该是相互依存、取长补短、长期共存的状态。</p>
<h1 id="组件化实践"><a href="#组件化实践" class="headerlink" title="组件化实践"></a>组件化实践</h1><p>Native 容器对应上图中各个层级的定义：</p>
<ul>
<li>工程 App，各个应用工程，目前已有十多个应用并行开发，51信用卡管家作为平台应用，其余应用为独立的业务工程应用</li>
<li>业务组件，独立的业务组件，一般为复合业务组件，api 与实现分离，相互之间依赖隔离</li>
<li>基础业务 SDK，独立的小的单功能模块，提供基础功能，目前这一层级中还包含遗留未改造的部分业务组件</li>
<li>基础 Lib，业务无关的基础组件</li>
</ul>
<p>组件化拆分的核心诉求是解耦合，提高组件内聚，所以应该从诉求出发，在沿用当下开发模式，并且不强依赖组件化框架的情况下，逐渐的进行组件化拆分。</p>
<p>通过工程隔离进而进行组件化拆分后，基本可以解决上面提到的问题：</p>
<ul>
<li>高内聚，低耦合，代码边界清晰，代码变动影响面可以准确评估</li>
<li>提高开发效率，每个组件可以独立打包，单独调试，最多几十秒就可以完成打包过程</li>
<li>每个组件负责组件内的事情，理论上只要保证组件内部稳定，接入工程 App 后也不会产生新的问题</li>
<li>降低 App 工程编译时间，最理想的情况是，App 工程仅仅是一个空壳，用于加载各个组件</li>
</ul>
<p>解耦，一般需要避免直接依赖，转为间接依赖，简单来说就是依赖隔离。对于组件化而言，每个组件都是单独的实现，单个组件对外提供的服务尽可能单一，依赖尽可能少；同时，依赖其它组件功能或页面的情况下，尽可能避免直接依赖，最好依赖中间层进行集中式管理，然后再进行逻辑分发。所以我们一般采用分总分的结构：组件内部分别注册，编译时生成汇总代码、运行时集中式管理，调用时处理逻辑分发。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwrpngbj7qj30yy0i4di0.jpg" alt="image-20181026181156315"></p>
<p>组件化需要解耦处理的几个基础模块：</p>
<ul>
<li>页面路由</li>
<li>模块间调用</li>
<li>消息总线</li>
<li>数据总线</li>
</ul>
<p>下面依次介绍。</p>
<h2 id="页面路由"><a href="#页面路由" class="headerlink" title="页面路由"></a>页面路由</h2><p>路由分发本质上是把直接依赖引用转化为中心化管理分发的一个过程，由于组件化拆分后，各个业务组件间不存在直接的依赖关系，所以必然要有一个统一收集页面跳转规则进而再分发的过程。</p>
<p>51信用卡在 2017 年就在进行路由化实践，以应对后面进行的组件化拆分需求，并沉淀出一套自研的路由框架 U51OkDeepLink，它也采用分总分结构，主要原理是组件内注册路由，编译时在组件内生成独立的路由表，并用 AOP 在编译时做好所有组件内路由表汇总的工作，调用初始化方法时进行路由表汇总，页面跳转时再进行管理分发，其用法很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//组件内注册路由</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleService</span> </span>&#123;</div><div class="line">    <span class="meta">@Path</span>(<span class="string">"/main"</span>)</div><div class="line">    <span class="meta">@Activity</span>(MainActivity.class)</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startMainActivity</span><span class="params">(@Query(<span class="string">"key"</span>)</span> String key)</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//其余组件唤起页面</span></div><div class="line"><span class="keyword">new</span> DeepLinkClient(context).buildRequest(<span class="string">"old://app/main?key=value"</span>).addQuery(<span class="string">"key2"</span>, <span class="string">"2"</span>).start();</div></pre></td></tr></table></figure>
<p>并且支持强大的异步特性，支持跳转过程中的中间逻辑处理。</p>
<p>其原理图如下</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwrpnhjehsj31ju0uewka.jpg" alt="router"></p>
<p>感兴趣的读者可以阅读 <a href="https://www.jianshu.com/p/8a3eeeaf01e8" target="_blank" rel="external">Android 组件化 —— 路由设计最佳实践</a> 获取更多技术细节。</p>
<h2 id="模块间调用"><a href="#模块间调用" class="headerlink" title="模块间调用"></a>模块间调用</h2><p>组件间层次和边界模糊问题的产生，根本原因是各个业务组件间的相互依赖关系混乱，为了进行业务组件间的隔离，首先要做好组件之间的服务调用解耦。</p>
<p>这里采用的是 ServiceLoader 的模式，组件工程目录一般如下所示</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwrpnfmr75j30bs052glm.jpg" alt="image-20181024204942179"></p>
<p>每个组件内一般声明三个 module：</p>
<ul>
<li>api module，声明对外暴露的服务接口和对外暴露的实体类及 Event 事件</li>
<li>imp module，依赖 api module，是 api module 的具体实现，不对外暴露细节，不允许其他组件对 imp module 进行直接依赖</li>
<li>app module，是工程的壳，可以直接运行调试，通过 SDKTemplate 创建生成，包含各种运行时所需环境</li>
</ul>
<p>业务组件之间依赖 api 库的服务接口，imp 库作为实现动态查找。版本发布时，同时发布 api 和 imp 两个库，并且保证 api 和 imp 具有相同版本号，这个在组件发版时统一管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//组件内 api module 接口声明</span></div><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestService</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//组件内 imp module 接口实现</span></div><div class="line"><span class="meta">@ServiceImpl</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//跨组件调用</span></div><div class="line">compile <span class="string">'com.u51.android:test-lib-api:$version'</span></div><div class="line"></div><div class="line">CommentService service = ServicesLoader.getInstance().getService(TestService.class);</div><div class="line">service.sayHello();</div></pre></td></tr></table></figure>
<p>它的实现原理与路由类似，也是采用分总分结构，在编译时通过 APT 生成汇总代码，调用时动态查找注入 Service 及其实现类的绑定关系。</p>
<p>与路由初始化汇总路由表不同的是，ServiceLoader 在调用时查找，省去了初始化的逻辑，Service 不会像路由这么多，查找起来不会存在遍历太慢的问题。</p>
<h2 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h2><p>消息总线是基于 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 实现的跨三端（Native、Hybrid、Weex）事件管理分发组件 U51EventBus。跨三端是指在任意一端注册监听后，在事件触发时都可以得到响应。</p>
<p>对于原生开发来说，EventBus 本身可以满足需求，虽然有点事件满天飞的缺点，但是还在可接受范围之内。对于业务组件来说，其 Event 类需要放在 api module 中进行暴露。</p>
<p>对于 Hybrid 和 Weex 来说，一般的 bridge 都是 callback 形式得到异步响应，对于全局事件通知支持不太友好。通过 bridge 通道连接 U51EventBus 消息总线，打通跨三端全局的事件监听及分发，得以实现任意事件可以在 Native、H5、Weex 之间相互发送和监听。比如，类似登陆、登出操作在 Native 发出后，全局已打开的 H5 或 Weex 页面可以立即得到感知。</p>
<p>其实现原理也是采用分总分结构，在编译时对 EventBus 进行了定制封装，事件分发还是使用的原有的 EventBus 分发逻辑。</p>
<h2 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h2><p>数据存储采用基于 <a href="https://developer.android.com/topic/libraries/architecture/room" target="_blank" rel="external">Room</a> 实现的统一 KV 存储框架，底层数据库依然是 sqlite，性能这块没有做特别强调，强制其在子线程中进行操作，用于支持日常开发中配置和业务数据的存取操作。</p>
<p>另外，数据总线支持按模块进行存取，每个业务组件都可以定义自有 tag，避免字段冲突问题。</p>
<h1 id="跨平台混合开发实践"><a href="#跨平台混合开发实践" class="headerlink" title="跨平台混合开发实践"></a>跨平台混合开发实践</h1><p>无论从早期的 PhoneGap、Cordova，还是近年来比较火的 ReactNative、Weex，到最近两年崛起的 Flutter，跨平台混合开发一直深受众多开发青睐。究其原因，还是其跨平台和动态化是原生开发所不具备的特性。</p>
<h2 id="Hybrid-容器实践"><a href="#Hybrid-容器实践" class="headerlink" title="Hybrid 容器实践"></a>Hybrid 容器实践</h2><p>Native 和 H5 混合开发一般是比较常见的混合开发模式，H5 开发效率高、迭代快速、不依赖 App 发版，51信用卡众多 App 产品中，有很多页面都是用 H5 来开发，嵌入原生 App 中使用 webview 进行加载显示。</p>
<p>早期 H5 容器在各个 App 中分别独立实现，没有统一的架构和规范，导致对 H5 的支持效率较低，PG 方法（来源于 PhoneGap）的开发、测试和维护都相当的混乱，重复性工作太多。</p>
<p>Native 层提供一套通用性强、功能丰富、稳定性高的 H5 容器对业务的高速发展至关重要。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwxgmjrohtj31kw0zkwth.jpg" alt="image-20181105173903973"></p>
<h3 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h3><p>由于 H5 不具备直接调用原生方法，所以原生壳要提供一套通用的通信方式，一般为 JsBridge，在 Android 端，实现 JsBridge 通信的通道一般有以下几种：</p>
<ul>
<li>shouldOverrideUrlLoading</li>
<li>addJavascriptInterface</li>
<li>onJsPrompt/onJsAlert</li>
</ul>
<p>而通道不是关键，怎样管理和维护 PG 方法调用才是核心。为此，我们把每个方法定义为一个 Plugin，用插件的形式管理 PG 方法，这样可以做到每个插件独立运行，互不干扰。插件管理也是采用分总分结构，在各个业务组件中分别注册，编译是通过 APT 生成汇总代码，运行时进行插件汇总，最后调用通过 PluginManager 查找分发逻辑。</p>
<p>插件注册代码如下，其中 <code>onExecute()</code> 方法在 js 调用该方法时触发，执行结果通过 <code>evaluateJavaScript()</code> 方法异步返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@JsPlugin</span>(name = TestPlugin.PLUGIN_NAME, loadOnInit = <span class="keyword">false</span>, version = <span class="number">1</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPlugin</span> <span class="keyword">extends</span> <span class="title">EnNiuJsPlugin</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PLUGIN_NAME = <span class="string">"TestPlugin"</span>;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPluginName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> PLUGIN_NAME;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onExecute</span><span class="params">(String args)</span> </span>&#123;</div><div class="line">        doSomething();                    </div><div class="line">        callbackContext.callback(...);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，H5 容器和插件都具有 Activity 生命周期感知能力，插件的生命周期：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwxgmhf6r9j31kw16eas1.jpg" alt="image-20181105191433330"></p>
<h3 id="配套设施"><a href="#配套设施" class="headerlink" title="配套设施"></a>配套设施</h3><p>插件统一通过插件管理平台进行维护管理，目前已有200+插件。PG 插件作为基础通用功能，采取集中式管理机制，任何人在新增、修改插件都需要进行相关负责人审核，以避免出现 Android、iOS 两端实现不统一，版本间实现不统一等问题。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwxgmi1nm7j31kw0ebdl6.jpg" alt="image-20181105191949792"></p>
<p>插件调试通过调试平台进行操作，浏览器中打开调试地址，App 端通过调试工具扫码建立连接，即可进行插件调试。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwxgmiq9l1j31kw110thw.jpg" alt="image-20181105192429943"></p>
<h3 id="离线加载"><a href="#离线加载" class="headerlink" title="离线加载"></a>离线加载</h3><p>Hybrid 混合开发的一大劣势就是性能比较差，打开页面较慢，特别是在弱网情况下。由于51信用卡业务大部分都是静态资源请求，参考业界做法，我们实现了动态下发离线包的方式来提升H5页面打开速度。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwxgmkmdnlj31ca12wn45.jpg" alt="lixianbao"></p>
<p>这里细节问题不具体展开。</p>
<p>除了以上提到的实践外，我们还做了很多工作，比如 UI 统一、Back 键拦截、公共参数处理、PG 白名单机制、H5监控、PG 方法监控等等，限于文章篇幅，这里不再一一列出，敬请关注后续相关文章。</p>
<h2 id="Weex-容器实践"><a href="#Weex-容器实践" class="headerlink" title="Weex 容器实践"></a>Weex 容器实践</h2><p>在 Hybrid 已有配套基础上，51信用卡选择了 Weex 作为跨平台方案，经过一年的踩坑填坑过程，目前已经有 20+ 个项目、数百个 Weex 页面在线上稳定运行，并且，目前 Weex 方案趋于成熟，已经作为51信用卡端内首选业务方案。</p>
<h3 id="共享插件"><a href="#共享插件" class="headerlink" title="共享插件"></a>共享插件</h3><p>由于 Hybrid 良好的面向接口编程特性，在进行 Weex 基础建设过程中，很方便的就把已有的插件集成进来，并且共享已沉淀的配套设施。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ENBridgeModule</span> <span class="keyword">extends</span> <span class="title">WXModule</span> </span>&#123;</div><div class="line">    <span class="meta">@JSMethod</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String method, String args, JSCallback jsCallback)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        weexWebView = weexEngine.getWeexVirtualWebView();</div><div class="line">        EnNiuJsBridge enNiuJsBridge = weexWebView.getEnNiuJsBridge();</div><div class="line">        enNiuJsBridge.notify(pg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注册 Weex 的 Module，并且每个 Weex Engine 中会新建出一个虚拟 webview，用于桥接 JsBridge 进而调用 PluginManager 进行插件逻辑分发。</p>
<p>Weex 容器实践在之前的文章中已经提到过一部分，具体请看 <a href="https://mp.weixin.qq.com/s/PSquf5ILDykC9jYFu911qg" target="_blank" rel="external">Weex避坑指南-理论篇 </a>，后续还将有 Weex 实践相关的文章放出，这里不做过多篇幅的介绍，敬请关注后续相关文章。</p>
<h1 id="工程化实践"><a href="#工程化实践" class="headerlink" title="工程化实践"></a>工程化实践</h1><p>工程化本质上是为了提高研发效率。51信用卡客户端团队自研的大风车管理平台，用于 App 管理、持续集成、类库管理、发版管理等，围绕客户端研发上下游流程，建立统一的管理入口。</p>
<p>目前，51信用卡 iOS 和 Android 共 30 多个应用 App、 200 多个类库依托大风车平台进行管理。下面主要介绍下类库管理相关内容。</p>
<h2 id="类库管理"><a href="#类库管理" class="headerlink" title="类库管理"></a>类库管理</h2><p>51信用卡目前有 100 多个 Android 类库，每个类库对应一个独立的 Gitlab 仓库。过多的独立组件及独立仓库，管理起来有些麻烦。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwrpnk3uc9j31kw0scaj6.jpg" alt="image-20181030193630574"></p>
<p>依托于大风车平台，所有类库的名称、最新版本及标签类型都会展示在列表页，标签类型对应组件化架构的层次结构，包括：基础组件、单业务功能组件、多业务功能组件。</p>
<p>在类库详情页，会有库的功能描述、groupId:artifactId 依赖信息、版本历史记录、分支信息、README、CHANGELOG、负责人等详情信息。</p>
<p>所有的类库管理工作都可以在大风车完成，包括新建类库、类库发版、查阅相关信息等等，这大大提高了基础组的研发效率，降低了团队间的沟通成本。</p>
<p>并且 App 工程中，该 App 所依赖的所有类库信息一目了然，在多人维护、多类库并行开发、类库频繁发版的情况下，依赖类库信息 check 更加便捷。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwrpng2bwcj31kw1540z0.jpg" alt="image-20181031160854953"></p>
<h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p>由于类库之间是仓库隔离，所以它们的依赖关系是 maven 依赖，所有类库的 aar 包都需要发布到内部 maven 服务器上，上传工作由 PublishMavenPlugin 完成。</p>
<h3 id="SNAPSHOT-预览版"><a href="#SNAPSHOT-预览版" class="headerlink" title="SNAPSHOT 预览版"></a>SNAPSHOT 预览版</h3><p>对于开发调试阶段，每个类库自带 DemoApp 工程，所以采用源码依赖；开发完成后，类库使用<code>SNAPSHOT</code>版本（比如 1.0.0-SNAPSHOT）发布到 maven 服务器，接入 App 工程后 push 代码触发大风车打包，进行集成测试。需要修改类库时，可以再重复发布相同版本的<code>SNAPSHOT</code>版本。</p>
<p><code>SNAPSHOT</code>版本可以在开发同学自己的机器上进行打包发布。</p>
<h3 id="正式版"><a href="#正式版" class="headerlink" title="正式版"></a>正式版</h3><p>对于发布阶段，类库必须使用正式版本发布，由于正式版本不可重复发布，这也就要求开发同学保证每个正式版本的版本质量，在正式发布前都应达到发布标准。</p>
<p>由于类库内部也存在相互依赖的情况，所以在类库正式发布时，不允许依赖包含<code>SNAPSHOT</code>版本的类库，<code>DependencyCheck</code>工作也会在  PublishMavenPlugin 完成。</p>
<p>同时，正式版本不允许开发同学在本机打包发布，PublishMavenPlugin 会检测是否在云端打包环境。功能分支经 CodeReview 后合并 master 分支，然后创建对应版本的 tag，触发大风车进行打包发布工作，发布成功后，会邮件通知 Android 组同学，并附带 CHANGELOG。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwxgz042voj312q0qa44m.jpg" alt="image-20181105204154472"></p>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><p>App 工程下采用 compile 依赖，compile 会解析类库 maven 包中的 pom 文件，进而间接依赖 pom 文件中声明的其他类库，也就是依赖传递。正常情况下，依赖传递会减少不必要的类库声明，当出现版本冲突时会自动处理 merge 操作。</p>
<p>但是，在多人协同工作、多类库并行开发情况下，事情变得有些复杂。考虑一种情况，应用 A 依赖类库 B，类库 B 依赖类库 C，正常情况下，A 中只需要声明依赖 B 即可，C 会被依赖传递过去。如果 C 中改变了方法签名，并且在应用 A 中显示声明依赖 C，编译时和运行时会分别出现什么情况？在编译时没有问题，正常编译通过；在运行时，当运行到类库 B 中使用的类库 C 中被改变签名的方法时，App crash。这是因为，maven 在处理类库版本 merge 时，会将 C 升级到最高版本，而此时 B 中已经编译好的 class 中使用的还是老版本 C 中的方法。</p>
<p>为了处理这个问题，我们使用 APICheckGradlePlugin 在编译时进行 check 操作，当发现被调用的方法找不到时，主动报错，将错误提前暴露在编译期，而非在运行时。同时内部强调 API 接口的向下兼容性，不用的方法标记为废弃，而非直接修改其方法签名或删除方法。</p>
<p>APICheckGradlePlugin 核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    c.getClassPool().get(callClassName)</div><div class="line">    isClassNotFound = <span class="keyword">false</span></div><div class="line">    m.getMethod()</div><div class="line">&#125; <span class="keyword">catch</span> (NotFoundException e) &#123;</div><div class="line">    <span class="keyword">if</span> (isClassNotFound) &#123;</div><div class="line">        dealException(String.format(<span class="string">"在%s类中的第%d行是用到的%s类不存在"</span>, className, line, callClassName))</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dealException(String.format(<span class="string">"在%s类中的第%d行是用到的%s类的%s方法不存在"</span>, className, line, callClassName, methodName))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="多module发布"><a href="#多module发布" class="headerlink" title="多module发布"></a>多module发布</h3><p>上文中提到，在多业务组件库工程中会有多个 module，一个 api module，一个 imp module，在使用 DemoApp 编译调试时采用源码依赖， imp module 依赖 api module，App 依赖 imp module，这样在打包上传 maven 时，会出现无法一起上传的问题；并且我们也要确保 api 和 imp 的版本号一致。为了解决这个问题，需要在上传时动态修改他们的 pom 文件，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">modifyPom &#123; pom -&gt;</div><div class="line">    pom.dependencies.findAll &#123; dep -&gt; dep.groupId == rootProject.name &#125;.collect &#123; dep -&gt;</div><div class="line">        dep.groupId = pom.groupId = rootProject.groupId</div><div class="line">        dep.version = pom.version = rootProject.sdkVersion</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="一键创建项目"><a href="#一键创建项目" class="headerlink" title="一键创建项目"></a>一键创建项目</h2><h3 id="模板工程"><a href="#模板工程" class="headerlink" title="模板工程"></a>模板工程</h3><p>由于每个新建组件类库的 App 工程需要运行时环境基本相同，包括网络环境、调试环境、gradle 配置、通用依赖配置等等，这些重复性的工作最好放在一起统一处理。为此，我们创建了组件库的模板工程，只需要 clone 下来模板仓库，然后修改一些代码即可开发需求代码。</p>
<h3 id="一键创建类库"><a href="#一键创建类库" class="headerlink" title="一键创建类库"></a>一键创建类库</h3><p>但是，这种方式依然有很多共性的工作，比如 clone 代码、修改类库名、修改 groupId:artifactId、创建新的类库仓库、push 代码、在大风车中新建类库关联仓库地址等等操作。这些共性操作仍然可以用机器来操作，所以我们在大风车新建类库这一步中，把前面所有要做的事情全部做完，只需要在新建类库时填入必要的参数，一键就可以创建出可用的类库项目。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwrpngxyd4j31g40mqdht.jpg" alt="image-20181031201425732"></p>
<h3 id="一键创建应用"><a href="#一键创建应用" class="headerlink" title="一键创建应用"></a>一键创建应用</h3><p>随着我司 App 越来越多，新建 App 的配置同样面临类库刚开始时的困扰，新建 App 与新建类库本质上是一样的，只不过所需参数更多一些，并且这些参数可能不固定，有些 App 需要有些 App 不需要。参考类库，我们提取共性操作，创建了 App 的模板工程，并且对接大风车，一键即可创建出 App 工程，那些可变的参数留在模板工程中按需手动配置。</p>
<h2 id="模块负责人"><a href="#模块负责人" class="headerlink" title="模块负责人"></a>模块负责人</h2><p>在组件化初步开始时，我们的每个模块都有固定的负责人，每个人手上都有固定的若干个模块，责任人对自己负责的模块负责。</p>
<p>但是随着组内的人员变动和业务变动，导致一些模块频繁易主，一些模块的文档长期处于不被维护状态，README 和 CHANGELOG 常年失修。</p>
<p>依赖大风车的类库管理，重新为每个模块指定负责人，并且梳理现存类库哪些缺失文档，进行补全。自从大风车自动抄送类库发版 CHANGELOG 后，CHANGELOG 不全的情况也大幅改善，基本每个新的版本都会附上该版本所做修改。</p>
<p>同时，我们也强调 CodeReview 机制，每个模块在提测前进行 CodeReview，强制merge request 必须有人点赞后才能合并 master 分支等等代码审查机制。未来，我们可能会进一步实践负责人 backup 方案，主副负责人相互 review，扩大大家技术视野的同时，可以进一步提高大家的主人翁意识。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好的架构不是设计出来的，而是演进出来的。本文简单阐述了51信用卡 Android 架构演进的一些实践经验，同时我们坚信技术方案没有最优解，重要的是要选择选择适合自己的。脱离所处环境和问题本身谈技术方案，都将不能得到适合自身的开发架构。同时，我们也应当吸取和借鉴业界优秀的架构和设计理念，并将其根据自身适用场景加以改造，在理论和实践中逐渐交替探索演进。</p>
<p>当然，我们目前所使用的架构依然存在一些问题，比如组件拆分不完全、主工程业务仍然很多、CodeReview 机制不健全、代码扫描不够严格、一些组件库没有严格按照 api 工程来改造、一些老的组件依然没有 api module等等问题。我们也应该看到，正是因为这些实际的问题在推动我们进行技术改造，架构升级。同时，我们也要审视行业内大的方向，紧跟技术趋势，主动拥抱变化，毕竟技术世界唯一不变的，便是变化。</p>
<p>本文链接： <a href="http://w4lle.com/2018/11/16/51credit-android-architecture/">http://w4lle.com/2018/11/16/51credit-android-architecture/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着业务的快速扩张，原本小作坊式的单个工程的开发模式越来与不能满足实际需求。早在两年多以前，51信用卡管家就向下沉淀出了单独的公用基础库，一些通用的功能组件和个别独立的业务被拆分成 SDK，形成了一套中型项目、多人并行的开发模式，也为未来组件化拆分做准备。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android热补丁之Robust（三）坑和解</title>
    <link href="http://w4lle.com/2018/06/20/robust-2/"/>
    <id>http://w4lle.com/2018/06/20/robust-2/</id>
    <published>2018-06-20T08:18:16.000Z</published>
    <updated>2018-06-20T13:12:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前两篇文章中，分析了 Android 热补丁框架 Robust 中，几个重要的流程包括：</p>
<ul>
<li>补丁加载过程</li>
<li>基础包插桩过程</li>
<li>补丁包自动化生成过程</li>
</ul>
<p>本篇文章主要分析下集成过程中遇到的坑以及分析问题的思路和最终的解决方案。包含：</p>
<ul>
<li>打补丁包出错？</li>
<li>Robust 定义的 API 不够用怎么办？</li>
<li>插件 Plugin Transform 的顺序问题？</li>
<li>与 Aspectj 冲突怎么办？</li>
<li>static 方法中包含 super 方法怎么办？</li>
</ul>
<a id="more"></a>
<p>系列文章:</p>
<ul>
<li><a href="http://w4lle.com/2017/03/31/robust-0/">Android热补丁之Robust原理解析(一)</a></li>
<li><a href="http://w4lle.com/2018/05/28/robust-1/">Android热补丁之Robust（二）自动化补丁原理解析</a></li>
<li><a href="http://w4lle.com/2018/05/29/robust-2/">Android热补丁之Robust（三）坑和解</a></li>
</ul>
<h1 id="打补丁包出错？"><a href="#打补丁包出错？" class="headerlink" title="打补丁包出错？"></a>打补丁包出错？</h1><p>在打补丁包过程中，碰到了一个错误 <code>execute command java -jar /Users/wanglinglong/Develop/u51/Credit51/CreditCardManager/robust/dx.jar --dex --output=classes.dex  meituan.jar error</code>，找了一大圈最后发现是jdk老版本在Mac上的一个bug，升级jdk就好了，参考 <a href="https://stackoverflow.com/questions/43003012/class-javalaunchhelper-is-implemented-in-two-places?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa" target="_blank" rel="external">Class JavaLaunchHelper is implemented in two places</a></p>
<h1 id="Robust-定义的-API-不够用怎么办？"><a href="#Robust-定义的-API-不够用怎么办？" class="headerlink" title="Robust 定义的 API 不够用怎么办？"></a>Robust 定义的 API 不够用怎么办？</h1><p>Robust 提供了一些 API 可供开发者扩展使用，比如：<br>添加类库依赖 <code>compile &#39;com.meituan.robust:robust:0.4.82&#39;</code>，其中 <code>PatchManipulateImp</code> 类的一些可扩展方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> List&lt;Patch&gt; <span class="title">fetchPatchList</span><span class="params">(Context context)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">verifyPatch</span><span class="params">(Context context, Patch patch)</span></span>;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">ensurePatchExist</span><span class="params">(Patch patch)</span></span>;</div></pre></td></tr></table></figure>
<p>但是在一些情况下，这些可扩展方法并不能满足我们的需求。</p>
<p>为了满足定制化需求，可以弃用 <code>com.meituan.robust:robust</code>，自己实现一套补丁加载逻辑，这个实现起来难度并不太大，主要补丁加载流程都可以参考 Robust 官方实现，具体加载逻辑可参考本系列第一篇文章，这里不再深入。</p>
<h1 id="插件-Plugin-Transform-的顺序问题？"><a href="#插件-Plugin-Transform-的顺序问题？" class="headerlink" title="插件 Plugin Transform 的顺序问题？"></a>插件 Plugin Transform 的顺序问题？</h1><p>首先，要找到 Gradle Plugin 编译过程中对于自定义 Transform 的处理，具体流程读者可以自行搜索查看，这里只给出关键代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">TaskManager.java</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Creates the post-compilation tasks for the given Variant.</div><div class="line"> *</div><div class="line"> * These tasks create the dex file from the .class files, plus optional intermediary steps like</div><div class="line"> * proguard and jacoco</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPostCompilationTasks</span><span class="params">(</span></span></div><div class="line">        @NonNull <span class="keyword">final</span> VariantScope variantScope) &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// ---- Code Coverage first -----</span></div><div class="line">    ...</div><div class="line">    <span class="comment">// Merge Java Resources.</span></div><div class="line">    createMergeJavaResTransform(variantScope);</div><div class="line">    <span class="comment">// ----- External Transforms -----</span></div><div class="line">    <span class="comment">// apply all the external transforms.</span></div><div class="line">    List&lt;Transform&gt; customTransforms = extension.getTransforms();</div><div class="line">    List&lt;List&lt;Object&gt;&gt; customTransformsDependencies = extension.getTransformsDependencies();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = customTransforms.size(); i &lt; count; i++) &#123;</div><div class="line">        Transform transform = customTransforms.get(i);</div><div class="line">        List&lt;Object&gt; deps = customTransformsDependencies.get(i);</div><div class="line">        transformManager</div><div class="line">                .addTransform(taskFactory, variantScope, transform)</div><div class="line">                .ifPresent(</div><div class="line">                        t -&gt; &#123;</div><div class="line">                            <span class="keyword">if</span> (!deps.isEmpty()) &#123;</div><div class="line">                                t.dependsOn(deps);</div><div class="line">                            &#125;</div><div class="line">                            <span class="comment">// if the task is a no-op then we make assemble task depend on it.</span></div><div class="line">                            <span class="keyword">if</span> (transform.getScopes().isEmpty()) &#123;</div><div class="line">                                variantScope.getAssembleTask().dependsOn(t);</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在生成 Dex 任务之前，会处理所有的自定义 Transform 任务，逻辑是按照顺序遍历然后处理任务依赖关系，那么从dzhe’l这里我们可以知道，Transform 的执行顺序是按照插件的声明顺序来执行的，也就是说，哪个 plugin 的声明在前，其对应的 Transform 就在前执行，举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apply plugin: <span class="string">'pluginA'</span></div><div class="line">apply plugin: <span class="string">'pluginB'</span></div></pre></td></tr></table></figure>
<p>那么对应的 TransformA 任务就会先于 TransfromB 任务执行。</p>
<p>好了，知道了 Transform 的执行顺序问题，再来看下 Robust 插件的顺序问题。首先来看下基线包的处理插件 <code>apply plugin: &#39;robust&#39;</code>，其逻辑是在每个方法中前置插入补丁加载逻辑代码，用于拦截基线包中的原有逻辑，达到修复方法的目的。<br>如果 robust Plugin 是先于其他插件执行的，那么会出现 Robust 插入代码后，再执行其他插件的代码逻辑，这样会有问题吗？其实要具体问题具体分析，可能会有问题，也可能没有问题。举个例子，我们项目中使用了听云，而且是较老的版本(2.5.9)，其插件内部插入代码没有用到 Transform，而是用了另外一种技术，其会导致不管在哪里声明插件，其处理顺序都是最后执行，那么对于 Robust 基线包插件来说，当基线包插件插入完代码后，又会去执行听云插件的插入代码逻辑，所以可能会看到以下这种代码：</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/robust_tingyun.png" alt=""></p>
<p>实际上，我们最终想要的结果是这样的：</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/robust_tingyun_right.png" alt=""></p>
<p>然而，如果仔细观察这种错误的代码插入逻辑，实际上并没有对最终的热修复逻辑产生影响。是因为在生成补丁包过程中，他们的执行顺序也是这样的，即听云插件最后执行，这样的结果就是Robust 自动化补丁插件在生成插件后就强制停止了整个编译流程，听云插件根本就没有机会执行。所以最后补丁包中仅仅会包含剔除了Robust 基线包插件插入的代码以及听云插件插入的代码。可以理解为第一张图中把红框下面的代码通过热修复的方式移入了红框里面，然后return。</p>
<p>对于听云来说，2.8.x版本之后，插入代码的逻辑也由 Tranform 来执行，也就是说，对于听云来说，不管是怎么样的执行顺序，都不会与 Robust 发生兼容性问题。</p>
<p>所以还是要具体问题具体分析，这里仅仅提供一些排查问题的思路。</p>
<h1 id="与-Aspectj-冲突怎么办？"><a href="#与-Aspectj-冲突怎么办？" class="headerlink" title="与 Aspectj 冲突怎么办？"></a>与 Aspectj 冲突怎么办？</h1><p>我们项目中大量使用了 AOP 技术，涉及到的框架有 Aspectj、javassist、ASM。其中由于  javassist 和 ASM 完全是有自己控制的，所以不会有问题，而对于 Aspectj 来说就没这么简单了。</p>
<p>刚开始介入就碰到了这样一个问题 <code>Caused by: java.lang.ClassCastException: com.meituan.robust.patch.MainFragmentActivityPatch cannot be cast to com.zhangdan.app.activities.MainFragmentActivity</code>，是一个类型强转错误。</p>
<p>问题分析，由于 Aspectj 框架为开发者省略了很多逻辑，开发者只需要编写切面相关代码即可，所以需要梳理清楚 Aspectj 的原理：</p>
<p>首先贴下未混淆的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">MainFragmentActivity.class</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCreate_aroundBody2</span><span class="params">(MainFragmentActivity mainFragmentActivity, Bundle bundle, JoinPoint joinPoint)</span> </span>&#123;</div><div class="line">        onCreate_aroundBody1$advice(mainFragmentActivity, bundle, joinPoint, MainFragmentActivity$$Injector.aspectOf(), (ProceedingJoinPoint) joinPoint);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> onCreate_aroundBody1$advice(MainFragmentActivity mainFragmentActivity, Bundle bundle, JoinPoint joinPoint, MainFragmentActivity$$Injector mainFragmentActivity$$Injector, ProceedingJoinPoint proceedingJoinPoint) &#123;</div><div class="line">        <span class="keyword">if</span> (!PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;mainFragmentActivity, bundle, joinPoint, mainFragmentActivity$$Injector, proceedingJoinPoint&#125;, <span class="keyword">null</span>, changeQuickRedirect, <span class="keyword">true</span>, <span class="number">11888</span>, <span class="keyword">new</span> Class[]&#123;MainFragmentActivity.class, Bundle.class, JoinPoint.class, MainFragmentActivity$$Injector.class, ProceedingJoinPoint.class&#125;, Void.TYPE).isSupported) &#123;</div><div class="line">            MainFragmentActivity mainFragmentActivity2 = (MainFragmentActivity) proceedingJoinPoint.getTarget();</div><div class="line">            onCreate_aroundBody0(mainFragmentActivity, bundle, proceedingJoinPoint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;bundle&#125;, <span class="keyword">this</span>, changeQuickRedirect, <span class="keyword">false</span>, <span class="number">11849</span>, <span class="keyword">new</span> Class[]&#123;Bundle.class&#125;, Void.TYPE).isSupported) &#123;</div><div class="line">            JoinPoint makeJP = Factory.makeJP(ajc$tjp_0, <span class="keyword">this</span>, <span class="keyword">this</span>, bundle);</div><div class="line">            MainFragmentActivity$$Injector.aspectOf().onCreate(<span class="keyword">new</span> AjcClosure3(<span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>, bundle, makeJP&#125;).linkClosureAndJoinPoint(<span class="number">69648</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCreate_aroundBody0</span><span class="params">(MainFragmentActivity mainFragmentActivity, Bundle bundle, JoinPoint joinPoint)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;mainFragmentActivity, bundle, joinPoint&#125;, <span class="keyword">null</span>, changeQuickRedirect, <span class="keyword">true</span>, <span class="number">11887</span>, <span class="keyword">new</span> Class[]&#123;MainFragmentActivity.class, Bundle.class, JoinPoint.class&#125;, Void.TYPE).isSupported) &#123;</div><div class="line">            <span class="keyword">super</span>.onCreate(bundle);</div><div class="line">            JudgeEmulatorUtil.uploadEmulatorInfoIfNeed(mainFragmentActivity);</div><div class="line">            instance = mainFragmentActivity;</div><div class="line">            mainFragmentActivity.setContentView(R.layout.main_activity);</div><div class="line">            ButterKnife.bind((Activity) mainFragmentActivity);</div><div class="line">            mainFragmentActivity.initUserCenterManager();</div><div class="line">            mainFragmentActivity.mainPagerAdapter = <span class="keyword">new</span> MainPagerAdapter(mainFragmentActivity, mainFragmentActivity.getSupportFragmentManager());</div><div class="line">            mainFragmentActivity.userInfoPresenter = <span class="keyword">new</span> UserInfoPresenter();</div><div class="line">            mainFragmentActivity.refreshOldDataPresenter = <span class="keyword">new</span> RefreshOldDataPresenter();</div><div class="line">            mainFragmentActivity.tabRedPointPresenter = <span class="keyword">new</span> TabRedPointPresenter(mainFragmentActivity);</div><div class="line">            mainFragmentActivity.getMsgCenterRedPresenter = <span class="keyword">new</span> GetMsgCenterRedPresenter(mainFragmentActivity);</div><div class="line">            mainFragmentActivity.userInfoPresenter.setUserInfoView(mainFragmentActivity);</div><div class="line">            mainFragmentActivity.userInfoPresenter.startGetCurUserInfoDBUseCase();</div><div class="line">            INSTANCE_FLAG = <span class="number">1</span>;</div><div class="line">            BaiduLocation.getInstance(ZhangdanApplication.getInstance()).start();</div><div class="line">            mainFragmentActivity.initToolBar();</div><div class="line">            mainFragmentActivity.showImportBillDialog();</div><div class="line">            mainFragmentActivity.onLoginCreate(bundle);</div><div class="line">            mainFragmentActivity.getLoggerABConfig();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>对应的patch 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragmentActivityPatch</span> </span>&#123;</div><div class="line">    MainFragmentActivity originClass;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainFragmentActivityPatch</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.originClass = (MainFragmentActivity) obj;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        StaticPart staticPart = (StaticPart) EnhancedRobustUtils.getStaticFieldValue(<span class="string">"ajc$tjp_0"</span>, MainFragmentActivity.class);</div><div class="line">        Log.d(<span class="string">"robust"</span>, <span class="string">"get static  value is ajc$tjp_0     No:  1"</span>);</div><div class="line">        JoinPoint joinPoint = (JoinPoint) EnhancedRobustUtils.invokeReflectStaticMethod(<span class="string">"makeJP"</span>, Factory.class, getRealParameter(<span class="keyword">new</span> Object[]&#123;staticPart, <span class="keyword">this</span>, <span class="keyword">this</span>, savedInstanceState&#125;), <span class="keyword">new</span> Class[]&#123;StaticPart.class, Object.class, Object.class, Object.class&#125;);</div><div class="line">        Object obj = (Injector) EnhancedRobustUtils.invokeReflectStaticMethod(<span class="string">"aspectOf"</span>, Injector.class, getRealParameter(<span class="keyword">new</span> Object[<span class="number">0</span>]), <span class="keyword">null</span>);</div><div class="line">        Object[] objArr = <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>, savedInstanceState, joinPoint&#125;;</div><div class="line">        Log.d(<span class="string">"robust"</span>, <span class="string">"  inner Class new      No:  2"</span>);</div><div class="line">        Object obj2 = (AjcClosure3) EnhancedRobustUtils.invokeReflectConstruct(<span class="string">"com.zhangdan.app.activities.MainFragmentActivity$AjcClosure3"</span>, getRealParameter(<span class="keyword">new</span> Object[]&#123;objArr&#125;), <span class="keyword">new</span> Class[]&#123;Object[].class&#125;);</div><div class="line">        <span class="keyword">if</span> (obj2 == <span class="keyword">this</span>) &#123;</div><div class="line">            obj2 = ((MainFragmentActivityPatch) obj2).originClass;</div><div class="line">        &#125;</div><div class="line">        ProceedingJoinPoint proceedingJoinPoint = (ProceedingJoinPoint) EnhancedRobustUtils.invokeReflectMethod(<span class="string">"linkClosureAndJoinPoint"</span>, obj2, getRealParameter(<span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> Integer(<span class="number">69648</span>)&#125;), <span class="keyword">new</span> Class[]&#123;Integer.TYPE&#125;, AroundClosure.class);</div><div class="line">        Log.d(<span class="string">"robust"</span>, <span class="string">"invoke  method is       No:  3 linkClosureAndJoinPoint"</span>);</div><div class="line">        <span class="keyword">if</span> (obj == <span class="keyword">this</span>) &#123;</div><div class="line">            obj = ((MainFragmentActivityPatch) obj).originClass;</div><div class="line">        &#125;</div><div class="line">        EnhancedRobustUtils.invokeReflectMethod(<span class="string">"onCreate"</span>, obj, getRealParameter(<span class="keyword">new</span> Object[]&#123;proceedingJoinPoint&#125;), <span class="keyword">new</span> Class[]&#123;ProceedingJoinPoint.class&#125;, Injector.class);</div><div class="line">        Log.d(<span class="string">"robust"</span>, <span class="string">"invoke  method is       No:  4 onCreate"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们往下跟下 Aspectj 的调用流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">AjcClosure 类</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AroundClosure</span> </span>&#123;</div><div class="line">   ...</div><div class="line">    <span class="keyword">protected</span> Object[] state;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AroundClosure</span><span class="params">(Object[] state)</span> </span>&#123;</div><div class="line">    	<span class="keyword">this</span>.state = state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Object[] getState() &#123;</div><div class="line">      <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * This takes in the same arguments as are passed to the proceed</div><div class="line">	 * call in the around advice (with primitives coerced to Object types)</div><div class="line">	 */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">run</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ProceedingJoinPoint <span class="title">linkClosureAndJoinPoint</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">        <span class="comment">//TODO is this cast safe ?</span></div><div class="line">        ProceedingJoinPoint jp = (ProceedingJoinPoint)state[state.length-<span class="number">1</span>];</div><div class="line">        jp.set$AroundClosure(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">this</span>.bitflags = flags;</div><div class="line">        <span class="keyword">return</span> jp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AjcClosure 接收一个 Object 的对象数组，在基础包中，它的实现是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>, bundle, makeJP&#125;</div></pre></td></tr></table></figure>
<p>注意这个 <code>this</code>，代表的是MainFragmentActivity 对象。<br>相对应的看下patch包中的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object[] objArr = <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>, savedInstanceState, joinPoint&#125;;</div></pre></td></tr></table></figure>
<p>这里调用了下 <code>getRealParameter(new Object[]{objArr})</code> 进行了 this 转换，所以这里的this 也是MainFragmentActivity对象，这里是没问题的。<br>然后调用 <code>linkClosureAndJoinPoint</code> 方法得到 ProceedingJoinPoint 对象，当做参数传递给 MainFragmentActivity$$Injector.onCreate(ProceedingJoinPoint joinPoint)  方法，看下这个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">MainFragmentActivity$$Injector.class</div><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragmentActivity</span>$$<span class="title">Injector</span> </span>&#123;</div><div class="line">  <span class="meta">@Around</span>(<span class="string">"execution(* com.zhangdan.app.activities.MainFragmentActivity.onCreate(..))"</span>)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    MainFragmentActivity target = (MainFragmentActivity)joinPoint.getTarget();</div><div class="line">    ...</div><div class="line">    joinPoint.proceed();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>调用了 ProceedingJoinPoint.proceed 抽象方法，实现在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   JoinPointImpl.<span class="function">java</span></div><div class="line"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</div><div class="line">	<span class="comment">// when called from a before advice, but be a no-op</span></div><div class="line">		<span class="keyword">return</span> arc.run(arc.getState());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 <code>arc</code> 是 AroundClosure，<code>arc.getState()</code> 返回的是构造 AroundClosure 时传递过来的对象数组。<br>最后调用了抽象方法 <code>run(Object[] args)</code>，实现在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragmentActivity</span>$<span class="title">AjcClosure3</span> <span class="keyword">extends</span> <span class="title">AroundClosure</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ChangeQuickRedirect changeQuickRedirect;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> MainFragmentActivity$AjcClosure3(Object[] objArr) &#123;</div><div class="line">        <span class="keyword">super</span>(objArr);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">(Object[] objArr)</span> </span>&#123;</div><div class="line">        PatchProxyResult proxy = PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;objArr&#125;, <span class="keyword">this</span>, changeQuickRedirect, <span class="keyword">false</span>, <span class="number">11911</span>, <span class="keyword">new</span> Class[]&#123;Object[].class&#125;, Object.class);</div><div class="line">        <span class="keyword">if</span> (proxy.isSupported) &#123;</div><div class="line">            <span class="keyword">return</span> proxy.result;</div><div class="line">        &#125;</div><div class="line">        Object[] objArr2 = <span class="keyword">this</span>.state;</div><div class="line">        MainFragmentActivity.onCreate_aroundBody2((MainFragmentActivity) objArr2[<span class="number">0</span>], (Bundle) objArr2[<span class="number">1</span>], (JoinPoint) objArr2[<span class="number">2</span>]);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后调用 <code>MainFragmentActivity.onCreate_aroundBody2((MainFragmentActivity) objArr2[0], (Bundle) objArr2[1], (JoinPoint) objArr2[2]);</code>，整个 AOP 的流程就走通了。</p>
<p>最后总结下 Aspectj 的调用流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MainFragmentActivity.onCreate -&gt; </div><div class="line">MainFragmentActivity$$Injector.onCreate(ProceedingJoinPoint joinPoint) -&gt; </div><div class="line">ProceedingJoinPoint.proceed() -&gt; </div><div class="line">AroundClosure.run(Object[] args) -&gt;  </div><div class="line">MainFragmentActivity$AjcClosure3.run(Object[] objArr) -&gt; </div><div class="line">MainFragmentActivity.onCreate_aroundBody2((MainFragmentActivity) objArr2[<span class="number">0</span>], (Bundle) objArr2[<span class="number">1</span>], (JoinPoint) objArr2[<span class="number">2</span>]); -&gt; </div><div class="line">MainFragmentActivity.onCreate_aroundBody1$advice -&gt; </div><div class="line">MainFragmentActivity.onCreate_aroundBody0();</div></pre></td></tr></table></figure>
<p>最后的 <code>MainFragmentActivity.onCreate_aroundBody0();</code>方法实际上就是onCreate()的原始方法逻辑。</p>
<p>另外，对于修改后的代码，没有被打入补丁，也是可以解释的。<br>对于 auto-path-plugin，Transform 的顺序是 Aspectj -&gt; auto-patch.<br>那么，对于标记修改的 onCreate 方法来说，Aspectj 处理完后，onCreate 方法被替换成了代理，真正的方法实现被新生成的方法隐藏起来了。<br>而我们仅仅标记了旧的 onCreate 方法，其结果就是，Aspectj 的代理 onCreate 方法被 patch 了，而实际的方法虽然方法体内有我们的修复，但是由于没有标记 <code>@modify</code> 而被忽略。</p>
<p>因为是强转 crash，所以在 $$Injector 代码中插入一些 Log</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">MainFragmentActivity$$Injector.class</div><div class="line">    <span class="meta">@Around</span>(<span class="string">"execution(* com.zhangdan.app.activities.MainFragmentActivity.onCreate(..))"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;proceedingJoinPoint&#125;, <span class="keyword">this</span>, changeQuickRedirect, <span class="keyword">false</span>, <span class="number">11892</span>, <span class="keyword">new</span> Class[]&#123;ProceedingJoinPoint.class&#125;, Void.TYPE).isSupported) &#123;</div><div class="line">            MainFragmentActivity target = (MainFragmentActivity) proceedingJoinPoint.getTarget();</div><div class="line">            ...</div><div class="line">            Log.d(<span class="string">"robust-wll"</span>, <span class="string">"test for aspectj start "</span>);</div><div class="line">            ...</div><div class="line">            Log.d(<span class="string">"robust-wll"</span>, <span class="string">"getTarget : "</span> + proceedingJoinPoint.getTarget().getClass().getSimpleName());</div><div class="line">            Log.d(<span class="string">"robust-wll"</span>, <span class="string">"getThis : "</span> + proceedingJoinPoint.getThis().getClass().getSimpleName());</div><div class="line">            Log.d(<span class="string">"robust-wll"</span>, <span class="string">"getArgs[0] : "</span> + (proceedingJoinPoint.getArgs()[<span class="number">0</span>] != <span class="keyword">null</span> ? proceedingJoinPoint.getArgs()[<span class="number">0</span>].getClass().getSimpleName() : <span class="keyword">null</span>));</div><div class="line">            Field arcField = proceedingJoinPoint.getClass().getDeclaredField(<span class="string">"arc"</span>);</div><div class="line">            arcField.setAccessible(<span class="keyword">true</span>);</div><div class="line">            AroundClosure arc = (AroundClosure) arcField.get(proceedingJoinPoint);</div><div class="line">            <span class="keyword">if</span> (!(arc == <span class="keyword">null</span> || arc.getState() == <span class="keyword">null</span> || arc.getState().length &lt; <span class="number">3</span>)) &#123;</div><div class="line">                Object[] states = arc.getState();</div><div class="line">                Log.d(<span class="string">"robust-wll"</span>, <span class="string">"states[0] : "</span> + (states[<span class="number">0</span>] != <span class="keyword">null</span> ? states[<span class="number">0</span>].getClass().getSimpleName() : <span class="keyword">null</span>));</div><div class="line">                Log.d(<span class="string">"robust-wll"</span>, <span class="string">"states[1] : "</span> + (states[<span class="number">1</span>] != <span class="keyword">null</span> ? states[<span class="number">1</span>].getClass().getSimpleName() : <span class="keyword">null</span>));</div><div class="line">                Log.d(<span class="string">"robust-wll"</span>, <span class="string">"states[2] : "</span> + (states[<span class="number">2</span>] != <span class="keyword">null</span> ? states[<span class="number">2</span>].getClass().getSimpleName() : <span class="keyword">null</span>));</div><div class="line">            &#125;</div><div class="line">            Log.d(<span class="string">"robust-wll"</span>, <span class="string">"test for aspectj end "</span>);</div><div class="line">            proceedingJoinPoint.proceed();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在不加载补丁情况下的 log 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.184</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: test <span class="keyword">for</span> aspectj start </div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.184</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: getTarget : MainFragmentActivity</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.185</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: getThis : MainFragmentActivity</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.185</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: getArgs[<span class="number">0</span>] : <span class="keyword">null</span></div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.185</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: states[<span class="number">0</span>] : MainFragmentActivity</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.185</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: states[<span class="number">1</span>] : <span class="keyword">null</span></div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.186</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: states[<span class="number">2</span>] : JoinPointImpl</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">41.186</span> <span class="number">15469</span> <span class="number">15469</span> D robust-wll: test <span class="keyword">for</span> aspectj end</div></pre></td></tr></table></figure>
<p>加载补丁后，log 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.885</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: test <span class="keyword">for</span> aspectj start </div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.885</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: getTarget : MainFragmentActivity</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.886</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: getThis : MainFragmentActivity</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.886</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: getArgs[<span class="number">0</span>] : <span class="keyword">null</span></div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.886</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: states[<span class="number">0</span>] : MainFragmentActivityPatch</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.886</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: states[<span class="number">1</span>] : <span class="keyword">null</span></div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.886</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: states[<span class="number">2</span>] : JoinPointImpl</div><div class="line"><span class="number">04</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">41.886</span> <span class="number">18490</span> <span class="number">18490</span> D robust-wll: test <span class="keyword">for</span> aspectj end</div></pre></td></tr></table></figure>
<p><strong>states[0] : MainFragmentActivityPatch</strong> 这个明显是不对的，所以我们知道了原因，是因为在构造 <code>AroundClosure</code> 时候传进来的参数不对。<br>报错地方对应于上面的分析，也就是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object[] objArr = <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>, savedInstanceState, joinPoint&#125;;</div><div class="line">Object obj2 = (AjcClosure3) EnhancedRobustUtils.invokeReflectConstruct(<span class="string">"com.zhangdan.app.activities.MainFragmentActivity$AjcClosure3"</span>, getRealParameter(<span class="keyword">new</span> Object[]&#123;objArr&#125;), <span class="keyword">new</span> Class[]&#123;Object[].class&#125;);</div></pre></td></tr></table></figure></p>
<p>结果就是，把一个含有3个对象的一维数据，编程了含有一个对象的二维数组，然后去 getRealParameter。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Object[] getRealParameter(Object[] objArr) &#123;</div><div class="line">    <span class="keyword">if</span> (objArr == <span class="keyword">null</span> || objArr.length &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> objArr;</div><div class="line">    &#125;</div><div class="line">    Object[] objArr2 = <span class="keyword">new</span> Object[objArr.length];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objArr.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (objArr[i] == <span class="keyword">this</span>) &#123;</div><div class="line">            objArr2[i] = <span class="keyword">this</span>.originClass;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            objArr2[i] = objArr[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> objArr2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而这个方法只判断了一维数组的情况，没有判断二维或多维数组的情况。终于找到原因了 😃<br>对应的修改方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Object[] getRealParameter(Object[] objArr) &#123;</div><div class="line">    <span class="keyword">if</span> (objArr == <span class="keyword">null</span> || objArr.length &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> objArr;</div><div class="line">    &#125;</div><div class="line">    Object[] objArr2 = <span class="keyword">new</span> Object[objArr.length];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objArr.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (objArr[i] <span class="keyword">instanceof</span> Object[]) &#123;</div><div class="line">            objArr2[i] = getRealParameter(((Object[]) objArr[i]));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (objArr[i] == <span class="keyword">this</span>) &#123;</div><div class="line">                objArr2[i] = <span class="keyword">this</span>.originClass;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                objArr2[i] = objArr[i];</div><div class="line">            &#125;</div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> objArr2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>castException 终于是搞定了。具体解决方法见 <a href="https://github.com/Meituan-Dianping/Robust/pull/259" target="_blank" rel="external">merge request #259</a>。</p>
<h1 id="static-方法中包含-super-方法怎么办？"><a href="#static-方法中包含-super-方法怎么办？" class="headerlink" title="static 方法中包含 super 方法怎么办？"></a>static 方法中包含 super 方法怎么办？</h1><p>看到这个标题可能会一脸懵逼，static 方法中怎么可能包含 super 调用？别急慢慢往下看。</p>
<p>书接上节，至于被 Aspectj  处理过的方法无法被打入 patch 的问题，理论上来说跟泛型的桥方法是类似的，解决方案也是 <code>@Modify -&gt; RobustModify.modify();</code>，修改后经验证，会报错。log如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">Caused by: javassist.CannotCompileException: [source error] not-available: <span class="keyword">this</span></div><div class="line">        at javassist.expr.MethodCall.replace(MethodCall.java:<span class="number">241</span>)</div><div class="line">        at javassist.expr.MethodCall$replace$<span class="number">2</span>.call(Unknown Source)</div><div class="line">        at com.meituan.robust.autopatch.PatchesFactory$<span class="number">1</span>.edit(PatchesFactory.groovy:<span class="number">144</span>)</div><div class="line">        at javassist.expr.ExprEditor.loopBody(ExprEditor.java:<span class="number">224</span>)</div><div class="line">        at javassist.expr.ExprEditor.doit(ExprEditor.java:<span class="number">91</span>)</div><div class="line">        at javassist.CtBehavior.instrument(CtBehavior.java:<span class="number">712</span>)</div><div class="line">        at javassist.CtBehavior$instrument$<span class="number">1</span>.call(Unknown Source)</div><div class="line">        at com.meituan.robust.autopatch.PatchesFactory.createPatchClass(PatchesFactory.groovy:<span class="number">76</span>)</div><div class="line">        at com.meituan.robust.autopatch.PatchesFactory.createPatch(PatchesFactory.groovy:<span class="number">310</span>)</div><div class="line">        at com.meituan.robust.autopatch.PatchesFactory$createPatch.call(Unknown Source)</div><div class="line">        at robust.gradle.plugin.AutoPatchTransform.generatPatch(AutoPatchTransform.groovy:<span class="number">190</span>)</div><div class="line">        at robust.gradle.plugin.AutoPatchTransform$generatPatch$<span class="number">0</span>.callCurrent(Unknown Source)</div><div class="line">        at robust.gradle.plugin.AutoPatchTransform.autoPatch(AutoPatchTransform.groovy:<span class="number">138</span>)</div><div class="line">        at robust.gradle.plugin.AutoPatchTransform$autoPatch.callCurrent(Unknown Source)</div><div class="line">        at robust.gradle.plugin.AutoPatchTransform.transform(AutoPatchTransform.groovy:<span class="number">97</span>)</div><div class="line">        at com.android.build.api.transform.Transform.transform(Transform.java:<span class="number">290</span>)</div><div class="line">        at com.android.build.gradle.internal.pipeline.TransformTask$<span class="number">2</span>.call(TransformTask.java:<span class="number">185</span>)</div><div class="line">        at com.android.build.gradle.internal.pipeline.TransformTask$<span class="number">2</span>.call(TransformTask.java:<span class="number">181</span>)</div><div class="line">        at com.android.builder.profile.ThreadRecorder.record(ThreadRecorder.java:<span class="number">102</span>)</div><div class="line">        ... <span class="number">27</span> more</div><div class="line">Caused by: compile error: not-available: <span class="keyword">this</span></div><div class="line">        at javassist.compiler.CodeGen.atKeyword(CodeGen.java:<span class="number">1908</span>)</div><div class="line">        at javassist.compiler.ast.Keyword.accept(Keyword.java:<span class="number">35</span>)</div><div class="line">        at javassist.compiler.JvstCodeGen.atMethodArgs(JvstCodeGen.java:<span class="number">358</span>)</div><div class="line">        at javassist.compiler.MemberCodeGen.atMethodCallCore(MemberCodeGen.java:<span class="number">569</span>)</div><div class="line">        at javassist.compiler.MemberCodeGen.atCallExpr(MemberCodeGen.java:<span class="number">537</span>)</div><div class="line">        at javassist.compiler.JvstCodeGen.atCallExpr(JvstCodeGen.java:<span class="number">244</span>)</div><div class="line">        at javassist.compiler.ast.CallExpr.accept(CallExpr.java:<span class="number">46</span>)</div><div class="line">        at javassist.compiler.CodeGen.atStmnt(CodeGen.java:<span class="number">338</span>)</div><div class="line">        at javassist.compiler.ast.Stmnt.accept(Stmnt.java:<span class="number">50</span>)</div><div class="line">        at javassist.compiler.CodeGen.atStmnt(CodeGen.java:<span class="number">351</span>)</div><div class="line">        at javassist.compiler.ast.Stmnt.accept(Stmnt.java:<span class="number">50</span>)</div><div class="line">        at javassist.compiler.Javac.compileStmnt(Javac.java:<span class="number">569</span>)</div><div class="line">        at javassist.expr.MethodCall.replace(MethodCall.java:<span class="number">235</span>)</div><div class="line">        ... <span class="number">45</span> more</div></pre></td></tr></table></figure></p>
<p>问题分析，根据堆栈显示，这里是在做替换 super 方法的逻辑，跟了下 plugin 的 debug，生成需要 replace 的 javassist 代码为 <code>{staticRobustonCreate(this,originClass,$$);}</code>，然后在 replace 后，javac 编译这条语句的时候跪了。<br>分析下需要替换的 super 的方法，这个方法实际上是 Aspectj 处理后的方法，根据上面分析的 Aspectj 的调用流程得知，该方法实际上是 onCreate 方法原始的逻辑，反编译出来如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCreate_aroundBody0</span><span class="params">(MainFragmentActivity mainFragmentActivity, Bundle bundle, JoinPoint joinPoint)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;mainFragmentActivity, bundle, joinPoint&#125;, <span class="keyword">null</span>, changeQuickRedirect, <span class="keyword">true</span>, <span class="number">11887</span>, <span class="keyword">new</span> Class[]&#123;MainFragmentActivity.class, Bundle.class, JoinPoint.class&#125;, Void.TYPE).isSupported) &#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(bundle);<span class="comment">//这里是需要替换的地方</span></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而 auto-patch 做的工作是将<code>super.onCreate</code>方法包装成 static 方法，正常生成的patch代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivityPatch</span> </span>&#123;</div><div class="line">    SecondActivity originClass;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecondActivityPatch</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.originClass = (SecondActivity) obj;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</div><div class="line">        staticRobustonCreate(<span class="keyword">this</span>,originClass,bundle);</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticRobustonCreate</span><span class="params">(SecondActivityPatch secondActivityPatch, SecondActivity secondActivity, Bundle bundle)</span> </span>&#123;</div><div class="line">        SecondActivityPatchRobustAssist.staticRobustonCreate(secondActivityPatch, secondActivity, bundle);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivityPatchRobustAssist</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticRobustonCreate</span><span class="params">(SecondActivityPatch secondActivityPatch, SecondActivity secondActivity, Bundle bundle)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(bundle);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而对于已经被 Aspectj 处理过的方法，是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCreate_aroundBody0</span><span class="params">(MainFragmentActivity mainFragmentActivity, Bundle bundle, JoinPoint joinPoint)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!PatchProxy.proxy(<span class="keyword">new</span> Object[]&#123;mainFragmentActivity, bundle, joinPoint&#125;, <span class="keyword">null</span>, changeQuickRedirect, <span class="keyword">true</span>, <span class="number">11887</span>, <span class="keyword">new</span> Class[]&#123;MainFragmentActivity.class, Bundle.class, JoinPoint.class&#125;, Void.TYPE).isSupported) &#123;</div><div class="line">        <span class="comment">//super.onCreate(bundle);//这里是需要替换的地方</span></div><div class="line">        staticRobustonCreate(<span class="keyword">this</span>,originClass,bundle);</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在static 方法中使用了 <code>this</code>关键字，当然编译出错啦。同理这个 <code>originClass</code> 也不可以出现，因为它是非 static 变量。<br>由于 xxPatchRobustAssist.staticRobustonCreate() 方法并没有用到前两个变量(patch, activity)，直接传 null 行不行呢？经验证是不行的，原因如下。<br>看了下生成xxxPatchRobustAssist类的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PatchesAssistFactory</span> </span>&#123;</div><div class="line">    <span class="function">def</span></div><div class="line">    <span class="keyword">static</span> <span class="title">createAssistClass</span><span class="params">(CtClass modifiedClass, String patchClassName, CtMethod removeMethod)</span> &#123;</div><div class="line">       ....</div><div class="line">        StringBuilder staticMethodBuidler = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">if</span> (removeMethod.parameterTypes.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            staticMethodBuidler.append(<span class="string">"public static  "</span> + removeMethod.returnType.name + <span class="string">"   "</span> + ReflectUtils.getStaticSuperMethodName(removeMethod.getName())</div><div class="line">                    + <span class="string">"("</span> + patchClassName + <span class="string">" patchInstance,"</span> + modifiedClass.getName() + <span class="string">" modifiedInstance,"</span> + JavaUtils.getParameterSignure(removeMethod) + <span class="string">")&#123;"</span>);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            staticMethodBuidler.append(<span class="string">"public static  "</span> + removeMethod.returnType.name + <span class="string">"   "</span> + ReflectUtils.getStaticSuperMethodName(removeMethod.getName())</div><div class="line">                    + <span class="string">"("</span> + patchClassName + <span class="string">" patchInstance,"</span> + modifiedClass.getName() + <span class="string">" modifiedInstance)&#123;"</span>);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        staticMethodBuidler.append(<span class="string">" return patchInstance."</span> + removeMethod.getName() + <span class="string">"("</span> + JavaUtils.getParameterValue(removeMethod.getParameterTypes().length) + <span class="string">");"</span>);</div><div class="line">        staticMethodBuidler.append(<span class="string">"&#125;"</span>);</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> assistClass;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上，最终生成的调用是 <code>xxPatch.superMethod($$);</code> ，$$代表全部参数。对于与上面的 onCreate 方法就是 <code>xxPatch.onCreate(bundle);</code>。<br>所以，patch 应该不能传 null 了，否则运行时会报空指针，那第二个参数 activity  能不能传 null 呢？继续往下看。<br>首先，根据常识，static 方法中肯定是不能调用 super方法的。从最终生成的代码也能看出，这并不是最终反编译出的的 <code>super.onCreate(bundle)</code>方法调用。所以处理的地方肯定在javassist修改编译之后，对应处理的地方在smali 层，代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">SmaliTool.<span class="function">java</span></div><div class="line">    <span class="keyword">private</span> String <span class="title">invokeSuperMethodInSmali</span><span class="params">(<span class="keyword">final</span> String line, String fullClassName)</span> &#123;</div><div class="line">                    ...</div><div class="line">                    result = line.replace(Constants.SMALI_INVOKE_VIRTUAL_COMMAND, Constants.SMALI_INVOKE_SUPER_COMMAND);</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (!ctMethod.getReturnType().isPrimitive()) &#123;</div><div class="line">                            returnType = <span class="string">"L"</span> + ctMethod.getReturnType().getName().replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>);</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            returnType = String.valueOf(((CtPrimitiveType) ctMethod.getReturnType()).getDescriptor());</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (NameManger.getInstance().getPatchNameMap().get(fullClassName).equals(fullClassName)) &#123;</div><div class="line">                            result = result.replace(<span class="string">"p0"</span>, <span class="string">"p1"</span>);</div><div class="line">                        &#125;</div><div class="line">                       ...</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">                    &#125;</div><div class="line">                ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>实际上就是把方法调用从 <code>invoke-invoke-virtual {p0, p2}, Lcom/meituan/robust/patch/SecondActivityPatch;-&gt;onCreate(Landroid/os/Bundle;)</code>V 转换成 <code>invoke-super {p1, p2}, Landroid/support/v7/app/AppCompatActivity;-&gt;onCreate(Landroid/os/Bundle;)V</code>，这步处理完才会真正的调用父类的super方法。<br>也就是说，在 smali 处理完后，参数从 p0 -&gt; p1，也就是参数从 xxpatch 换成了 Activity，第二个参数会在运行时用到，所以也不能传null。<br>分析完了总结下，第二个参数 originClass 肯定不能传 null，否则会空指针；第一个参数  xxPatch，由于在 smali 被替换成了第二个参数，所以有可能是可以传 null 的。</p>
<p>解决方案：</p>
<ol>
<li>修改 originClass 为static，并新增一个 static patch 变量</li>
<li>由于目前已经是在 static 方法中存在 super 方法，对应的 smali 代码：</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.<span class="function">method <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="title">onCreate_aroundBody0</span><span class="params">(Lcom/zhangdan/app/activities/MainFragmentActivity;Landroid/os/Bundle;Lorg/aspectj/lang/JoinPoint;)</span>V</span></div><div class="line"> ...</div><div class="line">invoke-<span class="keyword">super</span> &#123;p0, p1&#125;, Lcom/zhangdan/app/activities/WrapperAppCompatFragmentActivity;-&gt;onCreate(Landroid/os/Bundle;)V</div></pre></td></tr></table></figure>
</li>
</ol>
<p>所以只要不处理就好了，需要做的就是在 auto-plugin 中增加条件判断，符合 static 方法中带有 super 的不处理，一共有三处，一处是生成 xxPatchRobustAssist 辅助类，第二处在 javassit 替换 super 方法，第三处在 smali 处理补丁中的 super 方法。</p>
<p>对于方案1，问题：<br>如果 patch 和 originClass 都是 static，那么就会有内存泄露的风险。<br>并且如果被 patch 方法是 static 方法，那么在初始化 patch 时，originClass 会传 null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">accessDispatch</span><span class="params">(String methodName, Object[] paramArrayOfObject)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Log.d(<span class="string">"robust"</span>, <span class="keyword">new</span> StringBuffer().append(<span class="string">"arrivied in AccessDispatch "</span>).append(methodName).append(<span class="string">" paramArrayOfObject  "</span>).append(paramArrayOfObject).toString());</div><div class="line">        MainFragmentActivityPatch mainFragmentActivityPatch;</div><div class="line">        <span class="keyword">if</span> (!methodName.split(<span class="string">":"</span>)[<span class="number">2</span>].equals(<span class="string">"false"</span>)) &#123;</div><div class="line">            Log.d(<span class="string">"robust"</span>, <span class="string">"static method forward "</span>);</div><div class="line">            mainFragmentActivityPatch = <span class="keyword">new</span> MainFragmentActivityPatch(<span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<p>同样应该也是为了避免内存泄露，每修复一个方法就会生成一个 patch 对象并持有 static 的 originClass 引用。<br>对于方案2 ，问题：<br>首先，Aspectj 在 static 方法中插了个 super 方法（猜测也是在 smali 层做的修改），直接写的话 javac 编译时会报错，smali 处理吧还没到这一步。所以被修复后，这个 static 方法是在 xxPatch 类中的，auto-patch 即使不处理，运行时也不能正常运行，因为 xxPatch 不是 originClass 父类的子类，不能直接其调用 super 方法。</p>
<p>观察 Aspectj 生成的方法，所有 的static 方法，第一个参数都是当前类的引用，比如 <code>private static final void onCreate_aroundBody0(MainFragmentActivity mainFragmentActivity, Bundle bundle, JoinPoint joinPoint) {</code>。<br>所以比如根据上面的分析，得出一个可行的方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">def <span class="keyword">static</span> String <span class="title">invokeSuperString</span><span class="params">(MethodCall m, String originClass)</span> </span>&#123;</div><div class="line">       ...</div><div class="line">       stringBuilder.append(getStaticSuperMethodName(m.methodName) + <span class="string">"("</span> + <span class="keyword">null</span> + <span class="string">","</span> + originClass + <span class="string">",\$\$);"</span>);</div><div class="line">       ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是 static 方法中含有 super 方法，就如下处理。<br>第一个 xxPatch 对象传空，最后在 smali 处理的时候会被替换掉。<br>第二个参数是从类似<code>onCreate_aroundBody0()</code>中传过来的，后面的是其他参数。<br>最终结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticRobustonCreate</span><span class="params">(MainFragmentActivityPatch mainFragmentActivityPatch, MainFragmentActivity mainFragmentActivity, Bundle bundle)</span> </span>&#123;</div><div class="line">    MainFragmentActivityPatchRobustAssist.staticRobustonCreate(mainFragmentActivityPatch, mainFragmentActivity, bundle);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCreate_aroundBody0</span><span class="params">(MainFragmentActivity ajc$<span class="keyword">this</span>, Bundle savedInstanceState, JoinPoint joinPoint)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    staticRobustonCreate(<span class="keyword">null</span>, ajc$<span class="keyword">this</span>, savedInstanceState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里这个问题就分析完了，详细解决方发见 <a href="https://github.com/Meituan-Dianping/Robust/pull/265" target="_blank" rel="external">merge request #265</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个系列到这里基本就结束了。这篇文章主要介绍了在接入 Robust 过程中碰到的一些坑以及解决思路，其实根本还是熟读源码，碰到问题学习从源码中找答案。要坚信，坑踩的多了，也就不怕坑了。最后福利一张。</p>
<p><img src="http://wx3.sinaimg.cn/large/0078WU5Lgy1fsgrhhx37tj30o31040zf.jpg" alt=""></p>
<p>本文链接： <a href="http://w4lle.com/2018/06/20/robust-2/">http://w4lle.com/2018/06/20/robust-2/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前两篇文章中，分析了 Android 热补丁框架 Robust 中，几个重要的流程包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;补丁加载过程&lt;/li&gt;
&lt;li&gt;基础包插桩过程&lt;/li&gt;
&lt;li&gt;补丁包自动化生成过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇文章主要分析下集成过程中遇到的坑以及分析问题的思路和最终的解决方案。包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打补丁包出错？&lt;/li&gt;
&lt;li&gt;Robust 定义的 API 不够用怎么办？&lt;/li&gt;
&lt;li&gt;插件 Plugin Transform 的顺序问题？&lt;/li&gt;
&lt;li&gt;与 Aspectj 冲突怎么办？&lt;/li&gt;
&lt;li&gt;static 方法中包含 super 方法怎么办？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
      <category term="热补丁" scheme="http://w4lle.com/tags/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>Android热补丁之Robust（二）自动化补丁原理解析</title>
    <link href="http://w4lle.com/2018/05/28/robust-1/"/>
    <id>http://w4lle.com/2018/05/28/robust-1/</id>
    <published>2018-05-28T11:47:06.000Z</published>
    <updated>2018-05-29T08:40:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android 热补丁框架 Robust 中，几个重要的流程包括：</p>
<ul>
<li>补丁加载过程</li>
<li>基础包插桩过程</li>
<li>补丁包生成过程</li>
</ul>
<p>在上一篇文章<a href="http://w4lle.com/2017/03/31/robust-0/">Android热补丁之Robust原理解析(一)</a>中，我们分析了前两个，补丁加载过程和基础包插桩过程，分析的版本为 <code>0.3.2</code>。<br>该篇文章为该系列的第二篇文章，主要分析补丁自动化生成的过程，分析的版本为<code>0.4.82</code>。<br><a id="more"></a><br>时间跨度有点大…</p>
<p>系列文章:</p>
<ul>
<li><a href="http://w4lle.com/2017/03/31/robust-0/">Android热补丁之Robust原理解析(一)</a></li>
<li><a href="http://w4lle.com/2018/05/28/robust-1/">Android热补丁之Robust（二）自动化补丁原理解析</a></li>
<li><a href="http://w4lle.com/2018/05/29/robust-2/">Android热补丁之Robust（三）坑和解</a></li>
</ul>
<h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p>首先在 Gradle 插件中注册了一个名为 AutoPatchTranform 的 Tranform </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPatchTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project target)</span> </span>&#123;</div><div class="line">    initConfig();</div><div class="line">    project.android.registerTransform(<span class="keyword">this</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">def <span class="title">initConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">    NameManger.init();</div><div class="line">    InlineClassFactory.init();</div><div class="line">    ReadMapping.init();</div><div class="line">    Config.init();</div><div class="line">    ...</div><div class="line">    ReadXML.readXMl(project.projectDir.path);</div><div class="line">    Config.methodMap = JavaUtils.getMapFromZippedFile(project.projectDir.path + Constants.METHOD_MAP_PATH)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该类为插件的入口，实现了 GradlePlugin 并继承自 Transform，在入口处初始化配置并注册 Transform。配置主要是读取 Robust xml 配置、混淆优化后的 mapping 文件、插庄过程中生成的 methodsMap.robust 文件、初始化内联工厂类等等。<br>然后最主要的是<code>transform</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(Context context, Collection&lt;TransformInput&gt; inputs, Collection&lt;TransformInput&gt; referencedInputs, TransformOutputProvider outputProvider, <span class="keyword">boolean</span> isIncremental)</span> <span class="keyword">throws</span> IOException, TransformException, InterruptedException </span>&#123;</div><div class="line">    project.android.bootClasspath.each &#123;</div><div class="line">        Config.classPool.appendClassPath((String) it.absolutePath)</div><div class="line">    &#125;</div><div class="line">    def box = ReflectUtils.toCtClasses(inputs, Config.classPool)</div><div class="line">    ...</div><div class="line">    autoPatch(box)</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">def <span class="title">autoPatch</span><span class="params">(List&lt;CtClass&gt; box)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    ReadAnnotation.readAnnotation(box, logger);</div><div class="line">    <span class="keyword">if</span>(Config.supportProGuard) &#123;</div><div class="line">        ReadMapping.getInstance().initMappingInfo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    generatPatch(box,patchPath);</div><div class="line"></div><div class="line">    zipPatchClassesFile()</div><div class="line">    executeCommand(jar2DexCommand)</div><div class="line">    executeCommand(dex2SmaliCommand)</div><div class="line">    SmaliTool.getInstance().dealObscureInSmali();</div><div class="line">    executeCommand(smali2DexCommand)</div><div class="line">    <span class="comment">//package patch.dex to patch.jar</span></div><div class="line">    packagePatchDex2Jar()</div><div class="line">    deleteTmpFiles()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>transform</code> 方法中，使用 javassist API 把所有需要处理的类加载到待扫描队列中，然后调用<code>autoPatch</code>方法自动生成补丁。<br>在 <code>autoPatch</code>方法中，主要做了这么几件事情：</p>
<ol>
<li>读取被 @Add、@Modify、RobustModify.modify() 标注的方法或类并记录</li>
<li>解析 mapping 文件并记录每个类和类中方法混淆前后对应的信息，其中方法存储的信息有：返回值，方法名，参数列表，混淆后的名字；字段存储的信息有：字段名，混淆后的名字</li>
<li>根据得到的信息，<code>generatPatch</code> 方法实际生成补丁</li>
<li>将生成的补丁class打包成jar包</li>
<li>jar -&gt; dex</li>
<li>dex -&gt; smali</li>
<li>处理 smali，主要是处理 super 方法和处理混淆关系</li>
<li>smali -&gt; dex</li>
<li>dex -&gt; jar</li>
</ol>
<p>1、2 比较好懂就不逐步分析了，主要看3；后面的5、6、7、8、9 都是为了 7 中处理 smali，所以只要搞懂smali处理就好了。下面我们分步来看。</p>
<h1 id="生成补丁"><a href="#生成补丁" class="headerlink" title="生成补丁"></a>生成补丁</h1><p>主要逻辑在 <code>generatPatch</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function">def  <span class="title">generatPatch</span><span class="params">(List&lt;CtClass&gt; box,String patchPath)</span></span>&#123;</div><div class="line">...</div><div class="line">    InlineClassFactory.dealInLineClass(patchPath, Config.newlyAddedClassNameList)</div><div class="line">    initSuperMethodInClass(Config.modifiedClassNameList);</div><div class="line">    <span class="comment">//auto generate all class</span></div><div class="line">    <span class="keyword">for</span> (String fullClassName : Config.modifiedClassNameList) &#123;</div><div class="line">        CtClass ctClass = Config.classPool.get(fullClassName)</div><div class="line">        CtClass patchClass = PatchesFactory.createPatch(patchPath, ctClass, <span class="keyword">false</span>, NameManger.getInstance().getPatchName(ctClass.name), Config.patchMethodSignatureSet)</div><div class="line">        patchClass.writeFile(patchPath)</div><div class="line">        patchClass.defrost();</div><div class="line">        createControlClass(patchPath, ctClass)</div><div class="line">    &#125;</div><div class="line">    createPatchesInfoClass(patchPath);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分为两个部分</p>
<h2 id="逐步翻译"><a href="#逐步翻译" class="headerlink" title="逐步翻译"></a>逐步翻译</h2><p>首先调用<code>InlineClassFactory.dealInLineClass(patchPath, Config.newlyAddedClassNameList)</code>识别被优化过的方法，这里的优化是泛指，包括被优化、内联、新增过的类和方法，具体的逻辑为扫描修改后的所有类和类中的方法，如果这些类和方法不在 mapping 文件中存在，那么可以定义为被优化过，其中包括<code>@Add</code>新增的类或方法。<br>然后调用<code>initSuperMethodInClass</code>方法识别修改后的所有类和类中的方法中，分析是否如包含 <code>super</code> 方法，如果有那么缓存下来。<br>然后调用 <code>PatchesFactory.createPatch</code> 反射翻译修改的类和方法，具体的实现在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> CtClass <span class="title">createPatchClass</span><span class="params">(CtClass modifiedClass, <span class="keyword">boolean</span> isInline, String patchName, Set patchMethodSignureSet, String patchPath)</span> <span class="keyword">throws</span> CannotCompileException, IOException, NotFoundException </span>&#123;</div><div class="line">    <span class="comment">//清洗需要处理的方法，略..</span></div><div class="line"></div><div class="line">    CtClass temPatchClass = cloneClass(modifiedClass, patchName, methodNoNeedPatchList);</div><div class="line">    </div><div class="line">    JavaUtils.addPatchConstruct(temPatchClass, modifiedClass);</div><div class="line">    CtMethod reaLParameterMethod = CtMethod.make(JavaUtils.getRealParamtersBody(), temPatchClass);</div><div class="line">    temPatchClass.addMethod(reaLParameterMethod);</div><div class="line"></div><div class="line">    dealWithSuperMethod(temPatchClass, modifiedClass, patchPath);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (CtMethod method : temPatchClass.getDeclaredMethods()) &#123;</div><div class="line">        <span class="comment">//  shit !!too many situations need take into  consideration</span></div><div class="line">        <span class="comment">//   methods has methodid   and in  patchMethodSignatureSet</span></div><div class="line">        <span class="keyword">if</span> (!Config.addedSuperMethodList.contains(method) &amp;&amp; reaLParameterMethod != method &amp;&amp; !method.getName().startsWith(Constants.ROBUST_PUBLIC_SUFFIX)) &#123;</div><div class="line">            method.instrument(</div><div class="line">                    <span class="keyword">new</span> ExprEditor() &#123;</div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">edit</span><span class="params">(FieldAccess f)</span> <span class="keyword">throws</span> CannotCompileException </span>&#123;</div><div class="line">                            ...</div><div class="line">                                <span class="keyword">if</span> (f.isReader()) &#123; f.replace(ReflectUtils.getFieldString(f.getField(), memberMappingInfo, temPatchClass.getName(), modifiedClass.getName()));</div><div class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.isWriter()) &#123;</div><div class="line">                                    f.replace(ReflectUtils.setFieldString(f.getField(), memberMappingInfo, temPatchClass.getName(), modifiedClass.getName()));</div><div class="line">                                &#125;</div><div class="line">                            ...</div><div class="line">                        &#125;</div><div class="line"></div><div class="line"></div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(NewExpr e)</span> <span class="keyword">throws</span> CannotCompileException </span>&#123;</div><div class="line">                            <span class="comment">//inner class in the patched class ,not all inner class</span></div><div class="line">                            ...</div><div class="line">                                <span class="keyword">if</span> (!ReflectUtils.isStatic(Config.classPool.get(e.getClassName()).getModifiers()) &amp;&amp; JavaUtils.isInnerClassInModifiedClass(e.getClassName(), modifiedClass)) &#123;</div><div class="line">                                    e.replace(ReflectUtils.getNewInnerClassString(e.getSignature(), temPatchClass.getName(), ReflectUtils.isStatic(Config.classPool.get(e.getClassName()).getModifiers()), getClassValue(e.getClassName())));</div><div class="line">                                    <span class="keyword">return</span>;</div><div class="line">                                &#125;</div><div class="line">                            ...</div><div class="line"></div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(Cast c)</span> <span class="keyword">throws</span> CannotCompileException </span>&#123;</div><div class="line">                            MethodInfo thisMethod = ReflectUtils.readField(c, <span class="string">"thisMethod"</span>);</div><div class="line">                            CtClass thisClass = ReflectUtils.readField(c, <span class="string">"thisClass"</span>);</div><div class="line"></div><div class="line">                            def isStatic = ReflectUtils.isStatic(thisMethod.getAccessFlags());</div><div class="line">                            <span class="keyword">if</span> (!isStatic) &#123;</div><div class="line">                                <span class="comment">//inner class in the patched class ,not all inner class</span></div><div class="line">                                <span class="keyword">if</span> (Config.newlyAddedClassNameList.contains(thisClass.getName()) || Config.noNeedReflectClassSet.contains(thisClass.getName())) &#123;</div><div class="line">                                    <span class="keyword">return</span>;</div><div class="line">                                &#125;</div><div class="line">                                <span class="comment">// static函数是没有this指令的，直接会报错。</span></div><div class="line">                                c.replace(ReflectUtils.getCastString(c, temPatchClass))</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(MethodCall m)</span> <span class="keyword">throws</span> CannotCompileException </span>&#123;</div><div class="line">                            ...</div><div class="line">                                <span class="keyword">if</span> (!repalceInlineMethod(m, method, <span class="keyword">false</span>)) &#123;</div><div class="line">                                    Map memberMappingInfo = getClassMappingInfo(m.getMethod().getDeclaringClass().getName());</div><div class="line">                                    <span class="keyword">if</span> (invokeSuperMethodList.contains(m.getMethod())) &#123;</div><div class="line">                                        <span class="keyword">int</span> index = invokeSuperMethodList.indexOf(m.getMethod());</div><div class="line">                                        CtMethod superMethod = invokeSuperMethodList.get(index);</div><div class="line">                                        <span class="keyword">if</span> (superMethod.getLongName() != <span class="keyword">null</span> &amp;&amp; superMethod.getLongName() == m.getMethod().getLongName()) &#123;</div><div class="line">                                            String firstVariable = <span class="string">""</span>;</div><div class="line">                                            <span class="keyword">if</span> (ReflectUtils.isStatic(method.getModifiers())) &#123;</div><div class="line">                                                <span class="comment">//修复static 方法中含有super的问题，比如Aspectj处理后的方法</span></div><div class="line">                                                MethodInfo methodInfo = method.getMethodInfo();</div><div class="line">                                                LocalVariableAttribute table = methodInfo.getCodeAttribute().getAttribute(LocalVariableAttribute.tag);</div><div class="line">                                                <span class="keyword">int</span> numberOfLocalVariables = table.tableLength();</div><div class="line">                                                <span class="keyword">if</span> (numberOfLocalVariables &gt; <span class="number">0</span>) &#123;</div><div class="line">                                                    <span class="keyword">int</span> frameWithNameAtConstantPool = table.nameIndex(<span class="number">0</span>);</div><div class="line">                                                    firstVariable = methodInfo.getConstPool().getUtf8Info(frameWithNameAtConstantPool)</div><div class="line">                                                &#125;</div><div class="line">                                            &#125;</div><div class="line">                                            m.replace(ReflectUtils.invokeSuperString(m, firstVariable));</div><div class="line">                                            <span class="keyword">return</span>;</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;</div><div class="line">                                    m.replace(ReflectUtils.getMethodCallString(m, memberMappingInfo, temPatchClass, ReflectUtils.isStatic(method.getModifiers()), isInline));</div><div class="line">                                &#125;</div><div class="line">                            ...</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//remove static code block,pay attention to the  class created by cloneClassWithoutFields which construct's</span></div><div class="line">    CtClass patchClass = cloneClassWithoutFields(temPatchClass, patchName, <span class="keyword">null</span>);</div><div class="line">    patchClass = JavaUtils.addPatchConstruct(patchClass, modifiedClass);</div><div class="line">    <span class="keyword">return</span> patchClass;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码其实是这个插件的核心部分，总体来说就是将修改后的代码全部翻译成反射调用生成 xxxPatch 类。<br>我们先只关注<code>method.instrument()</code>这个方法，这个Javassist的API，作用是遍历方法中的代码逻辑，包括：</p>
<ul>
<li>FieldAccess，字段访问操作。分为字段读和写两种，分别调用<code>ReflectUtils.getFieldString</code>方法，将代码逻辑使用Javassist翻译成反射调用，然后替换。</li>
<li>NewExpr，new 对象操作。也分为两种<ul>
<li>非静态内部类，调用<code>ReflectUtils.getNewInnerClassString</code>翻译成反射，然后替换</li>
<li>外部类，调用<code>ReflectUtils.getCreateClassString</code>翻译成反射，然后替换</li>
</ul>
</li>
<li>Cast，强转操作。调用<code>ReflectUtils.getCastString</code>翻译成反射，然后替换</li>
<li>MethodCall，方法调用操作。情况比较复杂，以下几种情形<ul>
<li>lamda表达式，调用<code>ReflectUtils.getNewInnerClassString</code>生成内部类的方法并翻译成反射，然后替换</li>
<li>修改的方法是内联方法，调用<code>ReflectUtils.getInLineMemberString</code>方法生成占位内联类<code>xxInLinePatch</code>，并在改类中把修改的方法翻译成反射，然后替换调用，这方法中又有一些其他情况判断，感兴趣的读者可以自行阅读</li>
<li>如果是super方法，这个情况后面单独拎出来说</li>
<li>正常方法，调用<code>ReflectUtils.getMethodCallString</code>方法翻译成反射，然后替换</li>
</ul>
</li>
<li>生成补丁类并增加构造方法</li>
</ul>
<p>请注意，以上所有方法和需要处理的方法都需要特别注意方法签名！</p>
<h2 id="控制补丁行为"><a href="#控制补丁行为" class="headerlink" title="控制补丁行为"></a>控制补丁行为</h2><p>最后调用 <code>createControlClass(patchPath, ctClass)</code>、<code>createPatchesInfoClass(patchPath);</code>生成 PatchesInfoImpl、xxxPatchControl 写入补丁信息和控制补丁行为。</p>
<p>其中，<code>PatchesInfoImpl</code>中包含所有补丁类的一一对应关系，比如 <code>MainActivity -&gt; MainActivityPatch</code>，不清楚的可以参考该系列的上一篇文章。生成的<code>xxxPatchControl</code>类用于生成<code>xxPatch</code>类，并判断补丁中的方法是否和methods.robust中的方法id匹配，如果匹配才会去调用补丁中方法。</p>
<p>至此整体流程基本梳理完成。后面会针对具体的复杂情况加以解析。</p>
<h1 id="this-如何处理"><a href="#this-如何处理" class="headerlink" title="this 如何处理"></a>this 如何处理</h1><p>首先，在补丁类中 xxPatch 中，<code>this</code>指代的是xxPatch类的对象，而我们是想要的对象是被补丁的类的对象。</p>
<p>在<code>PatchesFactory.createPatchClass()</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">CtMethod reaLParameterMethod = CtMethod.make(JavaUtils.getRealParamtersBody(), temPatchClass);</div><div class="line">temPatchClass.addMethod(reaLParameterMethod);</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getRealParamtersBody</span><span class="params">()</span> </span>&#123;</div><div class="line">    StringBuilder realParameterBuilder = <span class="keyword">new</span> StringBuilder();</div><div class="line">    realParameterBuilder.append(<span class="string">"public  Object[] "</span> + Constants.GET_REAL_PARAMETER + <span class="string">" (Object[] args)&#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"if (args == null || args.length &lt; 1) &#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" return args;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"&#125;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" Object[] realParameter = new Object[args.length];"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"for (int i = 0; i &lt; args.length; i++) &#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"if (args[i] instanceof Object[]) &#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"realParameter[i] ="</span> + Constants.GET_REAL_PARAMETER + <span class="string">"((Object[]) args[i]);"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"&#125; else &#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"if (args[i] ==this) &#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" realParameter[i] =this."</span> + ORIGINCLASS + <span class="string">";"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"&#125; else &#123;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" realParameter[i] = args[i];"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" &#125;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" &#125;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" &#125;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">"  return realParameter;"</span>);</div><div class="line">    realParameterBuilder.append(<span class="string">" &#125;"</span>);</div><div class="line">    <span class="keyword">return</span> realParameterBuilder.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段的作用是，在每个xxPatch补丁类中都插入一个<code>getRealParameter()</code>方法，反编译出来最终的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Object[] getRealParameter(Object[] objArr) &#123;</div><div class="line">    <span class="keyword">if</span> (objArr == <span class="keyword">null</span> || objArr.length &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> objArr;</div><div class="line">    &#125;</div><div class="line">    Object[] objArr2 = <span class="keyword">new</span> Object[objArr.length];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objArr.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (objArr[i] <span class="keyword">instanceof</span> Object[]) &#123;</div><div class="line">            objArr2[i] = getRealParameter((Object[]) objArr[i]);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objArr[i] == <span class="keyword">this</span>) &#123;</div><div class="line">            objArr2[i] = <span class="keyword">this</span>.originClass;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            objArr2[i] = objArr[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> objArr2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的作用是，在每个xxPatch中使用的<code>this</code>，都转换成xx被补丁类的对象。其中的<code>originClass</code>就是补丁类的对象。</p>
<h1 id="super-如何处理"><a href="#super-如何处理" class="headerlink" title="super 如何处理"></a>super 如何处理</h1><p>同<code>this</code>类似，xxPatch中调用 <code>super</code> 方法同样需要转为调用被补丁类中相关方法的<code>super</code>调用。</p>
<p>还是在<code>PatchesFactory.createPatchClass()</code>方法中有<code>dealWithSuperMethod(temPatchClass, modifiedClass, patchPath);</code>调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dealWithSuperMethod</span><span class="params">(CtClass patchClass, CtClass modifiedClass, String patchPath)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException, IOException </span>&#123;</div><div class="line">    ...</div><div class="line">    methodBuilder.append(<span class="string">"public  static "</span> + invokeSuperMethodList.get(index).getReturnType().getName() + <span class="string">"  "</span> + ReflectUtils.getStaticSuperMethodName(invokeSuperMethodList.get(index).getName()) + <span class="string">"("</span> + patchClass.getName() + <span class="string">" patchInstance,"</span> + modifiedClass.getName() + <span class="string">" modifiedInstance,"</span> + JavaUtils.getParameterSignure(invokeSuperMethodList.get(index)) + <span class="string">")&#123;"</span>);</div><div class="line">    ...</div><div class="line">    CtClass assistClass = PatchesAssistFactory.createAssistClass(modifiedClass, patchClass.getName(), invokeSuperMethodList.get(index));</div><div class="line">    ...</div><div class="line">    methodBuilder.append(NameManger.getInstance().getAssistClassName(patchClass.getName()) + <span class="string">"."</span> + ReflectUtils.getStaticSuperMethodName(invokeSuperMethodList.get(index).getName())  + <span class="string">"(patchInstance,modifiedInstance"</span>);</div><div class="line">    ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>保留主要代码，根据方法签名生成了一个新的方法，以<code>staticRobust+methodName</code>命名，方法中调用以<code>RobustAssist</code>结尾的类中的同名方法，并调用 <code>PatchesAssistFactory.createAssistClass</code> 方法生成该类，这个类的父类是被补丁类的父类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">PatchesAssistFactory.createAssistClass:</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">createAssistClass</span><span class="params">(CtClass modifiedClass, String patchClassName, CtMethod removeMethod)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    staticMethodBuidler.append(<span class="string">"public static  "</span> + removeMethod.returnType.name + <span class="string">"   "</span> + ReflectUtils.getStaticSuperMethodName(removeMethod.getName())</div><div class="line">            + <span class="string">"("</span> + patchClassName + <span class="string">" patchInstance,"</span> + modifiedClass.getName() + <span class="string">" modifiedInstance)&#123;"</span>);</div><div class="line">                </div><div class="line">    staticMethodBuidler.append(<span class="string">" return patchInstance."</span> + removeMethod.getName() + <span class="string">"("</span> + JavaUtils.getParameterValue(removeMethod.getParameterTypes().length) + <span class="string">");"</span>);</div><div class="line">    staticMethodBuidler.append(<span class="string">"&#125;"</span>);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在遍历<code>MethodCall</code>过程中，处理方法调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">m.replace(ReflectUtils.invokeSuperString(m, firstVariable));</div><div class="line">...</div><div class="line"><span class="function">def <span class="keyword">static</span> String <span class="title">invokeSuperString</span><span class="params">(MethodCall m, String originClass)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    stringBuilder.append(getStaticSuperMethodName(m.methodName) + <span class="string">"(this,"</span> + Constants.ORIGINCLASS + <span class="string">",\$\$);"</span>);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>传递的参数，patch、originClass（被补丁类对象）、方法实际参数列表。</p>
<p>反编译出的结果实际是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">MainFragmentActivity:</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(bundle);</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">MainFragmentActivityPatch:</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticRobustonCreate</span><span class="params">(MainFragmentActivityPatch mainFragmentActivityPatch, MainFragmentActivity mainFragmentActivity, Bundle bundle)</span> </span>&#123;</div><div class="line">    MainFragmentActivityPatchRobustAssist.staticRobustonCreate(mainFragmentActivityPatch, mainFragmentActivity, bundle);</div><div class="line">&#125;</div><div class="line"></div><div class="line">MainFragmentActivityPatchRobustAssist:</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragmentActivityPatchRobustAssist</span> <span class="keyword">extends</span> <span class="title">WrapperAppCompatFragmentActivity</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticRobustonCreate</span><span class="params">(MainFragmentActivityPatch mainFragmentActivityPatch, MainFragmentActivity mainFragmentActivity, Bundle bundle)</span> </span>&#123;</div><div class="line">        mainFragmentActivityPatch.onCreate(bundler);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数是按照实际的方法参数传进去的，最后调用了xxPatch.superMethod方法。但是这样也并没有实现<code>super</code>方法的转义啊，再往下看。</p>
<p>在处理smali过程中，有这么一段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">invokeSuperMethodInSmali</span><span class="params">(<span class="keyword">final</span> String line, String fullClassName)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    result = line.replace(Constants.SMALI_INVOKE_VIRTUAL_COMMAND, Constants.SMALI_INVOKE_SUPER_COMMAND);</div><div class="line">    ...</div><div class="line">    result = result.replace(<span class="string">"p0"</span>, <span class="string">"p1"</span>);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在处理之前，smali是长这样的：<code>invoke-invoke-virtual {p0, p2}, Lcom/meituan/robust/patch/SecondActivityPatch;-&gt;onCreate(Landroid/os/Bundle;)V</code>,<br>处理之后是这样的：<code>invoke-super {p1, p2}, Landroid/support/v7/app/AppCompatActivity;-&gt;onCreate(Landroid/os/Bundle;)V</code>，意思就是本来是调用正常方法，现在转为调用super方法，并且把参数换了一下，把p0(补丁类对象)换成了p1（被补丁类对象），这样就完成了<code>super</code>的处理。反编译后最终结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragmentActivityPatchRobustAssist</span> <span class="keyword">extends</span> <span class="title">WrapperAppCompatFragmentActivity</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticRobustonCreate</span><span class="params">(MainFragmentActivityPatch mainFragmentActivityPatch, MainFragmentActivity mainFragmentActivity, Bundle bundle)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(bundle);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="内联怎么处理"><a href="#内联怎么处理" class="headerlink" title="内联怎么处理"></a>内联怎么处理</h1><p>内联是个广义的概念，包括了混淆过程中的优化(修改方法签名、删除方法等)、内联。在上面的分析中处理zi方法基本也提到了，缺啥补啥：就是把内联掉的方法再补回来。<br>对于内联的方法，不能用<code>@Modify</code>注解标注，只能使用<code>RobustModify.modify()</code>标注，因为在基础包中方法都没了，打了l补丁方法也没用。</p>
<p>主要逻辑在遍历<code>MethodCall</code> -&gt; <code>repalceInlineMethod()</code> -&gt; <code>ReflectUtils.getInLineMemberString()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">stringBuilder.append(<span class="string">" instance=new "</span> + NameManger.getInstance().getInlinePatchName(method.declaringClass.name) + <span class="string">"(\$0);"</span>)</div><div class="line">stringBuilder.append(<span class="string">"\$_=(\$r)instance."</span> + getInLineMethodName(method) + <span class="string">"("</span> + parameterBuilder.toString() + <span class="string">");"</span>)</div><div class="line">...</div></pre></td></tr></table></figure>
<p>作用就是把内联掉的方法调用替换为InLine类中的新增方法。</p>
<p>结果就是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String first=<span class="keyword">null</span>;</div><div class="line">    <span class="comment">//privateMethod被内联了</span></div><div class="line">    <span class="comment">// private void privateMethod(String fir)&#123;</span></div><div class="line">    <span class="comment">//    System.out.println(fir);</span></div><div class="line">    <span class="comment">//&#125;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(String fir)</span></span>&#123;</div><div class="line">        first=fir;</div><div class="line">        Parent children=<span class="keyword">new</span> Children();</div><div class="line">        <span class="comment">//children.privateMethod("Robust");</span></div><div class="line">        <span class="comment">//内联替换的逻辑</span></div><div class="line">        ParentInline inline= <span class="keyword">new</span> ParentInline(children);</div><div class="line">        inline.privateMethod(<span class="string">"Robust"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentInline</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Parent children ;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentInline</span><span class="params">(Parent p)</span></span>&#123;</div><div class="line">       children=p;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//混淆为c</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">(String fir)</span></span>&#123;</div><div class="line">        System.out.println(fir);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Robust 的核心其实就是自动化生成补丁这块，至于插庄、补丁加载这些都是很好实现的，因为没有很多的特殊情况需要处理。<br>这篇文章主要分析了自动化补丁插件的主要工作流程，和一些特殊情况的处理，文章有限，当然还有很多特殊情况没有分析，这里只是提供一些分析源码的思路，碰到特殊情况可以按照这个思路排查解决问题。</p>
<p>就像代码中有一行注释，我觉得特别能概括自动化生成补丁的团队的心里路程，在此也再次感谢美团团队对开源做出的贡献。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  shit !!too many situations need take into  consideration</span></div></pre></td></tr></table></figure></p>
<p>总体来说，Robust 坑是有的，但是它也是高可用性、高兼容性的热修复框架，尤其是在Android 系统开放性越来越收紧的趋势下，Robust  作为不 hook 系统 API 的热修复框架优势更加突出。虽然其中可能有一些坑，只要我们对原理熟悉掌握，才有信心能搞定这些问题。</p>
<p>下一篇文章，主要就讲下Robust与其他框架搭配使用出现的一些坑。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://tech.meituan.com/android_autopatch.html" target="_blank" rel="external">Android热更新方案Robust开源，新增自动化补丁工具</a></li>
<li><a href="https://www.jianshu.com/p/b9b3ff0e1bf8" target="_blank" rel="external">Javassist 使用指南（二）</a></li>
<li><a href="https://juejin.im/entry/579ef6e37db2a2005a6350d8" target="_blank" rel="external">[转] 深入理解 Dalvik 字节码指令及 Smali 文件</a></li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2018/05/28/robust-1/">http://w4lle.com/2018/05/28/robust-1/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Android 热补丁框架 Robust 中，几个重要的流程包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;补丁加载过程&lt;/li&gt;
&lt;li&gt;基础包插桩过程&lt;/li&gt;
&lt;li&gt;补丁包生成过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上一篇文章&lt;a href=&quot;http://w4lle.com/2017/03/31/robust-0/&quot;&gt;Android热补丁之Robust原理解析(一)&lt;/a&gt;中，我们分析了前两个，补丁加载过程和基础包插桩过程，分析的版本为 &lt;code&gt;0.3.2&lt;/code&gt;。&lt;br&gt;该篇文章为该系列的第二篇文章，主要分析补丁自动化生成的过程，分析的版本为&lt;code&gt;0.4.82&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
      <category term="热补丁" scheme="http://w4lle.com/tags/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>使用 Python 处理 pdf</title>
    <link href="http://w4lle.com/2018/02/02/python-pdf/"/>
    <id>http://w4lle.com/2018/02/02/python-pdf/</id>
    <published>2018-02-02T01:34:45.000Z</published>
    <updated>2018-02-05T01:33:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近老婆工作中碰到一些困难，总是跟我抱怨工作好烦，不开心。<br>主要是是因为要处理一些报告，这些 pdf 格式的样本报告比较多，基本都是人工操作比较容易出错，也比较琐碎，好心情都被磨没了。</p>
<p>然后我说要么写个小程序吧，帮你处理这些琐碎的工作，然后就大概梳理了一下主要需求：</p>
<a id="more"></a>
<p>内部报告：</p>
<ol>
<li>首先需要从系统出导出一个大的 pdf，包含很多小的 pdf</li>
<li>每个小的 pdf 报告中包含一些信息，比如 报告标题、姓名、编号、医院、总页数</li>
<li>拿到这些信息之后，分割大的 pdf，将小的 pdf 报告剥离处理</li>
<li>然后重命名这些报告，格式为 <code>姓名-编号.pdf</code></li>
<li>将这些报告移动到对应医院的目录下，然后将这些医院目录压缩</li>
</ol>
<p>外部报告：</p>
<ol>
<li>外部会发过来压缩包，其中包含单个的 pdf 报告</li>
<li>解压缩后将报告拿出来，提取其中的信息，信息基本同内部报告</li>
<li>重命名</li>
<li>移动到对应的医院目录下，并压缩</li>
</ol>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>人生苦短，我用python。<br>嗯，python大法好，处理这些琐碎的事情写个 python 脚本跑一下不就好了吗。<br>python 版本使用的python 3.x。</p>
<p>梳理了下输球，首先需要解析大 pdf 中的一些关键信息，转化为我们需要的报告信息，首先写个Model叫做 <code>Sample</code>，包含 title、number、name、total_page、hospital 等等，然后依次解析 pdf 生成组成 samples 列表，最后根据报告列表分割处理pdf 就好了。</p>
<h2 id="解析-pdf"><a href="#解析-pdf" class="headerlink" title="解析 pdf"></a>解析 pdf</h2><p>有个 python 库叫做 <a href="https://github.com/euske/pdfminer" target="_blank" rel="external">pdfminer</a>，这个库已经不支持python 3.x 版本了，该项目注明了可以使用 <a href="https://github.com/pdfminer/pdfminer.six" target="_blank" rel="external">pdfminer.six</a>来支持3.x的版本。</p>
<p>基本语法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_samples</span><span class="params">()</span>:</span></div><div class="line">    fp = open(get_origin_report_path(), <span class="string">'rb'</span>)  <span class="comment"># 以二进制读模式打开</span></div><div class="line">    <span class="comment"># 用文件对象来创建一个pdf文档分析器</span></div><div class="line">    praser = PDFParser(fp)</div><div class="line">    <span class="comment"># 创建一个PDF文档</span></div><div class="line">    doc = PDFDocument()</div><div class="line">    <span class="comment"># 连接分析器 与文档对象</span></div><div class="line">    praser.set_document(doc)</div><div class="line">    doc.set_parser(praser)</div><div class="line"></div><div class="line">    <span class="comment"># 提供初始化密码</span></div><div class="line">    <span class="comment"># 如果没有密码 就创建一个空的字符串</span></div><div class="line">    doc.initialize()</div><div class="line"></div><div class="line">    <span class="comment"># 检测文档是否提供txt转换，不提供就忽略</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> doc.is_extractable:</div><div class="line">        <span class="keyword">raise</span> PDFTextExtractionNotAllowed</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="comment"># 创建PDf 资源管理器 来管理共享资源</span></div><div class="line">        rsrcmgr = PDFResourceManager()</div><div class="line">        <span class="comment"># 创建一个PDF设备对象</span></div><div class="line">        laparams = LAParams()</div><div class="line">        device = PDFPageAggregator(rsrcmgr, laparams=laparams)</div><div class="line">        <span class="comment"># 创建一个PDF解释器对象</span></div><div class="line">        interpreter = PDFPageInterpreter(rsrcmgr, device)</div><div class="line"></div><div class="line">        <span class="comment"># 循环遍历列表，每次处理一个page的内容</span></div><div class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> doc.get_pages():  <span class="comment"># doc.get_pages() 获取page列表</span></div><div class="line">            number_index = <span class="number">0</span></div><div class="line">            name_index = <span class="number">0</span></div><div class="line">            sample = Sample()</div><div class="line">            interpreter.process_page(page)</div><div class="line">            <span class="comment"># 接受该页面的LTPage对象</span></div><div class="line">            layout = device.get_result()</div><div class="line">            <span class="comment"># 这里layout是一个LTPage对象 里面存放着 这个page解析出的各种对象 一般包括LTTextBox, LTFigure, LTImage, LTTextBoxHorizontal 等等 想要获取文本就获得对象的text属性，</span></div><div class="line">            <span class="keyword">for</span> index, out <span class="keyword">in</span> enumerate(layout):</div><div class="line">                <span class="comment"># if hasattr(out, "get_text"):</span></div><div class="line">                <span class="comment"># if (isinstance(out, LTTextBoxHorizontal)):</span></div><div class="line">                <span class="keyword">if</span> (isinstance(out, LTTextBox)):</div><div class="line">                    <span class="keyword">with</span> open(get_log_path(), <span class="string">'a'</span>) <span class="keyword">as</span> outfile:</div><div class="line">                        results = out.get_text().replace(<span class="string">u'\xa0'</span>, <span class="string">u' '</span>)</div><div class="line">                        parse()</div><div class="line">                        ...</div><div class="line">                        ....</div></pre></td></tr></table></figure>
<p>官网给出的 layout 布局</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/pdfminer_layout.png" alt="layout"></p>
<p>我们主要拿其中的文本信息，所以拿到每一页 pdf 的LTPage后，遍历其中的包含 text 属性的控件就好了，拿到文本信息，根据正则匹配到关心的文本信息，赋值给新建的<code>sample</code>，依次循环，最后组成 <code>samples</code> 报告列表给后面使用。<br>解析完了后就需要处理 pdf 了。</p>
<h3 id="分割-pdf"><a href="#分割-pdf" class="headerlink" title="分割 pdf"></a>分割 pdf</h3><p>首先要做的是将大的 pdf 分割成小的 pdf，搜了下分割 pdf 有个python 库叫做 <a href="https://pythonhosted.org/PyPDF2/" target="_blank" rel="external">PyPDF2</a>，参考API 写了一个工具方法用来分割 pdf。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_pdf</span><span class="params">(infn, outfn, start_page, end_page)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    分割pdf文档，如果需要的话</div><div class="line"></div><div class="line">    :param infn: 源报告目录</div><div class="line">    :param outfn: 分割后输出文档目录</div><div class="line">    :param start_page:</div><div class="line">    :param end_page:</div><div class="line">    :return:</div><div class="line">    """</div><div class="line">    pdf_output = PdfFileWriter()</div><div class="line">    pdf_input = PdfFileReader(open(infn, <span class="string">'rb'</span>))</div><div class="line">    <span class="comment"># 获取 pdf 共用多少页</span></div><div class="line">    page_count = pdf_input.getNumPages()</div><div class="line">    <span class="comment"># 将 pdf 的分割页面，输出到一个新的文件</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start_page, end_page):</div><div class="line">        pdf_output.addPage(pdf_input.getPage(i))</div><div class="line">    pdf_output.write(open(outfn, <span class="string">'wb'</span>))</div><div class="line">    print(<span class="string">'---分割pdf完毕--'</span>)</div></pre></td></tr></table></figure>
<p>根据第一步得出的 samples，循环一下拿出其中的total_page，依次分割就好了。</p>
<p>最后就是重命名、移动、压缩，不写了。</p>
<h1 id="打包成-exe-可执行文件"><a href="#打包成-exe-可执行文件" class="headerlink" title="打包成 exe 可执行文件"></a>打包成 exe 可执行文件</h1><p>老婆使用的是 Windowns，所以最后要打包成 <code>.exe</code> 可执行文件，搜了下 pyinstaller 可以解决，但是还是需要在对应的平台才能打出对应平台的可执行文件，可就是说想要打出 <code>.exe</code> 必须在 Windows 下打包，这就有点蛋疼了。然后弄了一下，发现 Windows 用来做开发真的是难用无比。<br>最后也没打 <code>.exe</code>，直接在 Windows 下装了python，双击 <code>.py</code> 文件好了，有bug的话替换一下文件好了，不用重新打包。</p>
<h1 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h1><p>项目交付老婆使用后，极其的好用，大幅提升了工作效率，减少出错概率，老婆甚至发了个朋友圈夸奖了一番，感觉美滋滋。</p>
<p>美了不到两天就出 bug 了。</p>
<p>bug是这样的，比如有个编号<code>编号：G201802020108</code> 正常解析出来 <code>sample.number = G201802020108</code> 才对，但是结果可能是这样的<code>G20180202</code>，后面少了几位。拿到原始的大 pdf 跑了一遍发现确实是这样，每个 pdf 在解析时我都把文本信息存了下来以便查问题用，这时派上了用场，打开看了下文本信息被这样处理了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">编号：G20180202</div><div class="line"><span class="number">0108</span></div></pre></td></tr></table></figure>
<p>本来在一行或者说在一个 <code>LTTextBox</code> 中的内容被分割成了两个，所以出现了内容少的问题。</p>
<p>找到了问题原因就好处理了。<br>首先想到了一个方案，每个 <code>LTxx</code> 控件在当页 pdf 中的位置由坐标表示，左上角坐标是 <code>{x0:0,y0:0, x1:0,y1:0}</code>，只要框住了编号信息所在的坐标范围，只要在该范围内的，所有文本信息 append 一下然后再正则匹配就好了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">in_number_area</span><span class="params">(text_box)</span>:</span></div><div class="line">    <span class="comment"># x0,y0,x1,y1</span></div><div class="line">    scope = (<span class="number">370</span>, <span class="number">700</span>, <span class="number">560</span>, <span class="number">740</span>)</div><div class="line">    <span class="keyword">if</span> in_area(text_box.bbox, scope):</div><div class="line">        print(<span class="string">'样本编号匹配！坐标点：'</span>, text_box.bbox)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    </div><div class="line"></div><div class="line"><span class="comment"># 判断TextBox坐标范围是否在规定范围内</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">in_area</span><span class="params">(bbox, scope)</span>:</span></div><div class="line">    <span class="keyword">if</span> bbox[<span class="number">0</span>] &gt; scope[<span class="number">0</span>] <span class="keyword">and</span> bbox[<span class="number">1</span>] &gt; scope[<span class="number">1</span>] <span class="keyword">and</span> bbox[<span class="number">2</span>] &lt; scope[<span class="number">2</span>] <span class="keyword">and</span> bbox[<span class="number">3</span>] &lt; scope[<span class="number">3</span>]:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>给定固定坐标范围，找到在该坐标范围内的控件，然后再去匹配。</p>
<p>跑了一下确实生效了，但是问题依然没有解决，为什么呢？因为报告种类不一，导致格式就不一样，坐标范围也不一样，也就是说不能动态的找到坐标范围。该方案失败。</p>
<p>于是又想到了第二个方案，直接看代码吧</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 解析编号</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> utils.number_legal_for_internal(sample.number):</div><div class="line">    num = utils.parse_sample_num(results)</div><div class="line">    <span class="keyword">if</span> num:</div><div class="line">        number_index = index</div><div class="line">        sample.number = num</div><div class="line">        <span class="keyword">continue</span></div><div class="line">    <span class="comment"># 解决编号被分成两段的问题</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> utils.number_legal_for_internal(sample.number) <span class="keyword">and</span> number_index <span class="keyword">and</span> (</div><div class="line">            index == number_index + <span class="number">1</span> <span class="keyword">or</span> index == number_index + <span class="number">2</span>):</div><div class="line">        print(<span class="string">'修正后的编号：'</span>)</div><div class="line">        num = utils.parse_sample_num(<span class="string">'样本编号：'</span> + sample.number + results)</div><div class="line">        sample.number = num</div><div class="line">        <span class="keyword">if</span> utils.number_legal_for_internal(num):</div><div class="line">            number_index = <span class="number">0</span></div><div class="line">            <span class="keyword">continue</span></div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>基本解决。</p>
<p>其实第二个方案也不太完美，为什么呢？编号还好说，一般都是字母加数字，如果出现这个bug一般都能比较好判断是否合法，比如编号长度 &gt;=11，但是，如果是名字呢，就没有很好的合法规则来判断，比如<code>名字：张三丰</code>，<code>丰</code>字被分割了，而合法判断是名字长度 &gt;=2，那最后结果就是<code>张三</code>而不是<code>张三丰</code>。</p>
<p>所以，其实还有一个优化方案，在方案一和方案二的基础上，第一步先匹配关键字，比如<code>姓名：</code>，匹配到了以后再框定坐标范围，一般名字都是6字以内，编号是20位以内，划定坐标范围后将范围内的匹配控件文本信息都拿出来再一起解析。基本做到了动态判断坐标范围。</p>
<p>外部报告跟内部报告基本是一样的，区别是首先需要解压一下，然后解析、处理，不写了。</p>
<h1 id="还有哪些可以做"><a href="#还有哪些可以做" class="headerlink" title="还有哪些可以做"></a>还有哪些可以做</h1><p>前面写了怎么解析处理pdf，其实还有一部分工作也可以用脚本来处理，比如，大的pdf 下载可以通过脚本处理；处理好的 pdf 报告要通过邮件法发送给客户，也可以通过脚本处理；有时还需要把解析出的信息填到表格中，也是可以用脚本处理的。</p>
<p>总结下来一共有这几个功能：</p>
<ul>
<li>爬虫，从系统中导出大的 pdf 报告</li>
<li>pdf 解析和分割</li>
<li>归类，压缩</li>
<li>生成表格</li>
<li>发送邮件</li>
</ul>
<p>目前只做了2 和3 ，其余的有时间慢慢写。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>为什么写这篇文章呢？<br>其实用到的东西很简单，看几分钟 python 入门然后再找两个开源库就搞定了，也没必要记录什么技术知识点。<br>我真正想说的是一些感悟，程序员碰到这种问题一般都会想办法写一些脚本处理，没什么稀奇的。但是对于不会写程序的人来说，有这个程序和没有这个程序简直就是不一样的工作，就拿这件事来说，用了这个程序之后，我老婆的工作效率明显提升，每天能节省出1-2小时时间做别的事情，从交付那天起，基本没听过老婆再抱怨工作了。简直开心。</p>
<p>还有就是以前总感觉程序员这个工作对生活的帮助简直就是没啥用，比如，你看谁谁现在是医生，去医院都不用挂号，直接就能看病；谁谁是老师，孩子上学的事情根本不用愁等等诸如此类，职业除了能养活自己之外能够反哺生活，在生活中提供一些价值。反观程序员对生活上的帮助简直就是0，甚至可以说是负数。</p>
<p>现在是高速发展的信息时代，干什么工作都离不开手机、电脑，甚至人工智能在某些方面都开始取代人力去做一些工作，所以我觉得越来越能体现出程序员的价值，可以控制机器取代人工去做一些重复性的、机械性的工作，所以在有能力的前提下学习一些开发知识会大有裨益。就像每个人都学英语一样，在未来，编程也有可能是一门基础学科，每个人都应该掌握。</p>
<p>回到现在，简单的用一些简单的脚本提升生活幸福感，把这些烦人的工作交给机器去做，人类最擅长的是浪费时间，恩。</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/machine_time1.jpg" alt=""></p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/machine_time2.jpg" alt=""></p>
<p>本文链接： <a href="http://w4lle.com/2018/02/02/python-pdf/">http://w4lle.com/2018/02/02/python-pdf/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近老婆工作中碰到一些困难，总是跟我抱怨工作好烦，不开心。&lt;br&gt;主要是是因为要处理一些报告，这些 pdf 格式的样本报告比较多，基本都是人工操作比较容易出错，也比较琐碎，好心情都被磨没了。&lt;/p&gt;
&lt;p&gt;然后我说要么写个小程序吧，帮你处理这些琐碎的工作，然后就大概梳理了一下主要需求：&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://w4lle.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="其他" scheme="http://w4lle.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>区块链（一）区块链和以太坊</title>
    <link href="http://w4lle.com/2017/10/27/ethereum-0/"/>
    <id>http://w4lle.com/2017/10/27/ethereum-0/</id>
    <published>2017-10-27T11:37:06.000Z</published>
    <updated>2017-10-27T13:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区块链是什么"><a href="#区块链是什么" class="headerlink" title="区块链是什么"></a>区块链是什么</h1><blockquote>
<p>区块链（英语：blockchain 或 block chain）是用分布式数据库识别、传播和记载信息的智能化对等网络, 也称为价值互联网。中本聪在2008年，于《比特币白皮书》中提出“区块链”概念，并在2009年创立了比特币社会网络，开发出第一个区块，即“创世区块”。</p>
</blockquote>
<a id="more"></a>
<p>区块链，简单的讲就是一个分布式存储的一个大账本，由一条条的交易记录（block）组成，并且任何人都可以拥有这个账本并且可以存储交易记录，几乎在同一时间这条记录就会被同步到全世界的副本上，这就使得没有人能够修改本地账本中的记录，使其拥有了去中心化的能力。可以理解为这就是区块链技术的基本内容，比特币和以太坊和其他代币都是以此为基础。最有名气的就属比特币了。</p>
<p>考虑现实生活，比如想去找一个陌生人借钱，那么就必须有一个双方都认可的第三方存在，比如银行。由于区块链的存在，这个第三方就可以不需要了。比如，我要借给 A 一块钱，我要在账本上写一条，我要借给 A 一块钱，首先会去检查你有没有一块钱，如果有的话就会记录下来，并且同时在你的账户中扣掉一块钱同时在 A 的账户中增加一块钱，同时同步到所有持有该账本的账户上。</p>
<p>因此，区块链具有以下特点：</p>
<ul>
<li>去中心化</li>
<li>分布式</li>
<li>密码性安全</li>
</ul>
<h1 id="以太坊是什么"><a href="#以太坊是什么" class="headerlink" title="以太坊是什么"></a>以太坊是什么</h1><blockquote>
<p>以太坊是一个全新开放的区块链平台，它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。</p>
</blockquote>
<p>以太坊相比于区块链有了更进一步的发展，它可以在链上创建一些自动运行的程序称之为智能合约，只要这个智能合约发布到了链上，任何人都无法修改它，并且它是对任何人透明的，任何人都可以看到其代码。任何人都可以发布智能合约，编写智能合约所使用的高级语言也是图灵完备的（意味着语言可以使用计图灵机完成任何图灵机可以完成的任务），这就使得这是可编程的，任何人支付一笔费用 (Gas) 都可以部署编写的智能合约供其他人使用。</p>
<p>考虑现实生活，比如说使用基于以太坊的智能合约存钱，该合约约定月利率1%，那么假如我存了100块钱进去，一个月后来取，那么我能取到的金额必然是 100 + 100 * 0.01。</p>
<p>所以相对于区块链，以太坊多了两个特点：</p>
<ul>
<li>智能合约</li>
<li>图灵完备</li>
</ul>
<h1 id="挖矿是怎么回事？"><a href="#挖矿是怎么回事？" class="headerlink" title="挖矿是怎么回事？"></a>挖矿是怎么回事？</h1><p>以太坊的本质就是一个基于交易的状态机(transaction-based state machine)。以太坊的状态包含很多交易，这些交易被打包到区块中（block），也就是说每个 block 包含了一系列的交易，每个区块与它的前一个区块链接起来组成区块链。<br><img src="http://7xs23g.com1.z0.glb.clouddn.com/blockchain.png" alt="blockchain"><br>为了让交易被认为是有效的，都必须要经历一个验证的过程，这个过程其实就是挖矿。挖矿实际上就是矿工用他们的计算资源来创建一个包含有效交易的区块出来。然而当你在计算区块的时候别的矿工同样也在计算，如果大家同时提交的话，怎么证明谁的区块是有效的？所以在提交区块到区块链上时，都需要提供一个数学机制的证明，称之为工作量证明（proof of work），所以一个矿工必须要比其他矿工更快的提供出这个证明来抢占区块的有效性将之合并到区块两上，与此同时，别的矿工会及时的将区块链的状态更新至最新。证实了一个新区块的矿工都会被奖励一定价值的奖赏。奖赏就是以太坊使的用一种内在数字代币—以太币(Ether)。</p>
<p>另外，以太坊和区块链的架构不同在于，以太坊区块不仅包含交易记录和最近的状态，还包含区块序号和难度值。</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/ethereum-blockchain.png" alt=""></p>
<h1 id="我们能用来干嘛"><a href="#我们能用来干嘛" class="headerlink" title="我们能用来干嘛"></a>我们能用来干嘛</h1><p>我们公司 1024 程序员节当天搞了个 HackathonDay 活动，我们报名参加了下，并且选题就是基于区块链的实际应用，虽然基本只有一天的时间来学习区块链的相关知识，我们还是做出了一些 Demo，基本算是入门。<br>所以接下来的文章会写到基于以太坊搭建一个私有链、创建账户、进行挖矿、进行转账交易、基于 Solidity 语言编写智能合约、部署到区块链上、编写 DApp 来使用智能合约等等。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://github.com/ethereum/wiki/wiki/%5B%E4%B8%AD%E6%96%87%5D-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6" target="_blank" rel="external">以太坊白皮书</a></li>
<li><a href="http://ethfans.org/posts/how-does-ethereum-work-anyway" target="_blank" rel="external">以太坊的工作原理</a></li>
<li><a href="http://wangxiaoming.com/blog/2016/05/05/blockchain-tech-what-is-blockchain/" target="_blank" rel="external">区块链是什么？</a></li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2017/10/27/ethereum-0/">http://w4lle.com/2017/10/27/ethereum-0/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;区块链是什么&quot;&gt;&lt;a href=&quot;#区块链是什么&quot; class=&quot;headerlink&quot; title=&quot;区块链是什么&quot;&gt;&lt;/a&gt;区块链是什么&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;区块链（英语：blockchain 或 block chain）是用分布式数据库识别、传播和记载信息的智能化对等网络, 也称为价值互联网。中本聪在2008年，于《比特币白皮书》中提出“区块链”概念，并在2009年创立了比特币社会网络，开发出第一个区块，即“创世区块”。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="区块链" scheme="http://w4lle.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>热修复总结</title>
    <link href="http://w4lle.com/2017/05/04/hotpatch-summary/"/>
    <id>http://w4lle.com/2017/05/04/hotpatch-summary/</id>
    <published>2017-05-04T10:45:31.000Z</published>
    <updated>2017-05-15T02:51:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="热修复总结"><a href="#热修复总结" class="headerlink" title="热修复总结"></a>热修复总结</h1><table>
<thead>
<tr>
<th style="text-align:center">平台</th>
<th style="text-align:center">阿里 AndFix</th>
<th style="text-align:center">阿里 HotFix1.x</th>
<th style="text-align:center">Nuwa</th>
<th style="text-align:center">微信Tinker</th>
<th style="text-align:center">美团Robust</th>
<th style="text-align:center">阿里 HotFix2.x</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">即时生效</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">看情况</td>
</tr>
<tr>
<td style="text-align:center">性能损耗</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较大</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较小</td>
</tr>
<tr>
<td style="text-align:center">补丁包大小</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">较大</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较小</td>
</tr>
<tr>
<td style="text-align:center">占Rom体积</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">较大</td>
<td style="text-align:center">较小</td>
<td style="text-align:center">看情况</td>
</tr>
<tr>
<td style="text-align:center">接入复杂度</td>
<td style="text-align:center">简单</td>
<td style="text-align:center">简单</td>
<td style="text-align:center">简单</td>
<td style="text-align:center">复杂</td>
<td style="text-align:center">简单</td>
<td style="text-align:center">简单</td>
</tr>
<tr>
<td style="text-align:center">安全校验</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">类替换</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">资源替换</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">即将支持</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">so替换</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">即将支持</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">全平台支持</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">开发透明</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">gradle支持</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">接口文档</td>
<td style="text-align:center">较少</td>
<td style="text-align:center">丰富</td>
<td style="text-align:center">较少</td>
<td style="text-align:center">丰富</td>
<td style="text-align:center">丰富</td>
<td style="text-align:center">丰富</td>
</tr>
<tr>
<td style="text-align:center">成功率</td>
<td style="text-align:center">较低</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">较高</td>
<td style="text-align:center">最高</td>
<td style="text-align:center">较高</td>
</tr>
<tr>
<td style="text-align:center">后台管理</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">加固兼容</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">部分兼容</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">不确定</td>
</tr>
</tbody>
</table>
<p>上表基本涵盖了具有代表性的各种热修复方案，涉及到的各种关键指标的横向对比。</p>
<p>Slider 中大概总结了各种方案的实现方式，以及常见的问题。</p>
<p>Slider 地址： <a href="http://w4lle.github.io/sliders/hot-fix/index.html" target="_blank" rel="external">http://w4lle.github.io/sliders/hot-fix/index.html</a></p>
<p>详细的各种方案分析：</p>
<ul>
<li><a href="http://w4lle.github.io/2016/03/03/Android%E7%83%AD%E8%A1%A5%E4%B8%81%E4%B9%8BAndFix%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">Android热补丁之AndFix原理解析</a></li>
<li><a href="http://w4lle.github.io/2016/05/02/%E4%BB%8EInstant%20run%E8%B0%88Android%E6%9B%BF%E6%8D%A2Application%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">从Instant run谈Android替换Application和动态加载机制</a></li>
<li><a href="http://w4lle.github.io/2016/12/16/tinker/" target="_blank" rel="external">Android热补丁之Tinker原理解析</a></li>
<li><a href="http://w4lle.github.io/2017/03/31/robust-0/" target="_blank" rel="external">Android热补丁之Robust原理解析(一)</a></li>
</ul>
<p>水平有限，难免有写的不对的地方，欢迎交流。</p>
<p>本文链接： <a href="http://w4lle.com/2017/05/04/hotpatch-summary/">http://w4lle.com/2017/05/04/hotpatch-summary/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;热修复总结&quot;&gt;&lt;a href=&quot;#热修复总结&quot; class=&quot;headerlink&quot; title=&quot;热修复总结&quot;&gt;&lt;/a&gt;热修复总结&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;平台&lt;/th&gt;
&lt;t
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
      <category term="热补丁" scheme="http://w4lle.com/tags/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>Android热补丁之Robust原理解析(一)</title>
    <link href="http://w4lle.com/2017/03/31/robust-0/"/>
    <id>http://w4lle.com/2017/03/31/robust-0/</id>
    <published>2017-03-31T07:58:12.000Z</published>
    <updated>2018-05-29T08:40:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>早在16年9月份，美团技术团队就写过一篇文章描述 Android 热补丁框架Robust的简单实现原理，但是并没有开源；然后在17年3月份，美团团队宣布正式开源 Robust并且配套了自动打补丁包工具。本系列文章主要解析Robust实现原理，分为几个方面</p>
<ul>
<li>补丁加载过程</li>
<li>基础包插桩过程</li>
<li>补丁包生成过程</li>
</ul>
<p>本文为第一篇，主要讲解补丁加载过程和基础包插桩过程，分析版本 <code>0.3.2</code>。</p>
<a id="more"></a>
<p>系列文章:</p>
<ul>
<li><a href="http://w4lle.com/2017/03/31/robust-0/">Android热补丁之Robust原理解析(一)</a></li>
<li><a href="http://w4lle.com/2018/05/28/robust-1/">Android热补丁之Robust（二）自动化补丁原理解析</a></li>
<li><a href="http://w4lle.com/2018/05/29/robust-2/">Android热补丁之Robust（三）坑和解</a></li>
</ul>
<h1 id="从-InstantRun-说起"><a href="#从-InstantRun-说起" class="headerlink" title="从 InstantRun 说起"></a>从 InstantRun 说起</h1><p>不得不说 InstantRun 真是个好东西。目前主流的热修复框架都有或多或少的参考 InstantRun 的某些技术点，比如 <a href="https://github.com/Tencent/tinker" target="_blank" rel="external">Tinker</a> 的官方文章中明确考虑过 InstantRun 中的 Application 替换，虽然最后没有采用，但是身为其兄弟库的 <a href="http://tinkerpatch.com/Docs/intro" target="_blank" rel="external">TinkerPatch</a> 中一键接入方案就采用的该技术点。关于该技术点，可以参考我之前写的一篇文章 <a href="http://w4lle.github.io/2017/01/05/one-key-for-tinker/" target="_blank" rel="external">一键接入Tinker</a> 。</p>
<p>我们知道，InstantRun 对应三种更新机制：</p>
<ul>
<li>冷插拔，我们称之为重启更新机制</li>
<li>温插拔，我们称之为重启Activity更新机制</li>
<li>热插拔，我们称之为热更新机制</li>
</ul>
<p>如果你还不熟悉 InstantRun，请参考我的这篇文章<a href="http://w4lle.github.io/2016/05/02/%E4%BB%8EInstant%20run%E8%B0%88Android%E6%9B%BF%E6%8D%A2Application%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">从Instant run谈Android替换Application和动态加载机制</a></p>
<p>而这篇文章的主角 Robust ，其热修复的关键技术点就是采用了 InstantRun 中的热更新机制，对应于多 ClassLoader 的动态加载方案，即一个 dex 文件对应一个新建 ClassLoader 。</p>
<h1 id="Robust-原理解析"><a href="#Robust-原理解析" class="headerlink" title="Robust 原理解析"></a>Robust 原理解析</h1><p>Robust 的原理可以简单描述为：</p>
<ol>
<li>打基础包时插桩，在每个方法前插入一段类型为 <code>ChangeQuickRedirect</code> 静态变量的逻辑</li>
<li>加载补丁时，从补丁包中读取要替换的类及具体替换的方法实现，新建 ClassLoader 加载补丁dex。</li>
</ol>
<p>我们来分别分析。</p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>打基础包时，Robust 为每个类新增了一个类型为 <code>ChangeQuickRedirect</code> 的静态变量，并且在每个方法前，增加判断该变量是否为空的逻辑，如果不为空，走打基础包时插桩的逻辑，否则走正常逻辑。我们反编译出基础包中的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SecondActivity</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ChangeQuickRedirect u;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (u != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (PatchProxy.isSupport(<span class="keyword">new</span> Object[]&#123;bundle&#125;, <span class="keyword">this</span>, u, <span class="keyword">false</span>, <span class="number">78</span>)) &#123;</div><div class="line">                PatchProxy.accessDispatchVoid(<span class="keyword">new</span> Object[]&#123;bundle&#125;, <span class="keyword">this</span>, u, <span class="keyword">false</span>, <span class="number">78</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">super</span>.onCreate(bundle);</div><div class="line">        ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>对应于补丁文件，需要有三个文件</p>
<ul>
<li><code>PatchesInfoImpl</code> 用于记录修改的类，及其对应的 <code>ChangeQuickRedirect</code> 接口的实现，我们反编译补丁包得出以下结果，其中的类名是混淆后的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatchesInfoImpl</span> <span class="keyword">implements</span> <span class="title">PatchesInfo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">getPatchedClassesInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">        List arrayList = <span class="keyword">new</span> ArrayList();</div><div class="line">        arrayList.add(<span class="keyword">new</span> PatchedClassInfo(<span class="string">"com.meituan.sample.robusttest.l"</span>, <span class="string">"com.meituan.robust.patch.SampleClassPatchControl"</span>));</div><div class="line">        arrayList.add(<span class="keyword">new</span> PatchedClassInfo(<span class="string">"com.meituan.sample.robusttest.p"</span>, <span class="string">"com.meituan.robust.patch.SuperPatchControl"</span>));</div><div class="line">        arrayList.add(<span class="keyword">new</span> PatchedClassInfo(<span class="string">"com.meituan.sample.SecondActivity"</span>, <span class="string">"com.meituan.robust.patch.SecondActivityPatchControl"</span>));</div><div class="line">        EnhancedRobustUtils.isThrowable = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> arrayList;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>xxxPatchControl</code> 是 <code>ChangeQuickRedirect</code> 接口的具体实现，是一个代理，具体的替换方法是在 <code>xxxPatch</code> 类中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivityPatchControl</span> <span class="keyword">implements</span> <span class="title">ChangeQuickRedirect</span> </span>&#123;</div><div class="line">...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSupport</span><span class="params">(String methodName, Object[] paramArrayOfObject)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"78:79:90:"</span>.contains(methodName.split(<span class="string">":"</span>)[<span class="number">3</span>]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">accessDispatch</span><span class="params">(String methodName, Object[] paramArrayOfObject)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            SecondActivityPatch secondActivityPatch;</div><div class="line">            ...</div><div class="line">            Object obj = methodName.split(<span class="string">":"</span>)[<span class="number">3</span>];</div><div class="line">            <span class="keyword">if</span> (<span class="string">"78"</span>.equals(obj)) &#123;</div><div class="line">                secondActivityPatch.onCreate((Bundle) paramArrayOfObject[<span class="number">0</span>]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (<span class="string">"79"</span>.equals(obj)) &#123;</div><div class="line">                <span class="keyword">return</span> secondActivityPatch.getTextInfo((String) paramArrayOfObject[<span class="number">0</span>]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (<span class="string">"90"</span>.equals(obj)) &#123;</div><div class="line">                secondActivityPatch.RobustPubliclambda$onCreate$<span class="number">0</span>((View) paramArrayOfObject[<span class="number">0</span>]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</div><div class="line">            th.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终调用 <code>accessDispatch</code> 方法，该方法会根据传递过来的方法签名，调用<code>xxxPatch</code>的修改过的方法。</p>
<ul>
<li><code>xxxPatch</code> 具体的替换实现类，代码就不贴了。</li>
</ul>
<p>其过程可以简单描述为，下发补丁包后，新建 DexClassLoader 加载补丁 dex 文件，反射得到 <code>PatchesInfoImpl</code> class，并创建其对象，调用 <code>getPatchedClassesInfo()</code> 方法得到哪些修改的类（比如 SecondActivity），然后再通过反射循环拿到每个修改类在当前环境中的的class，将其中类型为 <code>ChangeQuickRedirect</code> 的静态变量反射修改为 <code>xxxPatchControl.java</code> 这个class new 出来的对象。</p>
<p>用官方的一种图很好的表达了替换原理。</p>
<p><img src="http://7xs23g.com1.z0.glb.clouddn.com/patching.png" alt="Robust"></p>
<h2 id="补丁加载过程分析"><a href="#补丁加载过程分析" class="headerlink" title="补丁加载过程分析"></a>补丁加载过程分析</h2><p>demo中的补丁加载就一句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> PatchExecutor(getApplicationContext(), <span class="keyword">new</span> PatchManipulateImp(),  <span class="keyword">new</span> Callback()).start();</div></pre></td></tr></table></figure>
<p><code>PatchExecutor</code> 是个 Thread</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public class PatchExecutor extends Thread &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        ...</div><div class="line">        applyPatchList(patches);</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 应用补丁列表</div><div class="line">     */</div><div class="line">    protected void applyPatchList(List&lt;Patch&gt; patches) &#123;</div><div class="line">        ...</div><div class="line">        for (Patch p : patches) &#123;</div><div class="line">            ...</div><div class="line">            currentPatchResult = patch(context, p);</div><div class="line">            ...</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected boolean patch(Context context, Patch patch) &#123;</div><div class="line">        ...</div><div class="line">        DexClassLoader classLoader = new DexClassLoader(patch.getTempPath(), context.getCacheDir().getAbsolutePath(),</div><div class="line">                null, PatchExecutor.class.getClassLoader());</div><div class="line">        patch.delete(patch.getTempPath());</div><div class="line">        ...</div><div class="line">        try &#123;</div><div class="line">            patchsInfoClass = classLoader.loadClass(patch.getPatchesInfoImplClassFullName());</div><div class="line">            patchesInfo = (PatchesInfo) patchsInfoClass.newInstance();</div><div class="line">            &#125; catch (Throwable t) &#123;</div><div class="line">             ...</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">        for (PatchedClassInfo patchedClassInfo : patchedClasses) &#123;</div><div class="line">            ...</div><div class="line">            try &#123;</div><div class="line">                oldClass = classLoader.loadClass(patchedClassName.trim());</div><div class="line">                Field[] fields = oldClass.getDeclaredFields();</div><div class="line">                for (Field field : fields) &#123;</div><div class="line">                    if (TextUtils.equals(field.getType().getCanonicalName(), ChangeQuickRedirect.class.getCanonicalName()) &amp;&amp; TextUtils.equals(field.getDeclaringClass().getCanonicalName(), oldClass.getCanonicalName())) &#123;</div><div class="line">                        changeQuickRedirectField = field;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                ...</div><div class="line">                try &#123;</div><div class="line">                    patchClass = classLoader.loadClass(patchClassName);</div><div class="line">                    Object patchObject = patchClass.newInstance();</div><div class="line">                    changeQuickRedirectField.setAccessible(true);</div><div class="line">                    changeQuickRedirectField.set(null, patchObject);</div><div class="line">                    &#125; catch (Throwable t) &#123;</div><div class="line">                    ...</div><div class="line">                &#125;</div><div class="line">            &#125; catch (Throwable t) &#123;</div><div class="line">                 ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>开启一个子线程，通过指定的路径去读patch文件的jar包，patch文件可以为多个，每个patch文件对应一个 DexClassLoader 去加载，每个patch文件中存在PatchInfoImp，通过遍历其中的类信息进而反射修改其中 <code>ChangeQuickRedirect</code> 对象的值。</p>
<h2 id="基础包插桩过程分析"><a href="#基础包插桩过程分析" class="headerlink" title="基础包插桩过程分析"></a>基础包插桩过程分析</h2><p>类似 InstantRun ， Robust 也是使用 Transform API 修改字节码文件，该 API 允许第三方插件在  .class 文件打包为 dex 文件之前操作编译好的 .class 字节码文件。</p>
<p>Robust 中的 <code>Gradle-Plugin</code> 就是操作字节码的名为 <code>robust</code> 的 gradle 插件项目。我们来简单看下实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobustTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project target)</span> </span>&#123;</div><div class="line">            <span class="comment">//解析项目下robust.xml配置文件</span></div><div class="line">            robust = <span class="keyword">new</span> XmlSlurper().parse(<span class="keyword">new</span> File(<span class="string">"$&#123;project.projectDir&#125;/$&#123;Constants.ROBUST_XML&#125;"</span>))</div><div class="line">            ...</div><div class="line">            project.android.registerTransform(<span class="keyword">this</span>)</div><div class="line">            project.afterEvaluate(<span class="keyword">new</span> RobustApkHashAction())</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(Context context, Collection&lt;TransformInput&gt; inputs, Collection&lt;TransformInput&gt; referencedInputs, TransformOutputProvider outputProvider, <span class="keyword">boolean</span> isIncremental)</span> <span class="keyword">throws</span> IOException, TransformException, InterruptedException </span>&#123;</div><div class="line">    ...</div><div class="line">    ClassPool classPool = <span class="keyword">new</span> ClassPool()</div><div class="line">    project.android.bootClasspath.each &#123;</div><div class="line">        logger.debug <span class="string">"android.bootClasspath   "</span> + (String) it.absolutePath</div><div class="line">        classPool.appendClassPath((String) it.absolutePath)</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    def box = ConvertUtils.toCtClasses(inputs, classPool)</div><div class="line">    insertRobustCode(box, jarFile)</div><div class="line">    writeMap2File(methodMap, Constants.METHOD_MAP_OUT_PATH)</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先读取 robust.xml 配置文件并初始化，可配置选项包括：</p>
<ul>
<li>一些开关选项</li>
<li>需要热补丁的包名或者类名，这些包名下的所有类都被会插入代码</li>
<li>不需要热补的包名或者类名，可以在需要热补的包中剔除指定的类或者包</li>
</ul>
<p>然后通过 <code>Transform</code> API 调用 <code>transform()</code> 方法，扫描所有类加入到 <code>classPool</code> 中，调用 <code>insertRobustCode()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="function">def <span class="title">insertRobustCode</span><span class="params">(List&lt;CtClass&gt; box, File jarFile)</span> </span>&#123;</div><div class="line">    ZipOutputStream outStream=<span class="keyword">new</span> JarOutputStream(<span class="keyword">new</span> FileOutputStream(jarFile));</div><div class="line">    <span class="keyword">new</span> ForkJoinPool().submit &#123;</div><div class="line">        box.each &#123; ctClass -&gt;</div><div class="line">            <span class="keyword">if</span> (isNeedInsertClass(ctClass.getName())) &#123;</div><div class="line">               <span class="comment">//将class设置为public ctClass.setModifiers(AccessFlag.setPublic(ctClass.getModifiers()))</span></div><div class="line">                <span class="keyword">boolean</span> addIncrementalChange = <span class="keyword">false</span>;</div><div class="line">                ctClass.declaredBehaviors.findAll &#123;</div><div class="line">                <span class="comment">//规避接口和无方法类</span></div><div class="line">                    <span class="keyword">if</span> (ctClass.isInterface() || ctClass.declaredMethods.length &lt; <span class="number">1</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (!addIncrementalChange) &#123;</div><div class="line">                    <span class="comment">//插入 public static ChangeQuickRedirect changeQuickRedirect;</span></div><div class="line">                        addIncrementalChange = <span class="keyword">true</span>;</div><div class="line">                        ClassPool classPool = it.declaringClass.classPool</div><div class="line">                        CtClass type = classPool.getOrNull(Constants.INTERFACE_NAME);</div><div class="line">                        CtField ctField = <span class="keyword">new</span> CtField(type, Constants.INSERT_FIELD_NAME, ctClass);</div><div class="line">                        ctField.setModifiers(AccessFlag.PUBLIC | AccessFlag.STATIC)</div><div class="line">                        ctClass.addField(ctField)</div><div class="line">                        logger.debug <span class="string">"ctClass: "</span> + ctClass.getName();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (it.getMethodInfo().isStaticInitializer()) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="comment">// synthetic 方法暂时不aop 比如AsyncTask 会生成一些同名 synthetic方法,对synthetic 以及private的方法也插入的代码，主要是针对lambda表达式</span></div><div class="line">                    <span class="keyword">if</span> ((it.getModifiers() &amp; AccessFlag.SYNTHETIC) != <span class="number">0</span> &amp;&amp; !AccessFlag.isPrivate(it.getModifiers())) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//不支持构造方法</span></div><div class="line">                    <span class="keyword">if</span> (it.getMethodInfo().isConstructor()) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//规避抽象方法</span></div><div class="line">                    <span class="keyword">if</span> ((it.getModifiers() &amp; AccessFlag.ABSTRACT) != <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//规避NATIVE方法</span></div><div class="line">                    <span class="keyword">if</span> ((it.getModifiers() &amp; AccessFlag.NATIVE) != <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//规避接口</span></div><div class="line">                    <span class="keyword">if</span> ((it.getModifiers() &amp; AccessFlag.INTERFACE) != <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (it.getMethodInfo().isMethod()) &#123;</div><div class="line">                        <span class="keyword">if</span> (AccessFlag.isPackage(it.modifiers)) &#123;</div><div class="line">                            it.setModifiers(AccessFlag.setPublic(it.modifiers))</div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">//判断是否有方法调用，返回是否插庄</span></div><div class="line">                        <span class="keyword">boolean</span> flag = modifyMethodCodeFilter(it)</div><div class="line">                        <span class="keyword">if</span> (!flag) &#123;</div><div class="line">                            <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//方法过滤</span></div><div class="line">                    <span class="keyword">if</span> (isExceptMethodLevel &amp;&amp; exceptMethodList != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">for</span> (String exceptMethod : exceptMethodList) &#123;</div><div class="line">                            <span class="keyword">if</span> (it.name.matches(exceptMethod)) &#123;</div><div class="line">                                <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (isHotfixMethodLevel &amp;&amp; hotfixMethodList != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">for</span> (String name : hotfixMethodList) &#123;</div><div class="line">                            <span class="keyword">if</span> (it.name.matches(name)) &#123;</div><div class="line">                                <span class="keyword">return</span> <span class="keyword">true</span></div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">return</span> !isHotfixMethodLevel</div><div class="line">                &#125;.each &#123; ctBehavior -&gt;</div><div class="line">                    <span class="comment">// methodMap must be put here</span></div><div class="line">                    methodMap.put(ctBehavior.longName, insertMethodCount.incrementAndGet());</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (ctBehavior.getMethodInfo().isMethod()) &#123;</div><div class="line">                            <span class="keyword">boolean</span> isStatic = ctBehavior.getModifiers() &amp; AccessFlag.STATIC;</div><div class="line">                            CtClass returnType = ctBehavior.getReturnType0();</div><div class="line">                            String returnTypeString = returnType.getName();</div><div class="line">                            def body = <span class="string">"if ($&#123;Constants.INSERT_FIELD_NAME&#125; != null) &#123;"</span></div><div class="line">                            body += <span class="string">"Object argThis = null;"</span></div><div class="line">                            <span class="keyword">if</span> (!isStatic) &#123;</div><div class="line">                                body += <span class="string">"argThis = \$0;"</span></div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            body += <span class="string">"   if (com.meituan.robust.PatchProxy.isSupport(\$args, argThis, $&#123;Constants.INSERT_FIELD_NAME&#125;, $isStatic, "</span> + methodMap.get(ctBehavior.longName) + <span class="string">")) &#123;"</span></div><div class="line">                            body += getReturnStatement(returnTypeString, isStatic, methodMap.get(ctBehavior.longName));</div><div class="line">                            body += <span class="string">"   &#125;"</span></div><div class="line">                            body += <span class="string">"&#125;"</span></div><div class="line">                            ctBehavior.insertBefore(body);</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">catch</span> (Throwable t ) &#123;</div><div class="line">                        logger.error <span class="string">"ctClass: "</span> + ctClass.getName() + <span class="string">" error: "</span> + t.toString();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                &#125;</div><div class="line">            zipFile(ctClass.toBytecode(),outStream,ctClass.name.replaceAll(<span class="string">"\\."</span>,<span class="string">"/"</span>)+<span class="string">".class"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;.get()</div><div class="line">    outStream.close();</div><div class="line">    logger.debug <span class="string">"robust insertMethodCount: "</span> + insertMethodCount.get()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法做了以下几件事：</p>
<ul>
<li>将class设置为public</li>
<li>规避 接口</li>
<li>规避 无方法类</li>
<li>规避 构造方法</li>
<li>规避 抽象方法</li>
<li>规避 native方法</li>
<li>规避 synthetic方法</li>
<li>过滤配置文件中不需要修复的类</li>
<li>通过 javassist 在类中插入 <code>public static ChangeQuickRedirect changeQuickRedirect;</code></li>
<li>通过 javassist 在方法中插入逻辑代码段</li>
<li>通过 zipFile() 方法写回class文件</li>
</ul>
<p>最后调用 <code>writeMap2File()</code> 将插桩的方法信息写入 robust/methodsMap.robust 文件中，此文件和混淆的mapping文件需要备份。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里本篇文章结束，主要讲了下基础原理、补丁加载流程和插桩过程。我们也可以简单的对 Robust 做下总结。</p>
<p>优点：</p>
<ul>
<li>由于使用多ClassLoader方案（补丁中无新增Activity，所以不算激进类型的动态加载，无需hook system），兼容性和稳定性更好，不存在preverify的问题</li>
<li>由于采用 InstantRun 的热更新机制，所以可以即时生效，不需要重启</li>
<li>支持Android2.3-7.X版本</li>
<li>对性能影响较小，不需要合成patch</li>
<li>支持方法级别的修复，支持静态方法</li>
<li>支持新增方法和类</li>
<li>支持ProGuard的混淆、内联、编译器优化后引起的问题(桥方法、lambda、内部类等)等操作</li>
</ul>
<p>当然，有优点就会有缺点：</p>
<ul>
<li>暂时不支持新增字段，但可以通过新增类解决</li>
<li>暂时不支持修复构造方法，已经在内测</li>
<li>暂时不支持资源和 so 修复，不过这个问题不大，因为独立于 dex 补丁，已经有很成熟的方案了，就看怎么打到补丁包中以及 diff 方案。</li>
<li>对于返回值是 this 的方法支持不太好</li>
<li><strong>没有安全校验，需要开发者在加载补丁之前自己做验证</strong></li>
<li>可能会出现深度方法内联导致的不可预知的错误(几率很小可以忽略)</li>
</ul>
<p>总的来说，Robust是可用的、高稳定性的、成功率很高（官方说99.9%）的、无侵入的一款优秀的热修复框架。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://tech.meituan.com/android_robust.html" target="_blank" rel="external">Android热更新方案Robust</a></li>
<li><a href="http://tech.meituan.com/android_autopatch.html" target="_blank" rel="external">Android热更新方案Robust开源，新增自动化补丁工具
</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26036302" target="_blank" rel="external">热修复框架研究之Robust原理</a></li>
</ul>
<p>本文链接： <a href="http://w4lle.com/2017/03/31/robust-0/">http://w4lle.com/2017/03/31/robust-0/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早在16年9月份，美团技术团队就写过一篇文章描述 Android 热补丁框架Robust的简单实现原理，但是并没有开源；然后在17年3月份，美团团队宣布正式开源 Robust并且配套了自动打补丁包工具。本系列文章主要解析Robust实现原理，分为几个方面&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;补丁加载过程&lt;/li&gt;
&lt;li&gt;基础包插桩过程&lt;/li&gt;
&lt;li&gt;补丁包生成过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文为第一篇，主要讲解补丁加载过程和基础包插桩过程，分析版本 &lt;code&gt;0.3.2&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://w4lle.com/tags/Android/"/>
    
      <category term="热补丁" scheme="http://w4lle.com/tags/%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>再见，薄荷！</title>
    <link href="http://w4lle.com/2017/03/08/goodbye-boohee/"/>
    <id>http://w4lle.com/2017/03/08/goodbye-boohee/</id>
    <published>2017-03-07T16:00:00.000Z</published>
    <updated>2017-03-08T12:56:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015.3.23 - 2017.3.8 </p>
<p>两年时光，匆匆而逝。</p>
<p>来到薄荷已经两年时间，说长不长，说短不短。</p>
<a id="more"></a>
<p>两年来在公司也成长了很多，包括技术和技术以外的其他东西。</p>
<p>薄荷是很注重技术氛围的公司，我们的技术团队是我工作以来技术氛围最为浓厚的团队，具体体现在每周三晚的技术分享和每周末每人一篇的技术博客。坚持写作是薄荷长久以来的优秀传统，我之前一直在CSDN写博客，隔三差五写一篇有时候不够积极，但是从加入薄荷后写作的积极性也有了提高，个人博客从2016年搭建至今也持续写了一些文章，其中包括一些质量还不错的文章被广泛阅读，一年的时间博客也有了6w的访问量，虽然不多，对我来说也是一种激励，说明分享的东西也会对别人有用。</p>
<p>至于Android组，我们有充分自由的技术栈选择，在可用性和稳定性的前提下，都可以引入项目中使用。在这两年时间里，我也主动承担了一些基础工作，慢慢也成长为Android组的负责人，有付出就会有回报，不用着急，想要的，时光都会给你。两年时间更新了多少版本已经记不得，但是每一个版本更新都有我的付出。有过开心，有过失落，不管怎样，这段工作已经过去，付出的汗水终究没有白费。</p>
<p>要感谢stormzhang对我工作的信任和帮助，也要谢谢skykai、loody、ttdevs这些小伙伴们，是大家的工作态度让我们这个团队这么有凝聚力。每当别人问起你心中的理想团队是什么样子，我都会毫不犹豫的回答，我现在所在的团队就是我向往的团队。大家对技术的热情，工作的积极态度，团队足够open的氛围，遇到问题永不服输的精神，生活中的互相帮助，碰巧也有共同的爱好，我说这就是我理想的团队。</p>
<p>在薄荷的这两年，也完成了人生中的两件大事。结婚、生子。我很感恩。感恩有个贤惠的媳妇儿，感恩我们有健康漂亮的小jojo，自从有了jojo我们家欢笑就没断过，每天哈哈哈。男人不就是这样，妻儿老小一人扛，家庭幸福比啥都强。希望时间可以慢点走，我们的小jojo慢慢健康长大，让我们多享受小jojo成长带给我们的快乐。</p>
<p>由于个人原因离开公司，今天下午办的离职手续，临走之前，提交了最后一行代码，commit message是“Goodbye”。团队小伙伴们一直把我送到地铁站才离去，我的心里也是很多不舍，但是人生不就是这样么，天下没有不散的筵席，只能心中默念祝大家都好！</p>
<p>虽然有些不舍，但我心里更多的是对新生活的期待，期待美好的明天，期待给家人一个稳定的家，期待简单的稳稳的幸福。期待父母身体健康，期待老婆贤惠漂亮，期待jojo健康成长。期待永远年轻，永远热泪盈眶，永远相信梦想。</p>
<p>已经远去的，带着美好记忆挥挥手说声拜拜。</p>
<p>将要到来的，怀着期待张开双手迎接未来。</p>
<p>再见，薄荷。</p>
<p>你好，明天。</p>
<p>本文链接： <a href="http://w4lle.com/2017/03/08/goodbye-boohee/">http://w4lle.com/2017/03/08/goodbye-boohee/</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015.3.23 - 2017.3.8 &lt;/p&gt;
&lt;p&gt;两年时光，匆匆而逝。&lt;/p&gt;
&lt;p&gt;来到薄荷已经两年时间，说长不长，说短不短。&lt;/p&gt;
    
    </summary>
    
    
      <category term="其他" scheme="http://w4lle.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
</feed>
